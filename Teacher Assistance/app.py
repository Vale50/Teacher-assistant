import os
import sys
# Database initialization should NOT be skipped in production
# os.environ['SKIP_DB_INIT'] = '1'
# os.environ['SQLALCHEMY_DATABASE_URI_BLOCK'] = '1'
from flask import Flask, request, jsonify, send_from_directory, url_for
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
from flask_mail import Mail, Message as MailMessage
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime, timedelta
from itsdangerous import URLSafeTimedSerializer
import uuid
from sqlalchemy import func, case
import logging
import json
from dotenv import load_dotenv
import stripe
import time
from functools import wraps
import sqlite3
import jwt
from flask import current_app
from extensions import db
from sqlalchemy import create_engine, event, inspect
from sqlalchemy.pool import QueuePool
from sqlalchemy.engine import Engine
from flask import Flask, request, jsonify, render_template_string, redirect, url_for
from flask_cors import CORS
from werkzeug.utils import secure_filename
import mysql.connector
from flask_jwt_extended import create_access_token
from mysql.connector import Error
import anthropic
from sqlalchemy import exc
import hashlib
import logging
from PIL import Image
import base64
from flask import Flask, send_from_directory
from flask_mail import Mail, Message as MailMessage
from sqlalchemy import func
from logging.handlers import RotatingFileHandler
from flask import send_file, make_response
import io
from docx import Document
from docx.shared import Pt, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
import tempfile
import pdfkit
from flask import render_template
from werkzeug.security import generate_password_hash, check_password_hash
import secrets
import requests
from sqlalchemy.exc import OperationalError, SQLAlchemyError
import logging
import traceback
from markupsafe import Markup
import html
from sqlalchemy.pool import Pool
from sqlalchemy import text
from anthropic import Anthropic
from twilio.rest import Client as TwilioClient
# auth_bp import moved to after app creation (line ~250) to avoid import errors
from flask import Blueprint
from auth.models import FlashcardSet, Flashcard
from google.oauth2 import id_token
from survey.routes import register_blueprint as register_survey_blueprint
from test_endpoint import test_bp
from google.auth.transport import requests as google_requests
from games import register_blueprint as register_games_blueprint
from flashcard import register_blueprint as register_flashcard_blueprint
from math_graph import register_math_graph_blueprint
from lesson_plan import register_lesson_plan_blueprint
from auth.models import db, User, Enrollment, Subscription, Quiz, QuizSubmission
from xwhy_creator.routes import register_blueprint as register_xwhy_blueprint
from coach import register_blueprint as register_coach_blueprint
from routes.affiliate_routes import affiliate_bp
from services.commission_service import CommissionService
from services.commission_service import WebhookHandler
# auth_bp import removed (duplicate) - imported after app creation
from auth.models import BlogSubscription, GeometryQuiz, GeometryQuizSubmission, LessonPlanModel, MathLessonPlanModel, QuizMasRegistration, QuizMasGameResult
from auth.models import WebinarRegistration, WebinarFeedback
from auth.models import ParentFeedback
from auth.models import Student
from auth.models import Tutor
from auth.models import Admin, AdminResource, AdminAssignment, WithdrawalRequest, Message
from auth.models import SupportChatSession, SupportChatMessage
from auth.models import ACardTransaction
from auth.models import LearnEarnConfig
from auth.models import StudentTask
from auth.models import TaskNotification
from auth.models import StudentLevel
from auth.models import TaskTemplate
from auth.models import SchoolCircle
from auth.models import CircleActivity
from auth.models import (
    Coach, CoachCourse, CoachCourseLesson, CoachS3Upload,
    CoachStudentEnrollment, CoachTask, CoachTaskAssignment, CoachAnalytics
)
from auth.models import create_notification
from auth.models import create_acard_transaction
from auth.models import get_student_level
from auth.models import calculate_level_progress
from auth.models import init_default_data
from auth.models import WorksheetQuestion
from auth.models import Worksheet
from auth.models import WorksheetTemplate
from auth.models import WorksheetAnalytics
from auth.models import WorksheetSubmission
from auth.models import ExtraTimeRequest
from auth.models import StudentLevel
from auth.models import Subject, StudentSubject, Skill, StudentSkill
from auth.models import (
    TutoringTutor, TutoringStudent, TutoringSession,
    TutoringReview, TutoringCertificate, TutoringAdminAction
)
from sqlalchemy import event, exc, text
from sqlalchemy.pool import Pool
from flask import Flask
from flask_jwt_extended import JWTManager
from geometry_backend_integration import setup_geometry_quiz_integration
from renderer_migration import create_renderer_for_app, get_unified_renderer
from unified_shape_renderer import render_shape_unified
from template_routes import template_bp
from migration_routes import migration_bp
import matplotlib
matplotlib.use('Agg')  
import matplotlib.pyplot as plt
import numpy as np
from sqlalchemy.exc import SQLAlchemyError, OperationalError
from flask import Flask, request, jsonify, send_file, make_response, send_from_directory, abort
from typing import List, Dict, Optional, Set, Tuple


# Initialize logging
logging.basicConfig(level=logging.DEBUG,
                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)
quiz_modes_bp = Blueprint('quiz_modes', __name__)

# Load environment variables
load_dotenv()
CLAUDE_API_KEY = os.getenv('CLAUDE_API_KEY')
MYSQL_URL = os.getenv('MYSQL_URL')
STRIPE_SECRET_KEY = os.getenv('STRIPE_SECRET_KEY')
JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')
MAIL_SERVER = os.getenv('MAIL_SERVER', 'smtp.gmail.com')
MAIL_PORT = int(os.getenv('MAIL_PORT', 587))
MAIL_USERNAME = os.getenv('MAIL_USERNAME')
MAIL_PASSWORD = os.getenv('MAIL_PASSWORD')
MAIL_DEFAULT_SENDER = os.getenv('MAIL_DEFAULT_SENDER')

# Initialize Flask app
app = Flask(__name__, static_folder='static', static_url_path='/static', template_folder='templates')
# Database URI will be set later after proper configuration
# app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('MYSQL_URL')

# CORS configuration moved to line 653 to avoid conflicts

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# NOTE: app is already created above at line 135, don't recreate it!

# Get MySQL URL from environment
MYSQL_URL = os.getenv('MYSQL_URL')

if not MYSQL_URL:
    logger.warning('âš ï¸ MYSQL_URL environment variable not set - using SQLite database')
    database_uri = 'sqlite:///app.db'
else:
    # Convert mysql:// to mysql+pymysql:// for SQLAlchemy
    database_uri = MYSQL_URL.replace('mysql://', 'mysql+pymysql://')

# Add connection parameters to prevent timeouts (if not already in URL)
# Only add MySQL-specific parameters if using MySQL
if MYSQL_URL and not database_uri.startswith('sqlite'):
    if '?' not in database_uri:
        database_uri += '?'
        database_uri += 'charset=utf8mb4&'
    else:
        if 'charset' not in database_uri:
            database_uri += '&charset=utf8mb4&'

    # Remove trailing & if present
    database_uri = database_uri.rstrip('&')

logger.info(f'ðŸ”— Connecting to database: {database_uri.split("@")[1].split("/")[0] if "@" in database_uri else "unknown"}')

# =============================================================================
# FLASK-SQLALCHEMY CONFIGURATION (CRITICAL: Set BEFORE init_app)
# =============================================================================

# Flask-SQLAlchemy Configuration - update the existing app config
app.config['SQLALCHEMY_DATABASE_URI'] = database_uri
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SQLALCHEMY_ECHO'] = False  # Set to True for debugging
app.config['SQLALCHEMY_RECORD_QUERIES'] = False  # Disable for performance

# CRITICAL: Railway + comprehensive fix optimized connection pool settings
app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {
    # Connection Pool Settings
    'pool_size': 10,                     # Max persistent connections
    'max_overflow': 20,                  # Max overflow connections
    'pool_timeout': 30,                  # Seconds to wait for connection
    'poolclass': QueuePool,              # Use QueuePool for better management
    
    # Connection Health & Recycling - CRITICAL FIXES
    'pool_pre_ping': True,               # CRITICAL: Test connection before use (prevents null errors)
    'pool_recycle': 280,                 # CRITICAL: Recycle before Railway's 5-min timeout
    
    # MySQL Connection Settings
    'connect_args': {
        'charset': 'utf8mb4',
        'connect_timeout': 10,           # Initial connection timeout
        'read_timeout': 30,              # Query read timeout
        'write_timeout': 30,             # Query write timeout
        'use_unicode': True,
    }
}

# =============================================================================
# JWT CONFIGURATION
# =============================================================================
app.config['JWT_SECRET_KEY'] = JWT_SECRET_KEY or 'dtTHo1VSKHmNz3LXG_LjKPBwz8tnN0BTAiMgYrCWXbA'
# Ensure JWT_SECRET_KEY variable matches app.config for consistency
JWT_SECRET_KEY = app.config['JWT_SECRET_KEY']
app.config['JWT_TOKEN_LOCATION'] = ['headers']
app.config['JWT_HEADER_NAME'] = 'Authorization'
app.config['JWT_HEADER_TYPE'] = 'Bearer'
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = False  # Tokens don't expire

# Initialize JWT Manager
jwt_manager = JWTManager(app)  # Renamed to avoid shadowing jwt module
logger.info(f"âœ… JWT Manager initialized with secret key: {JWT_SECRET_KEY[:10]}...")

# JWT Error Handlers
@jwt_manager.expired_token_loader
def expired_token_callback(jwt_header, jwt_payload):
    """Handle expired token errors"""
    logger.warning(f"Expired token attempted access: {jwt_payload}")
    return jsonify({
        'error': 'Token has expired',
        'message': 'Your session has expired. Please login again.'
    }), 401

@jwt_manager.invalid_token_loader
def invalid_token_callback(error):
    """Handle invalid token errors"""
    logger.warning(f"Invalid token attempted access: {error}")
    return jsonify({
        'error': 'Invalid token',
        'message': 'The authentication token is invalid. Please login again.'
    }), 401

@jwt_manager.unauthorized_loader
def missing_token_callback(error):
    """Handle missing token errors"""
    logger.warning(f"Missing token attempted access: {error}")
    return jsonify({
        'error': 'Authorization required',
        'message': 'Authentication token is missing. Please login.'
    }), 401

@jwt_manager.revoked_token_loader
def revoked_token_callback(jwt_header, jwt_payload):
    """Handle revoked token errors"""
    logger.warning(f"Revoked token attempted access: {jwt_payload}")
    return jsonify({
        'error': 'Token has been revoked',
        'message': 'This token has been revoked. Please login again.'
    }), 401

logger.info("âœ… JWT error handlers configured")

def blocked_create_all(*args, **kwargs):
    logger.warning("âš ï¸ db.create_all() BLOCKED - tables must exist in database")
    pass

db.create_all = blocked_create_all
logger.info("âœ… Table creation disabled")
# =============================================================================
# INITIALIZE SQLALCHEMY (CRITICAL: Do this ONCE and ONLY ONCE)
# =============================================================================

# IMPORTANT: Only call init_app ONCE
# If db is already created elsewhere (like at top of file), don't recreate it
# Assuming you have: db = SQLAlchemy() at the top of your file
db.init_app(app)

logger.info('âœ… SQLAlchemy initialized with app')

# Import auth_bp after app and db are initialized
from auth.routes import auth_bp
logger.info('âœ… Auth blueprint imported')

# STEP 3: Patch SQLAlchemy to remove all relationships at runtime
with app.app_context():
    try:
        # Import all models
        from auth.models import *
        logger.info("âœ… Models imported")
        
        # CRITICAL: Remove all relationships that cause errors
        problematic_models = [
            'Affiliate',
            'QuizTeam',
            'WorksheetAnalytics',
            'WorksheetSubmission',
            'ExtraTimeRequest',
            'LessonPlanEvaluation',
            'StudentEvaluationAttempt',
            'LessonPlanSection',
            'PublishedLessonPlan',
            'TeamSubmission',
            'Referral',
            'Commission',
            'Payout',
            'AffiliateClick',
            'AffiliateProductLink'
        ]
        
        # Remove relationships from mapper
        from sqlalchemy.orm import class_mapper
        
        for model_name in problematic_models:
            try:
                if model_name in globals():
                    model = globals()[model_name]
                    mapper = class_mapper(model)
                    
                    # Remove all relationships
                    relationships_to_remove = []
                    for key, relationship in mapper.relationships.items():
                        relationships_to_remove.append(key)
                    
                    for key in relationships_to_remove:
                        try:
                            delattr(model, key)
                            logger.info(f"âœ… Removed relationship '{key}' from {model_name}")
                        except:
                            pass
            except Exception as e:
                logger.debug(f"Note for {model_name}: {e}")
        
        logger.info("âœ… All problematic relationships removed")
        
    except Exception as e:
        logger.error(f"Model import note: {e}")
# =============================================================================
# CONNECTION HEALTH MONITORING EVENTS
# =============================================================================

# ============================================================================
# DATABASE CONNECTION MONITORING
# ============================================================================
@event.listens_for(Engine, "connect")
def receive_connect(dbapi_conn, connection_record):
    """Set MySQL session variables on new connections"""
    try:
        with dbapi_conn.cursor() as cursor:
            cursor.execute("SET SESSION wait_timeout=300")
            cursor.execute("SET SESSION interactive_timeout=300")
        logger.info('âœ… New database connection established')
    except Exception as e:
        logger.warning(f'âš ï¸ Could not set session variables: {e}')

@event.listens_for(Pool, "checkout")
def receive_checkout(dbapi_conn, connection_record, connection_proxy):
    """Verify connection before use"""
    try:
        with dbapi_conn.cursor() as cursor:
            cursor.execute("SELECT 1")
    except Exception as e:
        logger.warning(f'ðŸ’€ Dead connection detected: {e}')
        raise exc.DisconnectionError()

# ============================================================================
# HEALTH CHECK ENDPOINTS (CRITICAL - MUST BE FIRST)
# ============================================================================
@app.route("/")
def root():
    return "OK", 200

@app.route("/", methods=["GET", "HEAD"])
def health():
    return "OK", 200    
@app.route('/api/health')
def api_healths():
    """Health check with database connection test"""
    try:
        db.session.execute(text('SELECT 1'))
        return {'status': 'healthy', 'database': 'connected'}, 200
    except Exception as e:
        logger.error(f'Health check failed: {e}')
        return {'status': 'unhealthy', 'database': 'disconnected', 'error': str(e)}, 503

logger.info('âœ… Health check endpoints ready')

# ============================================================================
# REQUEST LIFECYCLE
# ============================================================================
@app.before_request
def before_request():
    """
    REMOVED: Database connection check on every request
    Reason: pool_pre_ping=True already handles dead connections efficiently.
    The SELECT 1 check on every request was causing 504 timeouts due to:
    - Added latency on every request
    - Connection pool contention with multiple workers
    - Unnecessary database round-trips
    """
    # Debug coach login requests (keeping this for debugging purposes)
    if '/api/coach/auth/login' in request.path:
        logger.info(f"========== COACH LOGIN REQUEST ==========")
        logger.info(f"Method: {request.method}")
        logger.info(f"Path: {request.path}")
        logger.info(f"Endpoint: {request.endpoint}")
        logger.info(f"View function: {app.view_functions.get(request.endpoint)}")
        logger.info(f"=========================================")

    # No database check needed - pool_pre_ping handles this automatically

@app.teardown_appcontext
def shutdown_session(exception=None):
    """Clean up database session after request"""
    try:
        if exception:
            logger.error(f'âŒ Request exception: {exception}')
            db.session.rollback()
        else:
            try:
                db.session.commit()
            except Exception as commit_error:
                logger.error(f'âŒ Commit error: {commit_error}')
                db.session.rollback()
    except Exception as e:
        logger.error(f'âŒ Teardown error: {e}')
        try:
            db.session.rollback()
        except:
            pass
    finally:
        try:
            db.session.remove()
        except Exception as remove_error:
            logger.error(f'âš ï¸ Error removing session: {remove_error}')

# ============================================================================
# ERROR HANDLERS
# ============================================================================
@app.errorhandler(exc.OperationalError)
def handle_db_operational_error(error):
    logger.error(f'ðŸ’¥ Database operational error: {error}')
    try:
        db.session.rollback()
        db.session.remove()
    except:
        pass
    return {'error': 'Database connection error. Please try again.'}, 503

@app.errorhandler(500)
def handle_internal_error(error):
    logger.error(f'ðŸ’¥ Internal server error: {error}')
    try:
        db.session.rollback()
    except:
        pass
    return {'error': 'Internal server error'}, 500

# ============================================================================
# TOKEN DECORATOR
# ============================================================================
def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if request.method == 'OPTIONS':
            return '', 204
            
        token = request.headers.get('Authorization')
        if not token:
            return jsonify({'error': 'Token is missing'}), 401
        
        try:
            from auth.models import User
            token = token.split(' ')[1]
            data = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            current_user = User.query.get(data['user_id'])
            
            if not current_user or not current_user.is_active:
                return jsonify({'error': 'Invalid user'}), 401
                
            return f(current_user, *args, **kwargs)
            
        except Exception as e:
            logger.error(f"Auth error: {str(e)}")
            return jsonify({'error': 'Invalid token'}), 401
            
    return decorated

# ============================================================================
# IMPORT AND REGISTER BLUEPRINTS
# ============================================================================



# Import main routes
try:
    import routes
    logger.info('âœ… Main routes imported')
except Exception as e:
    logger.error(f'âŒ Routes import error: {e}')

# ============================================================================
# STARTUP MESSAGE
# ============================================================================
logger.info('=' * 60)
logger.info('âœ… DECIPHER ACADEMY API READY')
logger.info('=' * 60)



# =============================================================================
# UTILITY FUNCTIONS - NEW
# =============================================================================

def execute_with_retry(func, max_retries=3, delay=0.5):
    """
    Execute a database function with automatic retry on connection failure
    Useful for critical operations
    
    Usage:
        result = execute_with_retry(lambda: Quiz.query.filter_by(id=quiz_id).first())
    """
    import time
    
    for attempt in range(max_retries):
        try:
            return func()
        except (exc.OperationalError, exc.DisconnectionError) as e:
            if attempt == max_retries - 1:
                logger.error(f'âŒ All retry attempts failed: {e}')
                raise
            logger.warning(f'âš ï¸ Database error (attempt {attempt + 1}/{max_retries}): {e}')
            time.sleep(delay * (attempt + 1))  # Exponential backoff
            try:
                db.session.rollback()
                db.session.remove()
            except:
                pass

# =============================================================================
# HEALTH CHECK ENDPOINT
# =============================================================================

# Add reconnection handling
@event.listens_for(Pool, "checkout")
def checkout_db_connection(dbapi_connection, connection_record, connection_proxy):
    """Ensure the connection is alive before using it"""
    try:
        cursor = dbapi_connection.cursor()
        cursor.execute("SELECT 1")
        cursor.close()
    except Exception as e:
        # Connection is dead, raise DisconnectionError to get a new connection
        logger.warning(f"Dead database connection detected: {str(e)}")
        raise exc.DisconnectionError()

# Add connection management for  MySQL
@event.listens_for(Pool, "connect")
def set_mysql_params(dbapi_connection, connection_record):
    """Set MySQL connection parameters for better stability"""
    if 'mysql' in str(type(dbapi_connection)):
        # Set connection timeout parameters
        cursor = dbapi_connection.cursor()
        cursor.execute("SET SESSION wait_timeout=300")
        cursor.execute("SET SESSION interactive_timeout=300")
        cursor.execute("SET SESSION net_read_timeout=600")
        cursor.execute("SET SESSION net_write_timeout=600")
        cursor.close()

def check_database():
    try:
        with app.app_context():
            print("ðŸ” Checking database...")

            # Check users table structure
            inspector = inspect(db.engine)

            if 'users' in inspector.get_table_names():
                columns = inspector.get_columns('users')
                for col in columns:
                    if col['name'] == 'id':
                        print(f"âœ… users.id type: {col['type']}")
                        return col['type']
            else:
                print("âš ï¸ users table doesn't exist yet")
                return None
    except Exception as e:
        print(f"âš ï¸ Database check failed (non-fatal): {e}")
        print("âš ï¸ App will continue without database connection")
        return None

def fix_incompatible_tables():
    with app.app_context():
        print("ðŸ”§ Fixing incompatible tables...")
        
        # Drop only the problematic table
        db.engine.execute(text('DROP TABLE IF EXISTS enrollments'))
        print("âœ… Dropped enrollments table")
        
        # Recreate it
        from models import Enrollment
        Enrollment.__table__.create(db.engine)
        print("âœ… Recreated enrollments table")

if __name__ == '__main__':
    check_database()
    
# Configure mail
# Flask-Mail configuration
app.config['MAIL_SERVER'] = 'smtp.gmail.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USERNAME'] = 'Decipheracad140@gmail.com'
app.config['MAIL_PASSWORD'] = 'pffwopglcdyytnhi'
app.config['MAIL_DEFAULT_SENDER'] = 'Decipheracad140@gmail.com'

# Google OAuth configuration
# Set your Google Client ID as an environment variable or directly here
os.environ['GOOGLE_CLIENT_ID'] = '587123593268-765h8r0680mgtqvc3coko7dg66gqf7n2.apps.googleusercontent.com'

# Initialize extensions
mail = Mail(app)
serializer = URLSafeTimedSerializer(JWT_SECRET_KEY) if JWT_SECRET_KEY else None

# Configure Anthropic client
anthropic_api_key = os.getenv('ANTHROPIC_API_KEY')
if anthropic_api_key:
    anthropic_client = anthropic.Anthropic(api_key=anthropic_api_key)
    logger.info("âœ“ Anthropic client initialized")
else:
    anthropic_client = None
    logger.warning("âš ï¸ ANTHROPIC_API_KEY not set - AI features will be disabled")

# Configure Stripe
if STRIPE_SECRET_KEY:
    stripe.api_key = STRIPE_SECRET_KEY
    logger.info("âœ“ Stripe configured")
else:
    logger.warning("âš ï¸ STRIPE_SECRET_KEY not set - payment features will be disabled")

# Helper function for subscription check
def is_premium_endpoint(path, method):
    # List of premium endpoints that require subscription
    premium_endpoints = [
        # Quiz Creator endpoints
      #  {'path': '/api/generate-quiz', 'method': 'POST'},
      #  {'path': '/api/regenerate-question', 'method': 'POST'},
        
        # Lesson Planner endpoints
      #  {'path': '/api/generate-lesson-plan', 'method': 'POST'},
      #  {'path': '/api/generate-lesson-content', 'method': 'POST'},
        
        # Video Quiz endpoints
        {'path': '/video-quiz/api/generate-questions', 'method': 'POST'},
        {'path': '/video-quiz/api/generate-summary', 'method': 'POST'},
    ]
    
    # Check if the current request matches any premium endpoint
    for endpoint in premium_endpoints:
        if path == endpoint['path'] and method == endpoint['method']:
            return True
            
    # Also check path patterns with wildcards
    pattern_endpoints = [
        # Example: any path starting with /api/premium/
        {'pattern': r'^/api/premium/', 'method': 'ANY'}
    ]
    
    for pattern in pattern_endpoints:
        if re.match(pattern['pattern'], path) and (pattern['method'] == 'ANY' or method == pattern['method']):
            return True
            
    return False

# Register the blueprint
app.register_blueprint(affiliate_bp)

from services.commission_service import CommissionService
print("Commission service loaded successfully")


# Define models
# In your models.py or equivalent file

# Register authentication routes

# Define token_required decorator
def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        # Skip for OPTIONS requests (CORS preflight)
        if request.method == 'OPTIONS':
            return '', 204
            
        # Get user from token
        token = request.headers.get('Authorization')
        if not token:
            return jsonify({'error': 'Token is missing'}), 401
        
        try:
            token = token.split(' ')[1]  # Remove 'Bearer ' prefix
            data = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            current_user = User.query.get(data['user_id'])
            
            if not current_user:
                return jsonify({'error': 'User not found'}), 401
                
            if not current_user.is_active:
                return jsonify({'error': 'User account is inactive'}), 401
            
            # Add subscription check for premium endpoints
            if is_premium_endpoint(request.path, request.method):
                # Check subscription or trial status
                has_active_subscription = False
                
                # Check trial period
                if current_user.trial_ends_at and current_user.trial_ends_at > datetime.utcnow():
                    has_active_subscription = True
                else:
                    # Check for active subscription
                    subscription = Subscription.query.filter_by(
                        user_id=current_user.id,
                        status='active'
                    ).first()
                    
                    if subscription and subscription.ends_at > datetime.utcnow():
                        has_active_subscription = True
                
                if not has_active_subscription:
                    return jsonify({
                        'error': 'Subscription required',
                        'message': 'Your free trial has ended. Please subscribe to continue using this service.'
                    }), 403
                
            return f(current_user, *args, **kwargs)
            
        except Exception as e:
            logger.error(f"Auth error: {str(e)}")
            return jsonify({'error': 'Invalid token'}), 401
            
    return decorated
# Setup CORS
CORS(app, resources={
    r"/*": {
      "origins": ["*"],
        "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        "allow_headers": ["Content-Type", "Authorization"],
        "expose_headers": ["Content-Type"],
        "supports_credentials": True
    }
})

# Add explicit CORS headers to all responses (helps with DO App Platform proxy)
@app.after_request
def after_request(response):
    """Add CORS headers to all responses - use set() to avoid duplicates"""
    origin = request.headers.get('Origin', '*')
    response.headers.set('Access-Control-Allow-Origin', origin)
    response.headers.set('Access-Control-Allow-Headers', 'Content-Type,Authorization')
    response.headers.set('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE,OPTIONS')
    response.headers.set('Access-Control-Allow-Credentials', 'true')
    return response

@app.route('/')
def health_checks():
    """Fast health check for load balancer"""
    return {'status': 'ok'}, 200

@app.route('/ping')
def ping():
    """Ultra-fast ping endpoint"""
    return 'pong', 200

anthropic_client = anthropic.Anthropic(
    api_key=os.getenv('ANTHROPIC_API_KEY')
)
logger.info(f"Anthropic API key configured: {bool(os.getenv('ANTHROPIC_API_KEY'))}")

# Import and register blueprints
try:
    from Decipher_VideoAI.video_quiz_blueprint import video_quiz_bp
    app.register_blueprint(video_quiz_bp, url_prefix='/video-quiz')
    print(f"Blueprint imported successfully: {video_quiz_bp}")
except ImportError as e:
    print(f"Failed to import Video Quiz blueprint: {e}")
    try:
        from Decipher_videoAI.video_quiz_blueprint import video_quiz_bp
        app.register_blueprint(video_quiz_bp, url_prefix='/video-quiz')
    except ImportError:
        print("Video Quiz feature will be disabled")

# Register auth blueprint
app.register_blueprint(auth_bp, url_prefix='/api/auth')
app.register_blueprint(test_bp, url_prefix='/api')
from quiz_modes import quiz_modes_bp
app.register_blueprint(quiz_modes_bp)

# Register student profile routes
from routes.student_profile_routes import student_profile_bp
from routes.portfolio_routes import portfolio_bp
from routes.scheme_of_work_routes import scheme_of_work_bp
app.register_blueprint(student_profile_bp)
app.register_blueprint(portfolio_bp)
app.register_blueprint(scheme_of_work_bp)

# Register messaging routes (super-admin <-> student messaging)
from routes.messaging_routes import messaging_bp
app.register_blueprint(messaging_bp)

# Register template and migration blueprints
app.register_blueprint(template_bp)
app.register_blueprint(migration_bp)

# Register survey blueprint
survey_bp = register_survey_blueprint(app, CLAUDE_API_KEY)

# Parse MYSQL_URL for coach blueprint database configuration
# Format: mysql://user:password@host:port/database
if MYSQL_URL:
    import re
    match = re.match(r'mysql://([^:]+):([^@]+)@([^:]+):(\d+)/(.+)', MYSQL_URL)
    if match:
        DB_CONFIG = {
            'host': match.group(3),
            'user': match.group(1),
            'password': match.group(2),
            'database': match.group(5),
            'port': int(match.group(4)),
            'charset': 'utf8mb4',
            'use_unicode': True,
            'autocommit': False
        }
    else:
        # Fallback for URLs without port
        match = re.match(r'mysql://([^:]+):([^@]+)@([^/]+)/(.+)', MYSQL_URL)
        if match:
            DB_CONFIG = {
                'host': match.group(3),
                'user': match.group(1),
                'password': match.group(2),
                'database': match.group(4),
                'port': 3306,
                'charset': 'utf8mb4',
                'use_unicode': True,
                'autocommit': False
            }
        else:
            DB_CONFIG = {}
else:
    DB_CONFIG = {}

# Register coach blueprint
logger.info("=" * 60)
logger.info("ATTEMPTING TO REGISTER COACH BLUEPRINT")
logger.info(f"DB_CONFIG keys: {list(DB_CONFIG.keys()) if DB_CONFIG else 'EMPTY'}")
logger.info("=" * 60)

try:
    coach_bp = register_coach_blueprint(app, DB_CONFIG)
    logger.info("âœ“ Coach Management module registered successfully")
    logger.info(f"âœ“ Coach blueprint URL prefix: /api/coach")

    # List coach routes
    coach_routes = [rule for rule in app.url_map.iter_rules() if 'coach' in str(rule)]
    logger.info(f"âœ“ Found {len(coach_routes)} coach routes:")
    for route in coach_routes:
        logger.info(f"  - {route.rule} | Methods: {list(route.methods)}")

    print("Coach Management module registered successfully")
except Exception as e:
    logger.error(f"âœ— Coach Management module failed to register: {e}")
    logger.error(f"âœ— Exception type: {type(e).__name__}")
    import traceback
    logger.error(f"âœ— Traceback:\n{traceback.format_exc()}")

# Register enrollment blueprint with database configuration
try:
    from routes.enrollment_routes import register_blueprint as register_enrollment_blueprint
    enrollment_bp = register_enrollment_blueprint(app, DB_CONFIG)
    logger.info("âœ“ Enrollment module registered successfully")
    logger.info(f"âœ“ Enrollment blueprint URL prefix: /api/enrollment")
except Exception as e:
    logger.error(f"âœ— Enrollment module failed to register: {e}")
    import traceback
    logger.error(f"âœ— Traceback:\n{traceback.format_exc()}")

# Add this where you register other blueprints
try:
    games_bp = register_games_blueprint(app, app.config.get('CLAUDE_API_KEY'))
    print("Games module registered successfully")
except ImportError:
    print("Games module not found. This feature will be disabled.")

# Register flashcard blueprint
try:
    flashcard_bp = register_flashcard_blueprint(app, claude_api_key=os.getenv('CLAUDE_API_KEY'))
    print("Flashcard module registered successfully")
except (ImportError, Exception) as e:
    print(f"Flashcard module not loaded: {e}. This feature will be disabled.")

# Register math graph blueprint
try:
    math_graph_bp = register_math_graph_blueprint(app)
    print("Math Graph module registered successfully")
except (ImportError, Exception) as e:
    print(f"Math Graph module not loaded: {e}. This feature will be disabled.")

# Register lesson plan blueprint
try:
    lesson_plan_bp = register_lesson_plan_blueprint(app)
    print("Lesson Plan module registered successfully")
except (ImportError, Exception) as e:
    print(f"Lesson Plan module not loaded: {e}. This feature will be disabled.")

# Register tutoring blueprint
try:
    from tutoring import register_blueprint as register_tutoring_blueprint
    tutoring_bp = register_tutoring_blueprint(app)
    print("âœ“ Tutoring module registered successfully at /tutoring")
except (ImportError, Exception) as e:
    print(f"Tutoring module not loaded: {e}. This feature will be disabled.")

# Add this route for the flashcard creator page
@app.route('/flashcard-creator')
def serve_flashcard_creator():
    return send_from_directory('.', 'flashcard-creator.html')

@app.route('/flashcard-l-reator.html')
def serve_flashcard_l_creator():
    return send_from_directory('.', 'flashcard-l-creator.html')    

# Add this route for the flashcard viewer page
@app.route('/flashcards.html')
def serve_flashcards():
    return send_from_directory('.', 'flashcards.html')

@app.route('/flashcards')
def serve_flashcards_no_ext():
    return send_from_directory('.', 'flashcards.html')

# Add route for the flashcard quiz page
@app.route('/flashcard-quiz.html')
def serve_flashcard_quiz():
    return send_from_directory('.', 'flashcard-quiz.html')

@app.route('/flashcard-quiz')
def serve_flashcard_quiz_no_ext():
    return send_from_directory('.', 'flashcard-quiz.html')

# Initialize the games package
def register_blueprint(app, claude_api_key=None):
    from games.routes import games_bp
    app.register_blueprint(games_bp, url_prefix='/api/games')
    return games_bp
# Register the X-Why-Creator blueprint
def register_all_blueprints(app):
    # ... your existing blueprint registrations
    
    # Add the X-Why-Creator blueprint
    xwhy_bp = register_xwhy_blueprint(app, CLAUDE_API_KEY)
    print("X-Why-Creator module registered successfully")



# Add this after creating all your routes
@app.route('/game-creator.html')
def serve_game_creator():
    return send_from_directory('static', 'game-creator.html')

# Register Stripe webhook
def register_blueprints(app):
    from stripe_webhook_handler import register_blueprint
    stripe_webhook_bp = register_blueprint(app, db)
    return stripe_webhook_bp


# Function to generate a verification token
def generate_verification_token():
    token = secrets.token_urlsafe(32)
    verification_token_expires = datetime.utcnow() + timedelta(days=1)
    return token, verification_token_expires  

# Function to send verification email
def send_verification_email(user_email, token):
    verification_url = f"{request.host_url.rstrip('/')}/verify-email/{token}"
    
    msg = MailMessage(
        'Verify Your Decipher Learning Account',
        sender=app.config['MAIL_DEFAULT_SENDER'],
        recipients=[user_email]
    )
    
    msg.body = f"""
    Hello,
    
    Thank you for registering with Decipher Learning Platform!
    
    To verify your email address and activate your account, please click the link below:
    
    {verification_url}
    
    This link will expire in 24 hours.
    
    If you didn't create this account, you can safely ignore this email.
    
    Best regards,
    The Decipher Learning Team
    """
    
    msg.html = f"""
    <p>Hello,</p>
    <p>Thank you for registering with Decipher Learning Platform!</p>
    <p>To verify your email address and activate your account, please click the button below:</p>
    <p><a href="{verification_url}" style="display: inline-block; padding: 10px 20px; background-color: #4F46E5; color: white; text-decoration: none; border-radius: 5px;">Verify My Email</a></p>
    <p>This link will expire in 24 hours.</p>
    <p>If you didn't create this account, you can safely ignore this email.</p>
    <p>Best regards,<br>The Decipher Learning Team</p>
    """
    
    mail.send(msg)

# Add this right after your Flask app initialization
UPLOAD_FOLDER = os.path.join('static', 'lesson_images')
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

# Set proper permissions (if on Linux)
try:
    os.chmod(UPLOAD_FOLDER, 0o755)
except Exception as e:
    logger.warning(f"Could not set folder permissions: {e}")

# Add this test endpoint temporarily
from functools import wraps
import jwt
from flask import request, jsonify

# Student authentication decorator
def student_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        try:
            # Get token from Authorization header
            auth_header = request.headers.get('Authorization')
            if not auth_header or not auth_header.startswith('Bearer '):
                logger.warning('No valid authorization header')
                return jsonify({'error': 'No valid token provided'}), 401
                
            token = auth_header.split(' ')[1]
            
            try:
                # Decode and verify token
                payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
                # Support both 'student_id' (direct jwt.encode) and 'sub' (flask_jwt_extended)
                student_id = payload.get('student_id') or payload.get('sub')

                if not student_id:
                    logger.warning('Token missing student_id and sub')
                    return jsonify({'error': 'Invalid token format'}), 401
                
                # Get student from database
                student = Student.query.get(student_id)
                if not student:
                    logger.warning(f'Student not found: {student_id}')
                    return jsonify({'error': 'Student not found'}), 404
                
                # Check if student is active
                if not student.is_active:
                    logger.warning(f'Inactive student attempted access: {student_id}')
                    return jsonify({'error': 'Student account is inactive'}), 403
                
                # Add student to request context
                request.current_student = student
                logger.info(f'Student authenticated: {student.name} ({student.email})')
                
            except jwt.ExpiredSignatureError:
                logger.warning('Expired token')
                return jsonify({'error': 'Token has expired'}), 401
            except jwt.InvalidTokenError as e:
                logger.warning(f'Invalid token: {str(e)}')
                return jsonify({'error': 'Invalid token'}), 401
            
            return f(*args, **kwargs)
            
        except Exception as e:
            logger.error(f"Student authentication error: {str(e)}")
            return jsonify({'error': 'Authentication failed'}), 500
    
    return decorated_function
    
# 1. Email Verification Endpoint
@app.route('/api/check-email', methods=['POST'])
def check_email():
    data = request.json
    email = data.get('email')
    
    if not email:
        return jsonify({'error': 'Email is required'}), 400
    
    # Basic format validation
    if '@' not in email or '.' not in email:
        return jsonify({'error': 'Invalid email format'}), 400
    
    # Check if email already exists
    user = User.query.filter_by(email=email).first()
    if user:
        return jsonify({'error': 'Email already exists'}), 400
    
    # Optional: Check if email domain exists (basic check)
    domain = email.split('@')[1]
    try:
        import socket
        socket.gethostbyname(domain)
    except:
        return jsonify({'error': 'Invalid email domain'}), 400
    
    return jsonify({'valid': True}), 200

# 2. Resend Verification Email Endpoint
@app.route('/api/resend-verification', methods=['POST'])
def resend_verification():
    data = request.json
    email = data.get('email')
    
    if not email:
        return jsonify({'error': 'Email is required'}), 400
    
    user = User.query.filter_by(email=email).first()
    if not user:
        return jsonify({'error': 'User not found'}), 404
    
    if user.email_verified:
        return jsonify({'message': 'Email already verified'}), 200
    
    # Generate new verification token
    token, expires = generate_verification_token()
    user.verification_token = token
    user.verification_token_expires = expires
    db.session.commit()
    
    # Send verification email
    try:
        send_verification_email(user.email, token)
        return jsonify({'success': True, 'message': 'Verification email sent'}), 200
    except Exception as e:
        return jsonify({'error': f'Failed to send email: {str(e)}'}), 500

# 3. Verify Email Endpoint
@app.route('/verify-email/<token>', methods=['GET'])
def verify_email(token):
    user = User.query.filter_by(verification_token=token).first()
    
    if not user:
        return "Invalid or expired verification link", 400
    
    if user.verification_token_expires < datetime.utcnow():
        return "Verification link has expired. Please request a new one.", 400
    
    user.email_verified = True
    user.verification_token = None
    user.verification_token_expires = None
    db.session.commit()
    
    # Redirect to a success page
    return """
    <html>
    <head>
        <title>Email Verified</title>
        <style>
            body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
            .success { color: #10B981; font-size: 24px; margin-bottom: 20px; }
            .btn { display: inline-block; padding: 10px 20px; background-color: #4F46E5; color: white; 
                   text-decoration: none; border-radius: 5px; margin-top: 20px; }
        </style>
    </head>
<body>
        <div class="success">Email Successfully Verified!</div>
        <p>Your account has been activated. You can now log in to Decipher Learning Platform.</p>
        <a href="/index.html" class="btn">Go to Login</a>
    </body>
    </html>
    """

# 4. Update Register Endpoint to Include Verification
# Updated login endpoint with email verification check
@app.route('/api/login', methods=['POST'])
def login():
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400
            
        if 'email' not in data or 'password' not in data:
            return jsonify({'error': 'Email and password are required'}), 400
        
        try:
            user = User.query.filter_by(email=data['email']).first()
        except Exception as db_error:
            logger.error(f"Database error during login: {str(db_error)}")
            return jsonify({'error': 'Database error', 'details': str(db_error)}), 500
            
        if not user or not check_password_hash(user.password_hash, data['password']):
            return jsonify({'error': 'Invalid email or password'}), 401
        
        # Check if email is verified (if user was registered via email)
        if user.auth_provider == 'email' and not user.email_verified:
            return jsonify({'error': 'Please verify your email before logging in', 'requires_verification': True}), 401
            
        # Update last login
        try:
            user.last_login = datetime.utcnow()
            db.session.commit()
        except Exception as commit_error:
            logger.error(f"Error updating last login: {str(commit_error)}")
            db.session.rollback()
            # Continue anyway - this isn't critical
        
        # Generate JWT token
        try:
            token = jwt.encode(
                {'user_id': user.id, 'exp': datetime.utcnow() + timedelta(days=1)},
                JWT_SECRET_KEY,
                algorithm='HS256'
            )
        except Exception as token_error:
            logger.error(f"Error generating token: {str(token_error)}")
            return jsonify({'error': 'Authentication error', 'details': str(token_error)}), 500
        
        return jsonify({
            'token': token,
            'user': {
                'id': user.id,
                'name': user.name,
                'email': user.email,
                'trial_ends_at': user.trial_ends_at.isoformat() if user.trial_ends_at else None
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Login error: {str(e)}")
        return jsonify({'error': 'Login failed', 'details': str(e)}), 500

# Updated registration endpoint with email verification
@app.route('/api/register', methods=['POST', 'OPTIONS'])
def register():
    # Handle OPTIONS request for CORS
    if request.method == 'OPTIONS':
        return '', 204
        
    try:
        # Log the incoming request
        logger.debug(f"Received registration request: {request.get_json()}")
        
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400
            
        # Validate required fields
        required_fields = ['name', 'email', 'password', 'country']
        missing_fields = [field for field in required_fields if field not in data]
        if missing_fields:
            return jsonify({'error': f'Missing required fields: {", ".join(missing_fields)}'}), 400
            
        # Check if user already exists
        if User.query.filter_by(email=data['email']).first():
            return jsonify({'error': 'Email already registered'}), 400
        
        # Generate verification token
        verification_token, token_expiry = generate_verification_token()
            
        # Create new user
        new_user = User(
            name=data['name'],
            email=data['email'],
            password_hash=generate_password_hash(data['password']),
            country=data['country'],
            trial_ends_at=datetime.utcnow() + timedelta(days=7),
            is_active=True,
            auth_provider='email',
            email_verified=False,
            verification_token=verification_token,
            verification_token_expires=token_expiry
        )
        
        db.session.add(new_user)
        db.session.commit()
        
        # Send verification email
        email_sent = send_verification_email(new_user.email, verification_token)
        
        # Return different responses based on whether we require email verification before login
        # Option 1: Require email verification before allowing login
        return jsonify({
            'message': 'Registration successful! Please check your email to verify your account.',
            'email_verification_sent': email_sent,
            'user': {
                'id': new_user.id,
                'name': new_user.name,
                'email': new_user.email,
                'requires_verification': True
            }
        }), 201
        
        
    except Exception as e:
        logger.error(f"Registration error: {str(e)}")
        return jsonify({'error': str(e)}), 500

# 6. Google Login Endpoint
# Add this improved implementation for Google Sign-In

@app.route('/api/google-login', methods=['POST'])
def google_login():
    """Handle Google Sign-In"""
    try:
        # Log the request
        logger.info("Received Google login request")
        
        data = request.get_json()
        if not data:
            logger.error("No JSON data in request")
            return jsonify({'error': 'No data provided'}), 400
            
        token = data.get('credential') or data.get('token')
        
        if not token:
            logger.error("No token provided in request")
            return jsonify({'error': 'Token is required'}), 400
        
        try:
            # Get Google client ID from environment
            client_id = os.environ.get('GOOGLE_CLIENT_ID', '587123593268-765h8r0680mgtqvc3coko7dg66gqf7n2.apps.googleusercontent.com')
            
            # Manual token verification using JWT library
            # This is a fallback in case the Google client library isn't working
            try:
                # Get the header and payload from the JWT token
                token_parts = token.split('.')
                if len(token_parts) != 3:
                    logger.error("Invalid token format")
                    return jsonify({'error': 'Invalid token format'}), 400
                
                # Decode the payload
                import base64
                import json
                
                # Ensure proper padding for base64 decoding
                def fix_padding(s):
                    padding = len(s) % 4
                    if padding:
                        s += '=' * (4 - padding)
                    return s
                
                # Extract payload
                payload_b64 = fix_padding(token_parts[1])
                try:
                    payload = json.loads(base64.b64decode(payload_b64))
                except Exception as decode_error:
                    logger.error(f"Failed to decode token payload: {str(decode_error)}")
                    return jsonify({'error': 'Invalid token payload'}), 400
                
                # Extract user info
                google_id = payload.get('sub')
                email = payload.get('email')
                name = payload.get('name')
                
                if not google_id or not email:
                    logger.error("Missing user information in token")
                    return jsonify({'error': 'Invalid token: missing user information'}), 400
                
                # Check if the token is intended for our client ID
                if payload.get('aud') != client_id:
                    logger.error(f"Token audience mismatch: {payload.get('aud')} vs {client_id}")
                    return jsonify({'error': 'Invalid token: audience mismatch'}), 400
                
            except Exception as verification_error:
                logger.error(f"Token verification error: {str(verification_error)}")
                return jsonify({'error': f'Token verification failed: {str(verification_error)}'}), 400
            
            logger.info(f"Successfully verified Google token for user: {email}")
            
            # Find if user exists by email or Google ID
            try:
                user = User.query.filter((User.email == email) | (User.google_id == google_id)).first()
                
                if not user:
                    logger.info(f"No user found with Google ID: {google_id} or email: {email}")
                    # Auto-register the user if not found
                    try:
                        # Create new user
                        new_user = User(
                            id=str(uuid.uuid4()),
                            name=name or email.split('@')[0],
                            email=email,
                            password_hash=None,  # No password for Google users
                            country="Unknown",  # Default value
                            trial_ends_at=datetime.utcnow() + timedelta(days=7),  # 7-day trial
                            is_active=True,
                            email_verified=True,  # Gmail emails are pre-verified
                            google_id=google_id,
                            auth_provider='google'
                        )
                        
                        db.session.add(new_user)
                        db.session.commit()
                        logger.info(f"Auto-registered Google user: {email}")
                        
                        user = new_user  # Use the newly created user
                    except Exception as reg_error:
                        logger.error(f"Failed to auto-register Google user: {str(reg_error)}")
                        db.session.rollback()
                        return jsonify({'error': 'Registration failed. Please try again or use email signup.'}), 500
                
                # Update Google ID if not set
                if user and not user.google_id:
                    user.google_id = google_id
                    user.auth_provider = 'google'
                    db.session.commit()
                    logger.info(f"Updated Google ID for user: {email}")
                
                # Update last login
                user.last_login = datetime.utcnow()
                db.session.commit()
                
                # Generate JWT token
                token_payload = {
                    'user_id': user.id,
                    'exp': datetime.utcnow() + timedelta(days=1)
                }
                
                jwt_token = jwt.encode(
                    token_payload,
                    JWT_SECRET_KEY,
                    algorithm='HS256'
                )
                
                logger.info(f"Successfully logged in Google user: {email}")
                
                return jsonify({
                    'token': jwt_token,
                    'user': {
                        'id': user.id,
                        'name': user.name,
                        'email': user.email,
                        'country': user.country,
                        'trial_ends_at': user.trial_ends_at.isoformat() if user.trial_ends_at else None
                    }
                }), 200
                
            except Exception as db_error:
                logger.error(f"Database error during Google login: {str(db_error)}")
                db.session.rollback()
                raise
                
        except Exception as verification_error:
            logger.error(f"Token verification error: {str(verification_error)}")
            return jsonify({'error': f'Token verification failed: {str(verification_error)}'}), 400
            
    except Exception as e:
        logger.error(f"Google login error: {str(e)}")
        return jsonify({'error': 'Login failed. Please try again or use email login.'}), 500

# Also improve the Google registration endpoint
@app.route('/api/google-register', methods=['POST'])
def google_register():
    """Handle Google Sign-Up"""
    try:
        # Log the request
        logger.info("Received Google registration request")
        
        data = request.get_json()
        if not data:
            logger.error("No JSON data in request")
            return jsonify({'error': 'No data provided'}), 400
            
        token = data.get('credential') or data.get('token')
        country = data.get('country', 'Unknown')
        
        if not token:
            logger.error("No token provided in request")
            return jsonify({'error': 'Token is required'}), 400
        
        try:
            # Get Google client ID from environment
            client_id = os.environ.get('GOOGLE_CLIENT_ID', '587123593268-765h8r0680mgtqvc3coko7dg66gqf7n2.apps.googleusercontent.com')
            
            # Manual token verification
            try:
                # Get the payload from the JWT token
                token_parts = token.split('.')
                if len(token_parts) != 3:
                    logger.error("Invalid token format")
                    return jsonify({'error': 'Invalid token format'}), 400
                
                # Decode the payload
                import base64
                import json
                
                # Ensure proper padding for base64 decoding
                def fix_padding(s):
                    padding = len(s) % 4
                    if padding:
                        s += '=' * (4 - padding)
                    return s
                
                # Extract payload
                payload_b64 = fix_padding(token_parts[1])
                try:
                    payload = json.loads(base64.b64decode(payload_b64))
                except Exception as decode_error:
                    logger.error(f"Failed to decode token payload: {str(decode_error)}")
                    return jsonify({'error': 'Invalid token payload'}), 400
                
                # Extract user info
                google_id = payload.get('sub')
                email = payload.get('email')
                name = payload.get('name')
                
                if not google_id or not email:
                    logger.error("Missing user information in token")
                    return jsonify({'error': 'Invalid token: missing user information'}), 400
                
                # Check if the token is intended for our client ID
                if payload.get('aud') != client_id:
                    logger.error(f"Token audience mismatch: {payload.get('aud')} vs {client_id}")
                    return jsonify({'error': 'Invalid token: audience mismatch'}), 400
                
            except Exception as verification_error:
                logger.error(f"Token verification error: {str(verification_error)}")
                return jsonify({'error': f'Token verification failed: {str(verification_error)}'}), 400
            
            logger.info(f"Successfully verified Google token for registration: {email}")
            
            # Check if user exists
            try:
                user = User.query.filter((User.email == email) | (User.google_id == google_id)).first()
                
                if user:
                    logger.info(f"User already exists with Google ID or email: {email}")
                    return jsonify({
                        'success': False, 
                        'error': 'User already exists with this email or Google account. Please login instead.',
                        'should_login': True
                    }), 400
                
                # Create new user
                new_user = User(
                    id=str(uuid.uuid4()),
                    name=name or email.split('@')[0],
                    email=email,
                    password_hash=None,  # No password for Google users
                    country=country,
                    trial_ends_at=datetime.utcnow() + timedelta(days=7),  # 7-day trial
                    is_active=True,
                    email_verified=True,  # Gmail emails are pre-verified
                    google_id=google_id,
                    auth_provider='google'
                )
                
                db.session.add(new_user)
                db.session.commit()
                logger.info(f"Successfully registered Google user: {email}")
                
                # Generate JWT token for automatic login
                token_payload = {
                    'user_id': new_user.id,
                    'exp': datetime.utcnow() + timedelta(days=1)
                }
                
                jwt_token = jwt.encode(
                    token_payload,
                    JWT_SECRET_KEY,
                    algorithm='HS256'
                )
                
                return jsonify({
                    'success': True,
                    'message': 'Registration with Google successful',
                    'token': jwt_token,
                    'user': {
                        'id': new_user.id,
                        'name': new_user.name,
                        'email': new_user.email,
                        'country': new_user.country,
                        'trial_ends_at': new_user.trial_ends_at.isoformat() if new_user.trial_ends_at else None
                    }
                }), 201
                
            except Exception as db_error:
                logger.error(f"Database error during Google registration: {str(db_error)}")
                db.session.rollback()
                raise
                
        except Exception as verification_error:
            logger.error(f"Token verification error: {str(verification_error)}")
            return jsonify({'error': f'Token verification failed: {str(verification_error)}'}), 400
            
    except Exception as e:
        logger.error(f"Google registration error: {str(e)}")
        return jsonify({'error': 'Registration failed. Please try again or use email signup.'}), 500

from contextlib import contextmanager

@contextmanager
def db_transaction():
    """Context manager for database transactions with proper cleanup"""
    try:
        yield db.session
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        logger.error(f"Database transaction error: {str(e)}")
        raise
    finally:
        db.session.close()

# Enhanced JWT token validation
def validate_token(token):
    """Validate JWT token and return payload"""
    try:
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
        logger.info(f"Token payload: {payload}")
        return payload
    except jwt.ExpiredSignatureError:
        logger.warning("Token has expired")
        return None
    except jwt.InvalidTokenError as e:
        logger.warning(f"Invalid token: {str(e)}")
        return None

# Admin required decorator with proper session handling
def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        token = None
        auth_header = request.headers.get('Authorization')
        logger.info(f"Auth header: {auth_header}")
        
        if auth_header and auth_header.startswith('Bearer '):
            token = auth_header.split(' ')[1]
            logger.info(f"Extracted token: {token[:20]}...")
        
        if not token:
            return jsonify({'error': 'Token is missing'}), 401
        
        payload = validate_token(token)
        if not payload:
            return jsonify({'error': 'Token is invalid or expired'}), 401
        
        try:
            admin = Admin.query.filter_by(
                id=payload['admin_id'],
                is_active=True
            ).first()
            
            if not admin:
                return jsonify({'error': 'Admin not found or inactive'}), 401
            
            # Store admin in request context
            request.current_admin = admin
            logger.info(f"Admin authenticated: {admin.name} ({admin.email})")
                
        except Exception as e:
            logger.error(f"Admin validation error: {str(e)}")
            return jsonify({'error': 'Authentication failed'}), 401
        
        return f(*args, **kwargs)
    
    return decorated_function

@app.route('/api/admin/login', methods=['POST'])
def admin_login():
    """Admin login with enhanced error handling and session management"""
    try:
        data = request.get_json()
        if not data or not all(key in data for key in ['email', 'password']):
            return jsonify({'error': 'Email and password are required'}), 400
        
        email = data['email'].strip().lower()
        password = data['password']
        
        # Direct database query without transaction context manager
        admin = Admin.query.filter_by(email=email).first()
        
        if not admin:
            return jsonify({'error': 'Invalid email or password'}), 401
        
        if not admin.password_hash:
            logger.error(f"Admin {admin.email} has no password hash")
            return jsonify({'error': 'Account setup incomplete. Please contact system administrator.'}), 401
        
        # Verify password
        if not check_password_hash(admin.password_hash, password):
            return jsonify({'error': 'Invalid email or password'}), 401
        
        if not admin.is_active:
            return jsonify({'error': 'Admin account is deactivated'}), 401
        
        # Update last login
        admin.last_login = datetime.utcnow()
        db.session.commit()
        
        # Generate JWT token
        token_payload = {
            'admin_id': admin.id,
            'email': admin.email,
            'role': admin.role,
            'iat': datetime.utcnow(),
            'exp': datetime.utcnow() + timedelta(hours=24)
        }
        
        token = jwt.encode(token_payload, JWT_SECRET_KEY, algorithm='HS256')
        
        return jsonify({
            'message': 'Login successful',
            'token': token,
            'admin': {
                'id': admin.id,
                'name': admin.name,
                'email': admin.email,
                'role': admin.role
            }
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Admin login error: {str(e)}")
        return jsonify({'error': 'Login failed'}), 500

@app.route('/api/admin/refresh-token', methods=['POST'])
@admin_required
def refresh_admin_token():
    """Refresh admin JWT token"""
    try:
        admin = request.current_admin
        
        # Generate new token
        token_payload = {
            'admin_id': admin.id,
            'email': admin.email,
            'role': admin.role,
            'iat': datetime.utcnow(),
            'exp': datetime.utcnow() + timedelta(hours=24)
        }
        
        token = jwt.encode(token_payload, JWT_SECRET_KEY, algorithm='HS256')
        
        return jsonify({
            'message': 'Token refreshed successfully',
            'token': token
        }), 200
        
    except Exception as e:
        logger.error(f"Token refresh error: {str(e)}")
        return jsonify({'error': 'Token refresh failed'}), 500

@app.route('/api/admin/change-password', methods=['POST'])
def change_admin_password():
    """Change admin password endpoint"""
    try:
        data = request.get_json()
        if not data or not all(key in data for key in ['email', 'current_password', 'new_password']):
            return jsonify({'error': 'Email, current password, and new password are required'}), 400
        
        email = data['email'].strip().lower()
        current_password = data['current_password']
        new_password = data['new_password']
        
        # Validate new password strength
        if len(new_password) < 8:
            return jsonify({'error': 'New password must be at least 8 characters long'}), 400
        
        # Check for password complexity
        import re
        if not re.search(r'[A-Z]', new_password):
            return jsonify({'error': 'New password must contain at least one uppercase letter'}), 400
        if not re.search(r'[a-z]', new_password):
            return jsonify({'error': 'New password must contain at least one lowercase letter'}), 400
        if not re.search(r'\d', new_password):
            return jsonify({'error': 'New password must contain at least one number'}), 400
        if not re.search(r'[!@#$%^&*()_+\-=\[\]{};\':"\\|,.<>\/?]', new_password):
            return jsonify({'error': 'New password must contain at least one special character'}), 400
        
        with db_transaction() as session:
            admin = session.query(Admin).filter_by(email=email).first()
            
            if not admin:
                return jsonify({'error': 'Admin not found'}), 404
            
            if not admin.password_hash:
                logger.error(f"Admin {admin.email} has no password hash")
                return jsonify({'error': 'Account setup incomplete. Please contact system administrator.'}), 401
            
            # Verify current password
            if not check_password_hash(admin.password_hash, current_password):
                return jsonify({'error': 'Current password is incorrect'}), 401
            
            if not admin.is_active:
                return jsonify({'error': 'Admin account is deactivated'}), 401
            
            # Update password
            admin.password_hash = generate_password_hash(new_password)
            session.commit()
            
            logger.info(f"Password changed successfully for admin: {admin.email}")
            
        return jsonify({
            'message': 'Password changed successfully'
        }), 200
        
    except Exception as e:
        logger.error(f"Change password error: {str(e)}")
        return jsonify({'error': 'Failed to change password'}), 500

# Dashboard Routes
@app.route('/api/admin/dashboard/stats', methods=['GET'])
@admin_required
def get_dashboard_stats():
    """Get dashboard statistics with proper session management"""
    try:
        logger.info(f"Dashboard stats requested by admin: {request.current_admin.name}")
        
        with db_transaction() as session:
            # Get all counts in a single transaction
            total_students = session.query(Student).count()
            
            # Active students (logged in within last 7 days)
            week_ago = datetime.utcnow() - timedelta(days=7)
            active_students = session.query(Student).filter(
                Student.last_login >= week_ago
            ).count()
            
            # Task statistics
            total_tasks = session.query(StudentTask).count()
            pending_tasks = session.query(StudentTask).filter_by(status='pending').count()
            completed_tasks = session.query(StudentTask).filter_by(status='completed').count()
            
            # A-Card total value
            acard_sum = session.query(func.sum(Student.acard_balance)).scalar()
            total_acard_value = float(acard_sum) if acard_sum else 0.0
            
            # Recent activity counts
            recent_registrations = session.query(Student).filter(
                Student.created_at >= week_ago
            ).count()
            
            recent_task_assignments = session.query(StudentTask).filter(
                StudentTask.assigned_at >= week_ago
            ).count()
            
            stats = {
                'total_students': total_students,
                'active_students': active_students,
                'total_tasks': total_tasks,
                'pending_tasks': pending_tasks,
                'completed_tasks': completed_tasks,
                'total_acard_value': total_acard_value,
                'recent_registrations': recent_registrations,
                'recent_task_assignments': recent_task_assignments,
                'last_updated': datetime.utcnow().isoformat()
            }
            
        logger.info(f"Dashboard stats returned successfully")
        return jsonify({'stats': stats}), 200
        
    except Exception as e:
        logger.error(f"Dashboard stats error: {str(e)}")
        return jsonify({'error': 'Failed to fetch dashboard stats'}), 500



# Initial Setup Routes
@app.route('/api/admin/create-initial', methods=['POST'])
def create_initial_admin_endpoint():
    """Emergency endpoint to create initial admin - remove in production"""
    try:
        with db_transaction() as session:
            # Check if any admin exists
            admin_count = session.query(Admin).count()
            if admin_count > 0:
                return jsonify({'error': 'Admin users already exist'}), 400
            
            # Create admin with proper password hash
            password_hash = generate_password_hash('admin123')
            
            admin = Admin(
                name='Super Admin',
                email='admin@deciph.ai',
                password_hash=password_hash,
                role='super_admin',
                is_super_admin=True,
                is_active=True,
                created_at=datetime.utcnow()
            )
            
            session.add(admin)
            session.commit()
            
        return jsonify({
            'message': 'Initial admin created successfully',
            'email': 'admin@deciph.ai',
            'password': 'admin123',
            'note': 'Please change the password after first login'
        }), 201
        
    except Exception as e:
        logger.error(f"Error creating initial admin: {str(e)}")
        return jsonify({'error': 'Failed to create admin'}), 500

# Health Check Route
@app.route('/api/health', methods=['GET'])
def health_check():
    """Enhanced health check endpoint with proper session management"""
    try:
        with db_transaction() as session:
            # Test database connection
            session.execute(text('SELECT 1'))
            
            # Get basic stats
            student_count = session.query(Student).count()
            admin_count = session.query(Admin).count()
            
        return jsonify({
            'status': 'healthy',
            'database': 'connected',
            'timestamp': datetime.utcnow().isoformat(),
            'version': '2.0.0',
            'stats': {
                'students': student_count,
                'admins': admin_count
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Health check failed: {str(e)}")
        return jsonify({
            'status': 'unhealthy',
            'database': 'disconnected',
            'error': 'Database connection failed',
            'timestamp': datetime.utcnow().isoformat()
        }), 503

# Debug Routes (Remove in production)
@app.route('/api/debug/check-admin', methods=['GET'])
def debug_check_admin():
    """Debug endpoint to check if admin exists"""
    if not app.debug:
        return jsonify({'error': 'Debug endpoints disabled in production'}), 404
    
    try:
        with db_transaction() as session:
            admins = session.query(Admin).all()
            admin_data = []
            
            for admin in admins:
                admin_data.append({
                    'id': admin.id,
                    'name': admin.name,
                    'email': admin.email,
                    'role': admin.role,
                    'is_active': admin.is_active,
                    'has_password_hash': bool(admin.password_hash),
                    'hash_length': len(admin.password_hash) if admin.password_hash else 0,
                    'created_at': admin.created_at.isoformat() if admin.created_at else None
                })
            
        return jsonify({
            'admin_count': len(admin_data),
            'admins': admin_data
        }), 200
        
    except Exception as e:
        logger.error(f"Debug check admin error: {str(e)}")
        return jsonify({'error': str(e)}), 500
    
# Enhanced Students Endpoint
@app.route('/api/admin/students', methods=['GET'])
@admin_required
def get_all_students():
    """Get all students with enhanced data"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 50, type=int)
        search = request.args.get('search', '')
        grade_filter = request.args.get('grade', '')
        
        # Build query
        query = Student.query
        
        # Apply search filter
        if search:
            query = query.filter(
                db.or_(
                    Student.name.ilike(f'%{search}%'),
                    Student.email.ilike(f'%{search}%')
                )
            )
        
        # Apply grade filter
        if grade_filter:
            query = query.filter(Student.grade_level == grade_filter)
        
        # Paginate results
        students_paginated = query.paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        students_data = []
        for student in students_paginated.items:
            # Count pending tasks for each student
            pending_tasks_count = StudentTask.query.filter_by(
                student_id=student.id, 
                status='pending'
            ).count()
            
            students_data.append({
                'id': student.id,
                'name': student.name,
                'email': student.email,
                'age': getattr(student, 'age', 0),
                'grade_level': getattr(student, 'grade_level', 'N/A'),
                'school_name': getattr(student, 'school_name', 'N/A'),
                'total_points': getattr(student, 'total_points', 0),
                'current_level': getattr(student, 'current_level', 1),
                'acard_balance': float(getattr(student, 'acard_balance', 0) or 0),
                'pending_tasks': pending_tasks_count,
                'is_active': getattr(student, 'is_active', True),
                'created_at': student.created_at.isoformat() if hasattr(student, 'created_at') and student.created_at else None,
                'last_login': student.last_login.isoformat() if hasattr(student, 'last_login') and student.last_login else None
            })
        
        return jsonify({
            'students': students_data,
            'pagination': {
                'page': students_paginated.page,
                'pages': students_paginated.pages,
                'per_page': students_paginated.per_page,
                'total': students_paginated.total,
                'has_next': students_paginated.has_next,
                'has_prev': students_paginated.has_prev
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Get students error: {str(e)}")
        return jsonify({'error': 'Failed to fetch students'}), 500


# ==================== SUBJECT MANAGEMENT ENDPOINTS ====================

@app.route('/api/subjects', methods=['GET'])
def get_all_subjects():
    """Get all active subjects"""
    try:
        subjects = Subject.query.filter_by(is_active=True).all()
        return jsonify({
            'subjects': [subject.to_dict() for subject in subjects]
        }), 200
    except Exception as e:
        logger.error(f"Get subjects error: {str(e)}")
        return jsonify({'error': 'Failed to fetch subjects'}), 500


@app.route('/api/admin/subjects', methods=['GET'])
@admin_required
def admin_get_subjects():
    """Admin endpoint to get all subjects"""
    try:
        subjects = Subject.query.all()
        return jsonify({
            'subjects': [subject.to_dict() for subject in subjects]
        }), 200
    except Exception as e:
        logger.error(f"Admin get subjects error: {str(e)}")
        return jsonify({'error': 'Failed to fetch subjects'}), 500


@app.route('/api/admin/subjects/create', methods=['POST'])
@admin_required
def create_subject():
    """Create a new subject (super admin only)"""
    try:
        # Check if user is super admin
        if request.current_admin.role != 'super_admin':
            return jsonify({'error': 'Only super admins can create subjects'}), 403

        data = request.get_json()
        required_fields = ['name', 'code']

        if not all(field in data for field in required_fields):
            return jsonify({'error': 'Missing required fields: name, code'}), 400

        # Check if subject already exists
        existing = Subject.query.filter_by(code=data['code']).first()
        if existing:
            return jsonify({'error': 'Subject with this code already exists'}), 400

        subject = Subject(
            name=data['name'],
            code=data['code'],
            description=data.get('description'),
            icon_color=data.get('icon_color', '#4A90E2'),
            icon_name=data.get('icon_name')
        )

        db.session.add(subject)
        db.session.commit()

        logger.info(f"Subject created: {subject.name} by admin {request.current_admin.id}")
        return jsonify({
            'message': 'Subject created successfully',
            'subject': subject.to_dict()
        }), 201

    except Exception as e:
        db.session.rollback()
        logger.error(f"Create subject error: {str(e)}")
        return jsonify({'error': 'Failed to create subject'}), 500


@app.route('/api/admin/students/<int:student_id>/subjects', methods=['GET'])
@admin_required
def get_student_subjects(student_id):
    """Get all subjects assigned to a specific student"""
    try:
        student = Student.query.get(student_id)
        if not student:
            return jsonify({'error': 'Student not found'}), 404

        student_subjects = StudentSubject.query.filter_by(
            student_id=student_id,
            is_active=True
        ).all()

        return jsonify({
            'student_id': student_id,
            'student_name': student.name,
            'subjects': [ss.to_dict() for ss in student_subjects]
        }), 200

    except Exception as e:
        logger.error(f"Get student subjects error: {str(e)}")
        return jsonify({'error': 'Failed to fetch student subjects'}), 500


@app.route('/api/admin/students/<int:student_id>/subjects/assign', methods=['POST'])
@admin_required
def assign_subjects_to_student(student_id):
    """Assign subjects to a student"""
    try:
        data = request.get_json()

        if 'subject_ids' not in data or not isinstance(data['subject_ids'], list):
            return jsonify({'error': 'subject_ids must be a list'}), 400

        student = Student.query.get(student_id)
        if not student:
            return jsonify({'error': 'Student not found'}), 404

        assigned = []
        skipped = []
        errors = []

        for subject_id in data['subject_ids']:
            try:
                # Check if subject exists
                subject = Subject.query.get(subject_id)
                if not subject:
                    errors.append(f"Subject {subject_id} not found")
                    continue

                # Check if already assigned
                existing = StudentSubject.query.filter_by(
                    student_id=student_id,
                    subject_id=subject_id
                ).first()

                if existing:
                    if not existing.is_active:
                        # Reactivate if previously deactivated
                        existing.is_active = True
                        existing.assigned_at = datetime.utcnow()
                        existing.admin_id = request.current_admin.id
                        assigned.append(subject.name)
                    else:
                        skipped.append(subject.name)
                    continue

                # Create new assignment
                student_subject = StudentSubject(
                    student_id=student_id,
                    subject_id=subject_id,
                    admin_id=request.current_admin.id,
                    custom_name=data.get('custom_name'),
                    custom_description=data.get('custom_description')
                )

                db.session.add(student_subject)
                assigned.append(subject.name)

            except Exception as e:
                errors.append(f"Error assigning subject {subject_id}: {str(e)}")

        db.session.commit()

        logger.info(f"Subjects assigned to student {student_id} by admin {request.current_admin.id}")

        return jsonify({
            'message': 'Subject assignment completed',
            'assigned': assigned,
            'skipped': skipped,
            'errors': errors
        }), 200

    except Exception as e:
        db.session.rollback()
        logger.error(f"Assign subjects error: {str(e)}")
        return jsonify({'error': 'Failed to assign subjects'}), 500


@app.route('/api/admin/students/subjects/bulk-assign', methods=['POST'])
@admin_required
def bulk_assign_subjects():
    """Bulk assign subjects to multiple students"""
    try:
        data = request.get_json()

        required_fields = ['student_ids', 'subject_ids']
        if not all(field in data for field in required_fields):
            return jsonify({'error': 'Missing required fields: student_ids, subject_ids'}), 400

        if not isinstance(data['student_ids'], list) or not isinstance(data['subject_ids'], list):
            return jsonify({'error': 'student_ids and subject_ids must be lists'}), 400

        results = {
            'total_students': len(data['student_ids']),
            'total_subjects': len(data['subject_ids']),
            'successful_assignments': 0,
            'failed_assignments': 0,
            'details': []
        }

        for student_id in data['student_ids']:
            student = Student.query.get(student_id)
            if not student:
                results['details'].append({
                    'student_id': student_id,
                    'status': 'error',
                    'message': 'Student not found'
                })
                results['failed_assignments'] += 1
                continue

            assigned_subjects = []
            for subject_id in data['subject_ids']:
                try:
                    subject = Subject.query.get(subject_id)
                    if not subject:
                        continue

                    # Check if already assigned
                    existing = StudentSubject.query.filter_by(
                        student_id=student_id,
                        subject_id=subject_id
                    ).first()

                    if existing:
                        if not existing.is_active:
                            existing.is_active = True
                            existing.assigned_at = datetime.utcnow()
                            existing.admin_id = request.current_admin.id
                            assigned_subjects.append(subject.name)
                    else:
                        student_subject = StudentSubject(
                            student_id=student_id,
                            subject_id=subject_id,
                            admin_id=request.current_admin.id
                        )
                        db.session.add(student_subject)
                        assigned_subjects.append(subject.name)

                except Exception as e:
                    logger.error(f"Error assigning subject {subject_id} to student {student_id}: {str(e)}")

            if assigned_subjects:
                results['details'].append({
                    'student_id': student_id,
                    'student_name': student.name,
                    'status': 'success',
                    'subjects': assigned_subjects
                })
                results['successful_assignments'] += 1
            else:
                results['details'].append({
                    'student_id': student_id,
                    'student_name': student.name,
                    'status': 'skipped',
                    'message': 'All subjects already assigned or no valid subjects'
                })

        db.session.commit()

        logger.info(f"Bulk subject assignment completed by admin {request.current_admin.id}")
        return jsonify(results), 200

    except Exception as e:
        db.session.rollback()
        logger.error(f"Bulk assign subjects error: {str(e)}")
        return jsonify({'error': 'Failed to bulk assign subjects'}), 500


@app.route('/api/admin/students/<int:student_id>/subjects/<int:subject_id>', methods=['DELETE'])
@admin_required
def remove_subject_from_student(student_id, subject_id):
    """Remove/deactivate a subject from a student"""
    try:
        student_subject = StudentSubject.query.filter_by(
            student_id=student_id,
            subject_id=subject_id
        ).first()

        if not student_subject:
            return jsonify({'error': 'Subject assignment not found'}), 404

        # Soft delete by marking as inactive
        student_subject.is_active = False
        db.session.commit()

        logger.info(f"Subject {subject_id} removed from student {student_id} by admin {request.current_admin.id}")
        return jsonify({'message': 'Subject removed successfully'}), 200

    except Exception as e:
        db.session.rollback()
        logger.error(f"Remove subject error: {str(e)}")
        return jsonify({'error': 'Failed to remove subject'}), 500


@app.route('/api/student/my-subjects', methods=['GET'])
def get_my_subjects():
    """Get subjects assigned to the current student"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401

        token = auth_header.split(' ')[1]

        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:
                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401

        # Get all active subjects for this student
        student_subjects = StudentSubject.query.filter_by(
            student_id=student_id,
            is_active=True
        ).all()

        # Get task counts for each subject
        subjects_with_stats = []
        for ss in student_subjects:
            # Count tasks for this subject
            # We'll filter tasks by subject based on task_type matching subject code
            subject_code = ss.subject.code if ss.subject else None

            pending_tasks = 0
            completed_tasks = 0

            if subject_code:
                # Try to match task_type with subject code
                all_tasks = StudentTask.query.filter_by(student_id=student_id).all()
                for task in all_tasks:
                    # Match task_type with subject code (flexible matching)
                    if (task.task_type and subject_code and
                        (subject_code.lower() in task.task_type.lower() or
                         task.task_type.lower() in subject_code.lower())):
                        if task.status == 'pending' or task.status == 'in_progress':
                            pending_tasks += 1
                        elif task.status == 'completed':
                            completed_tasks += 1

            subject_dict = ss.to_dict()
            subject_dict['pending_tasks'] = pending_tasks
            subject_dict['completed_tasks'] = completed_tasks
            subject_dict['total_tasks'] = pending_tasks + completed_tasks

            subjects_with_stats.append(subject_dict)

        return jsonify({
            'subjects': subjects_with_stats
        }), 200

    except Exception as e:
        logger.error(f"Get my subjects error: {str(e)}")
        return jsonify({'error': 'Failed to fetch your subjects'}), 500


# ==================== END SUBJECT MANAGEMENT ENDPOINTS ====================


# ==================== SKILL MANAGEMENT ENDPOINTS ====================

@app.route('/api/admin/skills', methods=['GET'])
@admin_required
def admin_get_skills():
    """Admin endpoint to get all skills"""
    try:
        skills = Skill.query.filter_by(is_active=True).all()
        return jsonify({
            'skills': [skill.to_dict() for skill in skills]
        }), 200
    except Exception as e:
        logger.error(f"Get skills error: {str(e)}")
        return jsonify({'error': 'Failed to fetch skills'}), 500


@app.route('/api/admin/students/<int:student_id>/skills/assign', methods=['POST'])
@admin_required
def assign_skills_to_student(student_id):
    """Assign one or more skills to a student"""
    try:
        data = request.get_json()

        if 'skill_ids' not in data or not isinstance(data['skill_ids'], list):
            return jsonify({'error': 'skill_ids must be provided as a list'}), 400

        # Check if student exists
        student = Student.query.get(student_id)
        if not student:
            return jsonify({'error': 'Student not found'}), 404

        assigned = []
        skipped = []
        errors = []

        for skill_id in data['skill_ids']:
            try:
                # Check if skill exists
                skill = Skill.query.get(skill_id)
                if not skill:
                    errors.append(f"Skill {skill_id} not found")
                    continue

                # Check if already assigned
                existing = StudentSkill.query.filter_by(
                    student_id=student_id,
                    skill_id=skill_id
                ).first()

                if existing:
                    if not existing.is_active:
                        # Reactivate if previously deactivated
                        existing.is_active = True
                        existing.assigned_at = datetime.utcnow()
                        existing.admin_id = request.current_admin.id
                        assigned.append(skill.name)
                    else:
                        skipped.append(skill.name)
                    continue

                # Create new assignment
                student_skill = StudentSkill(
                    student_id=student_id,
                    skill_id=skill_id,
                    admin_id=request.current_admin.id,
                    proficiency_level=data.get('proficiency_level', 'beginner'),
                    custom_name=data.get('custom_name'),
                    custom_description=data.get('custom_description')
                )

                db.session.add(student_skill)
                assigned.append(skill.name)

            except Exception as e:
                errors.append(f"Error assigning skill {skill_id}: {str(e)}")

        db.session.commit()

        logger.info(f"Skills assigned to student {student_id} by admin {request.current_admin.id}")

        return jsonify({
            'message': 'Skill assignment completed',
            'assigned': assigned,
            'skipped': skipped,
            'errors': errors
        }), 200

    except Exception as e:
        db.session.rollback()
        logger.error(f"Assign skills error: {str(e)}")
        return jsonify({'error': 'Failed to assign skills'}), 500


@app.route('/api/admin/students/skills/bulk-assign', methods=['POST'])
@admin_required
def bulk_assign_skills():
    """Bulk assign skills to multiple students"""
    try:
        data = request.get_json()

        required_fields = ['student_ids', 'skill_ids']
        if not all(field in data for field in required_fields):
            return jsonify({'error': 'Missing required fields: student_ids, skill_ids'}), 400

        if not isinstance(data['student_ids'], list) or not isinstance(data['skill_ids'], list):
            return jsonify({'error': 'student_ids and skill_ids must be lists'}), 400

        results = {
            'total_students': len(data['student_ids']),
            'total_skills': len(data['skill_ids']),
            'successful_assignments': 0,
            'failed_assignments': 0,
            'details': []
        }

        for student_id in data['student_ids']:
            student = Student.query.get(student_id)
            if not student:
                results['details'].append({
                    'student_id': student_id,
                    'status': 'error',
                    'message': 'Student not found'
                })
                results['failed_assignments'] += 1
                continue

            assigned_skills = []
            for skill_id in data['skill_ids']:
                try:
                    skill = Skill.query.get(skill_id)
                    if not skill:
                        continue

                    # Check if already assigned
                    existing = StudentSkill.query.filter_by(
                        student_id=student_id,
                        skill_id=skill_id
                    ).first()

                    if existing:
                        if not existing.is_active:
                            existing.is_active = True
                            existing.assigned_at = datetime.utcnow()
                            existing.admin_id = request.current_admin.id
                            assigned_skills.append(skill.name)
                    else:
                        student_skill = StudentSkill(
                            student_id=student_id,
                            skill_id=skill_id,
                            admin_id=request.current_admin.id
                        )
                        db.session.add(student_skill)
                        assigned_skills.append(skill.name)

                except Exception as e:
                    logger.error(f"Error assigning skill {skill_id} to student {student_id}: {str(e)}")

            if assigned_skills:
                results['details'].append({
                    'student_id': student_id,
                    'student_name': student.name or student.email,
                    'status': 'success',
                    'assigned_skills': assigned_skills
                })
                results['successful_assignments'] += 1
            else:
                results['details'].append({
                    'student_id': student_id,
                    'student_name': student.name or student.email,
                    'status': 'no_changes',
                    'message': 'No new skills assigned'
                })

        db.session.commit()

        logger.info(f"Bulk skills assignment completed by admin {request.current_admin.id}")

        return jsonify(results), 200

    except Exception as e:
        db.session.rollback()
        logger.error(f"Bulk assign skills error: {str(e)}")
        return jsonify({'error': 'Failed to bulk assign skills'}), 500


@app.route('/api/admin/students/<int:student_id>/skills/<int:skill_id>', methods=['DELETE'])
@admin_required
def remove_skill_from_student(student_id, skill_id):
    """Remove a skill from a student (soft delete)"""
    try:
        student_skill = StudentSkill.query.filter_by(
            student_id=student_id,
            skill_id=skill_id
        ).first()

        if not student_skill:
            return jsonify({'error': 'Skill assignment not found'}), 404

        # Soft delete - set is_active to False
        student_skill.is_active = False
        db.session.commit()

        logger.info(f"Skill {skill_id} removed from student {student_id} by admin {request.current_admin.id}")

        return jsonify({'message': 'Skill removed successfully'}), 200

    except Exception as e:
        db.session.rollback()
        logger.error(f"Remove skill error: {str(e)}")
        return jsonify({'error': 'Failed to remove skill'}), 500


@app.route('/api/student/my-skills', methods=['GET'])
def get_my_skills():
    """Get skills assigned to the current student"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401

        token = auth_header.split(' ')[1]

        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:
                logger.warning(f"Invalid token: No student identifier")
                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401

        # Get all active skills for this student
        student_skills = StudentSkill.query.filter_by(
            student_id=student_id,
            is_active=True
        ).all()

        skills_data = []
        for ss in student_skills:
            skill_dict = ss.to_dict()
            skills_data.append(skill_dict)

        return jsonify({
            'skills': skills_data,
            'total': len(skills_data)
        }), 200

    except Exception as e:
        logger.error(f"Get my skills error: {str(e)}")
        return jsonify({'error': 'Failed to fetch your skills'}), 500


@app.route('/api/admin/students/<int:student_id>/skills', methods=['GET'])
@admin_required
def get_student_skills(student_id):
    """Admin endpoint to get all skills assigned to a specific student"""
    try:
        student = Student.query.get(student_id)
        if not student:
            return jsonify({'error': 'Student not found'}), 404

        student_skills = StudentSkill.query.filter_by(
            student_id=student_id,
            is_active=True
        ).all()

        skills_data = []
        for ss in student_skills:
            skill_dict = ss.to_dict()
            skills_data.append(skill_dict)

        return jsonify({
            'skills': skills_data,
            'total': len(skills_data)
        }), 200

    except Exception as e:
        logger.error(f"Get student skills error: {str(e)}")
        return jsonify({'error': 'Failed to fetch student skills'}), 500


# ==================== END SKILL MANAGEMENT ENDPOINTS ====================

# Enhanced task list endpoint with proper score display
@app.route('/api/student/tasks', methods=['GET'])
def get_student_tasks_with_scores():
    """Get student tasks with enhanced score information"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401
            
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
            
        tasks = StudentTask.query.filter_by(student_id=student_id).order_by(
            db.func.isnull(StudentTask.due_date),
            StudentTask.due_date.asc(),
            StudentTask.assigned_at.desc()
        ).all()
        
        tasks_data = []
        for task in tasks:
            task_data_dict = json.loads(task.task_data) if task.task_data else {}
            completion_data = task_data_dict.get('completion_data', {})
            score_breakdown = task_data_dict.get('score_breakdown', {})
            
            # Enhanced URL determination
            task_url = None
            is_external = False
            link_type = task_data_dict.get('link_type', 'internal')
            
            if task_data_dict.get('external_url'):
                task_url = task_data_dict['external_url']
                is_external = True
            elif task_data_dict.get('task_file'):
                task_url = f"https://deciph.ai.deciphersacad.online/{task_data_dict['task_file']}"
                is_external = True
                link_type = 'internal'
            
            # Enhanced score information
            score_info = None
            if task.status == 'completed' and (completion_data or score_breakdown):
                raw_score = score_breakdown.get('raw_game_score') or completion_data.get('raw_score') or completion_data.get('score', 0)
                max_score = score_breakdown.get('max_possible_score') or completion_data.get('max_score', 100)
                percentage = score_breakdown.get('percentage_achieved') or completion_data.get('score_percentage')
                
                # Calculate percentage if not stored
                if not percentage and max_score > 0:
                    percentage = round((raw_score / max_score) * 100, 1)
                
                score_info = {
                    'raw_score': raw_score,
                    'max_score': max_score,
                    'percentage': percentage,
                    'performance_level': get_performance_level(percentage) if percentage else None,
                    'time_spent': completion_data.get('time_spent', 0),
                    'games_played': completion_data.get('performance_data', {}).get('gamesPlayed', 0)
                }
            
            due_date_iso = None
            if task.due_date:
                due_date_iso = task.due_date.isoformat()
            
            tasks_data.append({
                'id': task.id,
                'task_type': task.task_type,
                'task_title': task.task_title,
                'task_description': task.task_description,
                'status': task.status,
                'points_reward': task.points_reward,
                'acard_credit': float(task.acard_credit),
                'due_date': due_date_iso,
                'assigned_at': task.assigned_at.isoformat(),
                'completed_at': task.completed_at.isoformat() if task.completed_at else None,
                'task_data': task_data_dict,
                'completion_data': completion_data,
                'score_info': score_info,  # Enhanced score information
                'task_url': task_url,
                'is_external': is_external,
                'link_type': link_type
            })
        
        return jsonify({
            'tasks': tasks_data,
            'pending_count': len([t for t in tasks_data if t['status'] == 'pending']),
            'completed_count': len([t for t in tasks_data if t['status'] == 'completed']),
            'total_count': len(tasks_data)
        }), 200
        
    except Exception as e:
        logger.error(f"Get student tasks with scores error: {str(e)}")
        return jsonify({'error': 'Failed to fetch tasks with scores'}), 500

# Subject-filtered tasks endpoint
@app.route('/api/student/tasks/subject/<subject_code>', methods=['GET'])
def get_student_tasks_by_subject(subject_code):
    """Get student tasks filtered by subject code"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401

        token = auth_header.split(' ')[1]

        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:
                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")
                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401

        # Fetch tasks and filter by subject code (flexible matching)
        all_tasks = StudentTask.query.filter_by(student_id=student_id).order_by(
            db.func.isnull(StudentTask.due_date),
            StudentTask.due_date.asc(),
            StudentTask.assigned_at.desc()
        ).all()

        # Filter tasks where task_type matches or contains subject_code
        tasks = [task for task in all_tasks if
                 task.task_type and (
                     task.task_type.lower() == subject_code.lower() or
                     subject_code.lower() in task.task_type.lower() or
                     task.task_type.lower() in subject_code.lower()
                 )]

        tasks_data = []
        for task in tasks:
            task_data_dict = json.loads(task.task_data) if task.task_data else {}
            completion_data = task_data_dict.get('completion_data', {})
            score_breakdown = task_data_dict.get('score_breakdown', {})

            # Enhanced URL determination
            task_url = None
            is_external = False
            link_type = task_data_dict.get('link_type', 'internal')

            if task_data_dict.get('external_url'):
                task_url = task_data_dict['external_url']
                is_external = True
            elif task_data_dict.get('task_file'):
                task_url = f"https://deciph.ai.deciphersacad.online/{task_data_dict['task_file']}"
                is_external = True
                link_type = 'internal'

            # Enhanced score information
            score_info = None
            if task.status == 'completed' and (completion_data or score_breakdown):
                raw_score = score_breakdown.get('raw_game_score') or completion_data.get('raw_score') or completion_data.get('score', 0)
                max_score = score_breakdown.get('max_possible_score') or completion_data.get('max_score', 100)
                percentage = score_breakdown.get('percentage_achieved') or completion_data.get('score_percentage')

                # Calculate percentage if not stored
                if not percentage and max_score > 0:
                    percentage = round((raw_score / max_score) * 100, 1)

                score_info = {
                    'raw_score': raw_score,
                    'max_score': max_score,
                    'percentage': percentage,
                    'performance_level': get_performance_level(percentage) if percentage else None,
                    'time_spent': completion_data.get('time_spent', 0),
                    'games_played': completion_data.get('performance_data', {}).get('gamesPlayed', 0)
                }

            due_date_iso = None
            if task.due_date:
                due_date_iso = task.due_date.isoformat()

            # Extract class link data
            class_link_data = task_data_dict.get('class_link')
            has_class_link = task_data_dict.get('has_class_link', False)

            tasks_data.append({
                'id': task.id,
                'task_type': task.task_type,
                'task_title': task.task_title,
                'task_description': task.task_description,
                'status': task.status,
                'points_reward': task.points_reward,
                'acard_credit': float(task.acard_credit),
                'due_date': due_date_iso,
                'assigned_at': task.assigned_at.isoformat(),
                'completed_at': task.completed_at.isoformat() if task.completed_at else None,
                'task_data': task_data_dict,
                'completion_data': completion_data,
                'score_info': score_info,
                'task_url': task_url,
                'is_external': is_external,
                'link_type': link_type,
                'class_link': class_link_data,
                'has_class_link': has_class_link
            })

        return jsonify({
            'tasks': tasks_data,
            'subject_code': subject_code,
            'pending_count': len([t for t in tasks_data if t['status'] == 'pending']),
            'completed_count': len([t for t in tasks_data if t['status'] == 'completed']),
            'total_count': len(tasks_data)
        }), 200

    except Exception as e:
        logger.error(f"Get student tasks by subject error: {str(e)}")
        return jsonify({'error': 'Failed to fetch tasks for subject'}), 500

# Add this endpoint to your Flask backend

# Optional: Enhanced detailed analytics (only add if you want the extra features)
@app.route('/api/student/analytics/detailed', methods=['GET'])
def get_detailed_student_analytics():
    """Get detailed analytics with score breakdown - OPTIONAL"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401
            
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
            
        # Get completed tasks with score data
        tasks = StudentTask.query.filter_by(
            student_id=student_id, 
            status='completed'
        ).order_by(StudentTask.completed_at.desc()).all()
        
        detailed_analytics = {
            'score_analytics': {
                'total_tasks_completed': len(tasks),
                'average_score_percentage': 0,
                'highest_score_percentage': 0,
                'lowest_score_percentage': 100 if len(tasks) > 0 else 0,
                'score_distribution': {
                    'outstanding': 0,  # 95%+
                    'excellent': 0,    # 90-94%
                    'great': 0,        # 80-89%
                    'good': 0,         # 70-79%
                    'fair': 0,         # 60-69%
                    'needs_practice': 0 # <60%
                }
            },
            'recent_performances': [],
            'score_trend': []
        }
        
        total_percentage = 0
        valid_scores = 0
        
        for task in tasks:
            try:
                task_data = json.loads(task.task_data) if task.task_data else {}
                completion_data = task_data.get('completion_data', {})
                
                raw_score = completion_data.get('raw_score', 0) or completion_data.get('score', 0)
                max_score = completion_data.get('max_score', 100)
                percentage = completion_data.get('score_percentage', 0)
                
                # Calculate percentage if not stored
                if not percentage and max_score > 0 and raw_score > 0:
                    percentage = round((raw_score / max_score) * 100, 1)
                
                if percentage > 0:
                    total_percentage += percentage
                    valid_scores += 1
                    
                    # Update min/max
                    detailed_analytics['score_analytics']['highest_score_percentage'] = max(
                        detailed_analytics['score_analytics']['highest_score_percentage'], 
                        percentage
                    )
                    detailed_analytics['score_analytics']['lowest_score_percentage'] = min(
                        detailed_analytics['score_analytics']['lowest_score_percentage'], 
                        percentage
                    )
                    
                    # Update distribution
                    if percentage >= 95:
                        detailed_analytics['score_analytics']['score_distribution']['outstanding'] += 1
                    elif percentage >= 90:
                        detailed_analytics['score_analytics']['score_distribution']['excellent'] += 1
                    elif percentage >= 80:
                        detailed_analytics['score_analytics']['score_distribution']['great'] += 1
                    elif percentage >= 70:
                        detailed_analytics['score_analytics']['score_distribution']['good'] += 1
                    elif percentage >= 60:
                        detailed_analytics['score_analytics']['score_distribution']['fair'] += 1
                    else:
                        detailed_analytics['score_analytics']['score_distribution']['needs_practice'] += 1
                
                # Add to recent performances (last 10)
                if len(detailed_analytics['recent_performances']) < 10:
                    detailed_analytics['recent_performances'].append({
                        'task_title': task.task_title,
                        'task_type': task.task_type,
                        'raw_score': raw_score,
                        'max_score': max_score,
                        'percentage': percentage,
                        'performance_level': get_performance_level(percentage),
                        'completed_at': task.completed_at.isoformat() if task.completed_at else None,
                        'time_spent': completion_data.get('time_spent', 0)
                    })
                
                # Add to score trend (last 15 for chart)
                if len(detailed_analytics['score_trend']) < 15:
                    detailed_analytics['score_trend'].append({
                        'task_title': task.task_title[:15] + '...' if len(task.task_title) > 15 else task.task_title,
                        'percentage': percentage,
                        'completed_at': task.completed_at.isoformat() if task.completed_at else None
                    })
                    
            except Exception as task_error:
                logger.warning(f"Error processing task {task.id} for analytics: {task_error}")
                continue
        
        # Calculate average
        if valid_scores > 0:
            detailed_analytics['score_analytics']['average_score_percentage'] = round(total_percentage / valid_scores, 1)
        else:
            detailed_analytics['score_analytics']['lowest_score_percentage'] = 0
        
        # Reverse trend to show oldest first
        detailed_analytics['score_trend'].reverse()
        
        return jsonify(detailed_analytics), 200
        
    except Exception as e:
        logger.error(f"Get detailed analytics error: {str(e)}")
        return jsonify({'error': 'Failed to fetch detailed analytics'}), 500

@app.route('/api/student/analytics', methods=['GET'])
def get_basic_student_analytics():
    """Basic analytics using existing task data"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401
            
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
            
        # Get all tasks for this student using existing query
        tasks = StudentTask.query.filter_by(student_id=student_id).all()
        
        # Initialize analytics data
        analytics = {
            'total_tasks': len(tasks),
            'completed_tasks': 0,
            'pending_tasks': 0,
            'avg_time_spent': 0,
            'avg_score': 0,
            'task_types': {},
            'recent_submissions': []
        }
        
        # Process each task
        total_time = 0
        total_score = 0
        total_max_score = 0
        completed_count = 0
        
        for task in tasks:
            # Count by status
            if task.status == 'completed':
                analytics['completed_tasks'] += 1
                completed_count += 1
                
                # Parse task data
                task_data = {}
                completion_data = {}
                try:
                    if task.task_data:
                        task_data = json.loads(task.task_data)
                        completion_data = task_data.get('completion_data', {})
                except json.JSONDecodeError:
                    pass
                
                # Add to recent submissions
                analytics['recent_submissions'].append({
                    'task_title': task.task_title,
                    'task_type': task.task_type,
                    'status': task.status,
                    'completed_at': task.completed_at.isoformat() if task.completed_at else None,
                    'completion_data': completion_data,
                    'points_reward': task.points_reward,
                    'acard_credit': float(task.acard_credit) if task.acard_credit else 0
                })
                
                # Process completion data for averages
                if completion_data:
                    time_spent = completion_data.get('time_spent', 0)
                    score = completion_data.get('score', 0)
                    max_score = completion_data.get('max_score', 100)
                    
                    total_time += time_spent
                    total_score += score
                    total_max_score += max_score
                    
            elif task.status == 'pending':
                analytics['pending_tasks'] += 1
            
            # Count task types
            task_type = task.task_type or 'unknown'
            analytics['task_types'][task_type] = analytics['task_types'].get(task_type, 0) + 1
        
        # Calculate averages
        if completed_count > 0:
            analytics['avg_time_spent'] = int(total_time / completed_count)
            if total_max_score > 0:
                analytics['avg_score'] = int((total_score / total_max_score) * 100)
        
        # Sort recent submissions by completion date (most recent first)
        analytics['recent_submissions'].sort(
            key=lambda x: x['completed_at'] or '0000-01-01T00:00:00', 
            reverse=True
        )
        
        # Limit recent submissions to last 10
        analytics['recent_submissions'] = analytics['recent_submissions'][:10]
        
        logger.info(f"Basic analytics for student {student_id}: {analytics['total_tasks']} tasks, {analytics['completed_tasks']} completed")
        
        return jsonify(analytics), 200
        
    except Exception as e:
        logger.error(f"Get basic student analytics error: {str(e)}")
        return jsonify({'error': 'Failed to fetch analytics'}), 500

# Also add a summary endpoint for quick dashboard stats
@app.route('/api/student/analytics/summary', methods=['GET'])
def get_student_analytics_summary():
    """Get quick analytics summary for dashboard"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401
            
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
            
        # Quick counts
        total_tasks = StudentTask.query.filter_by(student_id=student_id).count()
        completed_tasks = StudentTask.query.filter_by(student_id=student_id, status='completed').count()
        pending_tasks = StudentTask.query.filter_by(student_id=student_id, status='pending').count()
        
        # Calculate completion rate
        completion_rate = 0
        if total_tasks > 0:
            completion_rate = (completed_tasks / total_tasks) * 100
        
        # Get student's current stats
        student = Student.query.get(student_id)
        
        summary = {
            'total_tasks': total_tasks,
            'completed_tasks': completed_tasks,
            'pending_tasks': pending_tasks,
            'completion_rate': round(completion_rate, 1),
            'total_points': getattr(student, 'total_points', 0),
            'acard_balance': float(getattr(student, 'acard_balance', 0) or 0),
            'current_level': getattr(student, 'current_level', 1)
        }
        
        return jsonify(summary), 200
        
    except Exception as e:
        logger.error(f"Get student analytics summary error: {str(e)}")
        return jsonify({'error': 'Failed to fetch analytics summary'}), 500

# Replace the existing task completion endpoint with this fixed version
@app.route('/api/student/task/<int:task_id>/complete', methods=['POST'])
def submit_task_completion(task_id):
    """Enhanced task completion with better score storage"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401
            
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
            
        task = StudentTask.query.filter_by(id=task_id, student_id=student_id).first()
        if not task:
            return jsonify({'error': 'Task not found'}), 404
            
        if task.status == 'completed':
            return jsonify({'error': 'Task already completed'}), 400
            
        data = request.get_json() or {}
        
        # Enhanced score processing
        submitted_score = data.get('score', 0)
        max_score = data.get('max_score', 100)
        raw_score = data.get('raw_score', submitted_score)  # Original game score
        score_percentage = data.get('score_percentage', 0)
        
        # If percentage not provided, calculate it
        if not score_percentage and max_score > 0:
            score_percentage = round((raw_score / max_score) * 100, 1)
        
        # Log the scoring data for debugging
        logger.info(f"Task {task_id} completion:")
        logger.info(f"  Raw score: {raw_score}, Max: {max_score}, Percentage: {score_percentage}%")
        
        # Update task
        task.status = 'completed'
        task.completed_at = datetime.utcnow()
        
        # Store enhanced completion data
        completion_data = {
            'score': submitted_score,
            'raw_score': raw_score,
            'max_score': max_score,
            'score_percentage': score_percentage,
            'time_spent': data.get('time_spent', 0),
            'attempts': data.get('attempts', 1),
            'completion_method': data.get('completion_method', 'enhanced_tracker'),
            'external_url_used': data.get('external_url_used', False),
            'performance_data': data.get('performance_data', {}),
            'completion_timestamp': datetime.utcnow().isoformat(),
            'tracker_version': '2.1'
        }
        
        # Update task_data with completion info
        existing_data = json.loads(task.task_data) if task.task_data else {}
        existing_data['completion_data'] = completion_data
        task.task_data = json.dumps(existing_data)
        
        # Get student and award rewards
        student = Student.query.get(student_id)
        
        # Award points
        if task.points_reward > 0:
            current_points = getattr(student, 'total_points', 0) or 0
            student.total_points = current_points + task.points_reward
        
        # Credit A-Card
        if task.acard_credit > 0:
            current_balance = float(getattr(student, 'acard_balance', 0) or 0)
            new_balance = current_balance + float(task.acard_credit)
            student.acard_balance = new_balance
            
            # Create transaction record if ACardTransaction exists
            try:
                transaction = ACardTransaction(
                    student_id=student_id,
                    task_id=task.id,
                    transaction_type='task_reward',
                    amount=float(task.acard_credit),
                    description=f'Reward for: {task.task_title} ({score_percentage}%)',
                    balance_after=new_balance
                )
                db.session.add(transaction)
            except NameError:
                # ACardTransaction model doesn't exist yet
                logger.info(f"A-Card credited: â‚³{task.acard_credit} (transaction model not available)")
        
        db.session.commit()
        
        # Enhanced response with detailed scoring info
        response_data = {
            'message': 'Task completed successfully',
            'success': True,
            'rewards': {
                'points_awarded': task.points_reward or 0,
                'acard_credited': float(task.acard_credit) if task.acard_credit else 0,
                'new_total_points': getattr(student, 'total_points', 0),
                'new_acard_balance': float(getattr(student, 'acard_balance', 0) or 0)
            },
            'score_info': {
                'raw_score': raw_score,
                'max_score': max_score,
                'percentage': score_percentage,
                'performance_level': get_performance_level(score_percentage)
            },
            'completion_data': completion_data
        }
        
        logger.info(f"Task {task_id} completed: {raw_score}/{max_score} ({score_percentage}%)")
        
        return jsonify(response_data), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Submit task completion error: {str(e)}")
        return jsonify({'error': 'Failed to submit task completion', 'success': False}), 500


def get_performance_level(percentage):
    """Get performance level description based on percentage"""
    if percentage >= 95:
        return "Outstanding! ðŸŒŸ"
    elif percentage >= 90:
        return "Excellent! ðŸŽ‰"
    elif percentage >= 80:
        return "Great Job! ðŸ‘"
    elif percentage >= 70:
        return "Good Work! ðŸ‘"
    elif percentage >= 60:
        return "Keep Practicing! ðŸ“š"
    else:
        return "Need More Practice ðŸ’ª"

def format_time(seconds):
    """Format time in seconds to human readable format"""
    if seconds < 60:
        return f"{seconds}s"
    elif seconds < 3600:
        minutes = seconds // 60
        remaining_seconds = seconds % 60
        return f"{minutes}m {remaining_seconds}s"
    else:
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        return f"{hours}h {minutes}m"


# Add progress tracking endpoint
@app.route('/api/student/task/progress', methods=['POST'])
def update_task_progress():
    """Track task progress for external games"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401
            
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
            
        data = request.get_json()
        task_id = data.get('task_id')
        
        if not task_id:
            return jsonify({'error': 'task_id is required'}), 400
            
        task = StudentTask.query.filter_by(id=task_id, student_id=student_id).first()
        if not task:
            return jsonify({'error': 'Task not found'}), 404
            
        # Update task progress data
        existing_data = json.loads(task.task_data) if task.task_data else {}
        
        progress_data = existing_data.get('progress_data', {})
        progress_data.update({
            'last_update': datetime.utcnow().isoformat(),
            'score': data.get('score', 0),
            'max_score': data.get('max_score', 100),
            'time_spent': data.get('time_spent', 0),
            'progress': data.get('progress', 0),
            'interactions': data.get('interactions', 0),
            'status': data.get('status', 'in_progress')
        })
        
        existing_data['progress_data'] = progress_data
        task.task_data = json.dumps(existing_data)
        
        # Update task status if needed
        if data.get('status') == 'started' and task.status == 'pending':
            task.status = 'in_progress'
        
        db.session.commit()
        
        return jsonify({
            'message': 'Progress updated successfully',
            'progress_data': progress_data
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Update task progress error: {str(e)}")
        return jsonify({'error': 'Failed to update progress'}), 500

# Social Media Management System - Complete Backend API Routes
# Add these routes to your Flask application (app.py)

# Import your existing models and the new social media models
from auth.models import (
    SocialMediaStudent, 
    SocialMediaTask, 
    SocialMediaProgress,
    create_sm_student_token,
    seed_social_media_students
)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# JWT Secret Key (already defined at the top of the file - DO NOT redefine here)
# JWT_SECRET_KEY is already set from environment variable or default value above

# ==================== AUTHENTICATION ROUTES ====================

@app.route('/api/social-media/auth/login', methods=['POST'])
def social_media_student_login():
    """
    Social media student login endpoint
    Expects: { "username": "Emma@decipher.com", "password": "MmA773E" }
    """
    try:
        data = request.get_json()
        username = data.get('username', '').strip()
        password = data.get('password', '').strip()
        
        if not username or not password:
            return jsonify({'error': 'Username and password are required'}), 400
        
        logger.info(f"Login attempt for social media student: {username}")
        
        # Find student by username
        student = SocialMediaStudent.query.filter_by(
            username=username,
            is_active=True
        ).first()
        
        if not student:
            logger.warning(f"Student not found: {username}")
            return jsonify({'error': 'Invalid username or password'}), 401
        
        # Verify password
        if not student.check_password(password):
            logger.warning(f"Invalid password for student: {username}")
            return jsonify({'error': 'Invalid username or password'}), 401
        
        # Update last login
        student.update_last_login()
        
        # Generate JWT token
        token = create_sm_student_token(student.id)
        
        logger.info(f"âœ… Successful login: {student.full_name}")
        
        return jsonify({
            'success': True,
            'message': f'Welcome back, {student.full_name.split()[0]}!',
            'token': token,
            'student': student.to_dict()
        }), 200
        
    except Exception as e:
        logger.error(f"Login error: {str(e)}")
        return jsonify({'error': 'Login failed. Please try again.'}), 500


@app.route('/api/social-media/auth/verify', methods=['GET'])
def verify_social_media_token():
    """Verify JWT token for social media student"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401
        
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            student_id = payload.get('student_id')
            
            if payload.get('student_type') != 'social_media':
                return jsonify({'error': 'Invalid token type'}), 401
            
            student = SocialMediaStudent.query.get(student_id)
            if not student or not student.is_active:
                return jsonify({'error': 'Student not found or inactive'}), 401
            
            return jsonify({
                'valid': True,
                'student': student.to_dict()
            }), 200
            
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
            
    except Exception as e:
        logger.error(f"Token verification error: {str(e)}")
        return jsonify({'error': 'Verification failed'}), 500


# ==================== STUDENT DASHBOARD ROUTES ====================

@app.route('/api/social-media/student/dashboard', methods=['GET'])
def get_social_media_dashboard():
    """Get dashboard data for social media student"""
    try:
        # Extract and verify token
        auth_header = request.headers.get('Authorization')
        if not auth_header:
            return jsonify({'error': 'No authorization token'}), 401
        
        token = auth_header.split(' ')[1]
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
        # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

        student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

        if not student_id:

            logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

            return jsonify({'error': 'Invalid token'}), 401
        
        student = SocialMediaStudent.query.get(student_id)
        if not student:
            return jsonify({'error': 'Student not found'}), 404
        
        # Get student's tasks
        all_tasks = SocialMediaTask.query.filter_by(student_id=student_id).all()
        pending_tasks = [t for t in all_tasks if t.status == 'pending']
        in_progress_tasks = [t for t in all_tasks if t.status == 'in_progress']
        completed_tasks = [t for t in all_tasks if t.status == 'completed']
        
        # Get progress data by week
        progress_records = SocialMediaProgress.query.filter_by(student_id=student_id).all()
        
        # Calculate overall progress
        if progress_records:
            avg_progress = sum([p.progress_percentage for p in progress_records]) / len(progress_records)
        else:
            avg_progress = 0
        
        dashboard_data = {
            'student': student.to_dict(),
            'statistics': {
                'total_tasks': len(all_tasks),
                'pending_tasks': len(pending_tasks),
                'in_progress_tasks': len(in_progress_tasks),
                'completed_tasks': len(completed_tasks),
                'total_points': student.total_points,
                'overall_progress': round(avg_progress, 1),
                'skill_level': student.skill_level
            },
            'recent_tasks': [t.to_dict() for t in all_tasks[:10]],  # Last 10 tasks
            'progress_by_week': [p.to_dict() for p in progress_records]
        }
        
        return jsonify(dashboard_data), 200
        
    except jwt.ExpiredSignatureError:
        return jsonify({'error': 'Token expired'}), 401
    except Exception as e:
        logger.error(f"Dashboard error: {str(e)}")
        return jsonify({'error': 'Failed to load dashboard'}), 500


@app.route('/api/social-media/student/tasks', methods=['GET'])
def get_social_media_student_tasks():
    """Get all tasks for social media student"""
    try:
        auth_header = request.headers.get('Authorization')
        token = auth_header.split(' ')[1]
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
        # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

        student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

        if not student_id:

            logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

            return jsonify({'error': 'Invalid token'}), 401
        
        # Query parameters for filtering
        status_filter = request.args.get('status')  # pending, in_progress, completed
        week_filter = request.args.get('week', type=int)
        task_type_filter = request.args.get('task_type')
        
        # Build query
        query = SocialMediaTask.query.filter_by(student_id=student_id)
        
        if status_filter:
            query = query.filter_by(status=status_filter)
        if week_filter:
            query = query.filter_by(week_number=week_filter)
        if task_type_filter:
            query = query.filter_by(task_type=task_type_filter)
        
        tasks = query.order_by(SocialMediaTask.week_number, SocialMediaTask.day_number).all()
        
        return jsonify({
            'tasks': [t.to_dict() for t in tasks],
            'total_count': len(tasks)
        }), 200
        
    except Exception as e:
        logger.error(f"Get tasks error: {str(e)}")
        return jsonify({'error': 'Failed to fetch tasks'}), 500

@app.route('/api/social-media/student/progress', methods=['GET'])
def get_student_progress():
    """Get student's progress across all weeks - ALWAYS RECALCULATE"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'Authentication required'}), 401
        
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            student_id = payload.get('student_id')
        except:
            return jsonify({'error': 'Invalid token'}), 401
        
        student = SocialMediaStudent.query.get(student_id)
        if not student:
            return jsonify({'error': 'Student not found'}), 404
        
        # Get all unique weeks for this student
        weeks_query = db.session.query(
            SocialMediaTask.week_number
        ).filter_by(
            student_id=student_id
        ).filter(
            SocialMediaTask.week_number.isnot(None)
        ).distinct().all()
        
        progress_data = []
        
        for (week_number,) in weeks_query:
            # ALWAYS RECALCULATE from actual task counts
            total_tasks = SocialMediaTask.query.filter_by(
                student_id=student_id,
                week_number=week_number
            ).count()
            
            completed_tasks = SocialMediaTask.query.filter_by(
                student_id=student_id,
                week_number=week_number,
                status='completed'
            ).count()
            
            week_progress = (completed_tasks / total_tasks * 100) if total_tasks > 0 else 0
            
            # Get time spent from progress table (or 0 if not exists)
            progress_record = SocialMediaProgress.query.filter_by(
                student_id=student_id,
                week_number=week_number
            ).first()
            
            time_spent = progress_record.time_spent_minutes if progress_record else 0
            
            progress_data.append({
                'week_number': week_number,
                'completed_lessons': completed_tasks,
                'total_lessons': total_tasks,
                'progress_percentage': round(week_progress, 1),
                'time_spent_minutes': time_spent
            })
            
            logger.info(f"Week {week_number}: {completed_tasks}/{total_tasks} ({week_progress:.1f}%) - {time_spent} min")
        
        # Sort by week number
        progress_data.sort(key=lambda x: x['week_number'])
        
        return jsonify({
            'success': True,
            'progress': progress_data
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching progress: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({'error': str(e)}), 500

# ==================== ADMIN ROUTES FOR SOCIAL MEDIA ====================

@app.route('/api/admin/social-media/students', methods=['GET'])
@admin_required  # Use your existing admin decorator
def get_social_media_students():
    """Get all social media students (Admin only)"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        search = request.args.get('search', '')
        
        query = SocialMediaStudent.query
        
        if search:
            query = query.filter(
                db.or_(
                    SocialMediaStudent.full_name.ilike(f'%{search}%'),
                    SocialMediaStudent.email.ilike(f'%{search}%'),
                    SocialMediaStudent.username.ilike(f'%{search}%')
                )
            )
        
        students_paginated = query.paginate(page=page, per_page=per_page, error_out=False)
        
        return jsonify({
            'students': [s.to_dict() for s in students_paginated.items],
            'pagination': {
                'page': students_paginated.page,
                'pages': students_paginated.pages,
                'total': students_paginated.total,
                'per_page': per_page
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Get social media students error: {str(e)}")
        return jsonify({'error': 'Failed to fetch students'}), 500


@app.route('/api/admin/social-media/student/create', methods=['POST'])
@admin_required
def create_social_media_student():
    """Create a new social media student manually (Admin only)"""
    try:
        data = request.get_json()
        
        required_fields = ['username', 'password', 'full_name', 'email']
        if not all(field in data for field in required_fields):
            return jsonify({'error': 'Missing required fields'}), 400
        
        # Check if username or email already exists
        existing_username = SocialMediaStudent.query.filter_by(username=data['username']).first()
        if existing_username:
            return jsonify({'error': 'Username already exists'}), 400
        
        existing_email = SocialMediaStudent.query.filter_by(email=data['email']).first()
        if existing_email:
            return jsonify({'error': 'Email already exists'}), 400
        
        # Create new student
        student = SocialMediaStudent(
            username=data['username'],
            full_name=data['full_name'],
            email=data['email'],
            phone_number=data.get('phone_number'),
            location=data.get('location'),
            bio=data.get('bio'),
            skill_level=data.get('skill_level', 'Beginner'),
            category=data.get('category', 'social-media'),  # CRITICAL FIX: Set category for proper login
            is_active=True
        )
        student.set_password(data['password'])
        
        db.session.add(student)
        db.session.commit()
        
        logger.info(f"âœ… Admin {request.current_admin.name} created social media student: {student.full_name}")
        
        return jsonify({
            'message': 'Student created successfully',
            'student': student.to_dict()
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Create student error: {str(e)}")
        return jsonify({'error': f'Failed to create student: {str(e)}'}), 500

@app.route('/api/admin/social-media/assign-tasks', methods=['POST'])
@admin_required
def assign_social_media_tasks():
    """Assign tasks to social media students - COMPREHENSIVE FIX"""
    try:
        data = request.get_json()
        
        # Enhanced logging
        logger.info(f"ðŸ“ Task assignment request from admin {request.current_admin.name}")
        logger.info(f"Request data: {json.dumps({k: v for k, v in data.items() if k != 'task_data'}, indent=2)}")
        
        # Validate required fields
        required_fields = ['student_ids', 'task_type', 'task_title', 'skill_category']
        missing_fields = [field for field in required_fields if field not in data or not data[field]]
        
        if missing_fields:
            logger.error(f"âŒ Missing required fields: {missing_fields}")
            return jsonify({'error': f'Missing required fields: {", ".join(missing_fields)}'}), 400
        
        student_ids = data['student_ids']
        if not isinstance(student_ids, list) or not student_ids:
            logger.error(f"âŒ Invalid student_ids: {student_ids}")
            return jsonify({'error': 'student_ids must be a non-empty list'}), 400
        
        skill_category = data['skill_category']
        logger.info(f"ðŸ” Looking for {len(student_ids)} students in category: {skill_category}")
        logger.info(f"   Student IDs: {student_ids}")
        
        # CRITICAL: Fetch students with flexible category matching
        if skill_category == 'social-media':
            # For social-media category, include NULL/empty categories (legacy students)
            students = SocialMediaStudent.query.filter(
                SocialMediaStudent.id.in_(student_ids),
                SocialMediaStudent.is_active == True
            ).filter(
                db.or_(
                    SocialMediaStudent.category == 'social-media',
                    SocialMediaStudent.category == None,
                    SocialMediaStudent.category == ''
                )
            ).all()
            logger.info(f"âœ… Social Media query (flexible): Found {len(students)} students")
        else:
            # For other categories, strict matching
            students = SocialMediaStudent.query.filter(
                SocialMediaStudent.id.in_(student_ids),
                SocialMediaStudent.is_active == True,
                SocialMediaStudent.category == skill_category
            ).all()
            logger.info(f"âœ… {skill_category} query (strict): Found {len(students)} students")
        
        # Log each found student
        for student in students:
            logger.info(f"   âœ“ {student.full_name} (ID: {student.id}, Category: {student.category or 'NULL'})")
        
        # Check for missing students
        if len(students) != len(student_ids):
            found_ids = {s.id for s in students}
            missing_ids = set(student_ids) - found_ids
            
            logger.error(f"âŒ Missing students: {missing_ids}")
            
            # Investigate missing students
            missing_details = []
            for missing_id in missing_ids:
                student = SocialMediaStudent.query.get(missing_id)
                if student:
                    reason = []
                    if not student.is_active:
                        reason.append("inactive")
                    if student.category and student.category != skill_category:
                        reason.append(f"wrong category ({student.category})")
                    if not reason:
                        reason.append("unknown")
                    
                    missing_details.append({
                        'id': student.id,
                        'name': student.full_name,
                        'category': student.category or 'NULL',
                        'is_active': student.is_active,
                        'reason': ', '.join(reason)
                    })
                    logger.warning(f"   âš ï¸ Student {student.id} ({student.full_name}): {', '.join(reason)}")
                else:
                    missing_details.append({
                        'id': missing_id,
                        'reason': 'not found in database'
                    })
                    logger.warning(f"   âš ï¸ Student {missing_id}: NOT IN DATABASE")
            
            return jsonify({
                'error': f'Could not find {len(missing_ids)} of {len(student_ids)} students',
                'missing_ids': list(missing_ids),
                'missing_details': missing_details,
                'found_students': [{'id': s.id, 'name': s.full_name} for s in students],
                'skill_category': skill_category
            }), 404
        
        # Parse due date
        due_date = None
        if data.get('due_date'):
            try:
                due_date = datetime.fromisoformat(data['due_date'].replace('Z', '+00:00'))
                logger.info(f"ðŸ“… Due date: {due_date}")
            except Exception as e:
                logger.warning(f"âš ï¸ Invalid due date: {e}")
        
        # Create tasks
        assigned_tasks = []
        for student in students:
            task = SocialMediaTask(
                student_id=student.id,
                admin_id=request.current_admin.id,
                task_type=data['task_type'],
                skill_category=skill_category,
                task_title=data['task_title'],
                task_description=data.get('task_description', ''),
                week_number=data.get('week_number'),
                day_number=data.get('day_number'),
                lesson_type=data.get('lesson_type', 'lesson'),
                video_url=data.get('video_url'),
                zoom_passcode=data.get('zoom_passcode'),
                duration=data.get('duration'),
                points_reward=data.get('points_reward', 0),
                access_code=data.get('access_code'),
                due_date=due_date,
                task_data=json.dumps(data.get('task_data', {})),
                status='pending'
            )
            
            db.session.add(task)
            db.session.flush()
            
            logger.info(f"âœ… Task {task.id} created for {student.full_name}")
            
            assigned_tasks.append({
                'task_id': task.id,
                'student_id': student.id,
                'student_name': student.full_name,
                'task_title': task.task_title
            })
        
        db.session.commit()
        
        logger.info(f"ðŸŽ‰ Successfully assigned {len(assigned_tasks)} tasks!")
        
        return jsonify({
            'success': True,
            'message': f'Successfully assigned {len(assigned_tasks)} tasks',
            'assigned_tasks': assigned_tasks,
            'details': {
                'admin': request.current_admin.name,
                'skill_category': skill_category,
                'task_title': data['task_title'],
                'students_count': len(assigned_tasks)
            }
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"âŒ Task assignment error: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({
            'error': f'Failed to assign tasks: {str(e)}'
        }), 500


print("âœ… Enhanced Social Media Task Assignment Endpoint")

@app.route('/api/admin/social-media/tasks', methods=['GET'])
@admin_required
def get_all_social_media_tasks():
    """Get all social media tasks (Admin view)"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 50, type=int)
        status_filter = request.args.get('status')
        task_type_filter = request.args.get('task_type')
        student_id = request.args.get('student_id', type=int)
        
        query = SocialMediaTask.query
        
        if status_filter:
            query = query.filter_by(status=status_filter)
        if task_type_filter:
            query = query.filter_by(task_type=task_type_filter)
        if student_id:
            query = query.filter_by(student_id=student_id)
        
        tasks_paginated = query.order_by(SocialMediaTask.assigned_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        tasks_data = []
        for task in tasks_paginated.items:
            task_dict = task.to_dict()
            # Add student info
            if task.student:
                task_dict['student_info'] = {
                    'id': task.student.id,
                    'name': task.student.full_name,
                    'email': task.student.email
                }
            tasks_data.append(task_dict)
        
        return jsonify({
            'tasks': tasks_data,
            'pagination': {
                'page': tasks_paginated.page,
                'pages': tasks_paginated.pages,
                'total': tasks_paginated.total,
                'per_page': per_page
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Get all social media tasks error: {str(e)}")
        return jsonify({'error': 'Failed to fetch tasks'}), 500


# ==================== INITIALIZATION ROUTE ====================

@app.route('/api/admin/social-media/initialize', methods=['POST'])
@admin_required
def initialize_social_media_system():
    """Initialize social media system with default students (Admin only)"""
    try:
        seed_social_media_students()
        
        return jsonify({
            'message': 'Social media system initialized successfully',
            'students_created': 3
        }), 200
        
    except Exception as e:
        logger.error(f"Initialization error: {str(e)}")
        return jsonify({'error': f'Initialization failed: {str(e)}'}), 500


# ==================== COURSE CATALOGUE ROUTES ====================

@app.route('/api/social-media/courses', methods=['GET'])
def get_social_media_courses():
    """Get all available courses/lessons for social media training"""
    try:
        # Return the complete  course catalogue
        courses = [
            # Week 1
            {
        id: 'onboarding',
        title: 'Onboarding Live Session',
        description: 'What to expect in the Social Media Management Training',
        type: 'live',
        week: 'Week 1',
        day: 'Day 1',
        duration: '60 min',
        videoUrl: 'https://www.canva.com/design/DAGkOEEe7RE/-jzfnV3VNnbNL5EguGSdoA/view?utm_content=DAGkOEEe7RE&utm_campaign=designshare&utm_medium=embeds&utm_source=link',
        category: 'Introduction'
    },
    {
        id: 'intro-smm',
        title: 'Introduction to Social Media Management',
        description: 'Learn the fundamentals of social media management and its importance in modern business',
        type: 'lesson',
        week: 'Week 1',
        day: 'Day 2',
        duration: '45 min',
        videoUrl: 'https://www.canva.com/design/DAGkQEnYEIw/nP7is1MijotBqQLXmFc_Og/view?utm_content=DAGkQEnYEIw&utm_campaign=share_your_design&utm_medium=link2&utm_source=shareyourdesignpanel',
        category: 'Fundamentals'
    },
    {
        id: 'career-paths',
        title: 'Freelance, In-house and Agency Owner',
        description: 'Explore different career paths in social media management',
        type: 'lesson',
        week: 'Week 1',
        day: 'Day 3',
        duration: '40 min',
        videoUrl: 'https://www.canva.com/design/DAGkQLQRYRM/gFGtBZltOpl-a5ob14eI6A/view?utm_content=DAGkQLQRYRM&utm_campaign=designshare&utm_medium=link&utm_source=recording_view',
        category: 'Career'
    },
    {
        id: 'instagram-platform',
        title: 'Understanding Instagram',
        description: 'Deep dive into Instagram platform features, algorithms, and best practices',
        type: 'lesson',
        week: 'Week 1',
        day: 'Day 4',
        duration: '50 min',
        videoUrl: 'https://www.canva.com/design/DAGktBodLoA/ajEtXlbtpq8dL7s-t99AbA/view?utm_content=DAGktBodLoA&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h7e815e940c',
        category: 'Platforms'
    },
    {
        id: 'linkedin-platform',
        title: 'Understanding LinkedIn',
        description: 'Master LinkedIn for professional social media management',
        type: 'lesson',
        week: 'Week 1',
        day: 'Day 4',
        duration: '45 min',
        videoUrl: 'https://www.canva.com/design/DAGktXpdr8A/UFlIcy2FVLAocE2HzpiCVw/view?utm_content=DAGktXpdr8A&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h217a32392d',
        category: 'Platforms'
    },
    {
        id: 'twitter-platform',
        title: 'Understanding Twitter',
        description: 'Learn Twitter strategies and engagement techniques',
        type: 'lesson',
        week: 'Week 1',
        day: 'Day 5',
        duration: '40 min',
        videoUrl: 'https://www.canva.com/design/DAGk3qku6Xc/O7SM7rhKZVSpyUVMtEIM-A/view?utm_content=DAGk3qku6Xc&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=hbca0201e7a',
        category: 'Platforms'
    },
    {
        id: 'tiktok-platform',
        title: 'Understanding TikTok',
        description: 'Explore TikTok content creation and viral marketing strategies',
        type: 'lesson',
        week: 'Week 1',
        day: 'Day 5',
        duration: '35 min',
        videoUrl: 'https://www.canva.com/design/DAGk_2WQoQY/6o-oL1bhuqs5Iv4kepBnJw/view?utm_content=DAGk_2WQoQY&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h9b389e5836',
        category: 'Platforms'
    },
    {
        id: 'content-strategy-live',
        title: 'Creating a Content Strategy',
        description: 'Live session on developing effective content strategies',
        type: 'live',
        week: 'Week 1',
        day: 'Saturday',
        duration: '90 min',
        videoUrl: '#',
        category: 'Strategy'
    },

    {
        id: 'social-audit',
        title: 'Auditing a Social Media Account',
        description: 'Learn how to conduct comprehensive social media audits',
        type: 'lesson',
        week: 'Week 2',
        day: 'Day 1',
        duration: '45 min',
        videoUrl: 'https://www.canva.com/design/DAGlec2NizY/BQsKbYBu7496Xu3o1Kou8w/view?utm_content=DAGlec2NizY&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=hd6d9816ea3',
        category: 'Analysis'
    },
    {
        id: 'social-goals',
        title: 'How to Set Social Media Goals',
        description: 'Master goal setting for social media campaigns',
        type: 'lesson',
        week: 'Week 2',
        day: 'Day 1',
        duration: '40 min',
        videoUrl: 'https://www.canva.com/design/DAGliB6y56w/Z2W_DnzH1oZFaq6CMJK4EQ/view?utm_content=DAGliB6y56w&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h96341d5801',
        category: 'Strategy'
    },
    {
        id: 'social-reporting',
        title: 'Social Media Reporting',
        description: 'Create professional reports for clients and stakeholders',
        type: 'lesson',
        week: 'Week 2',
        day: 'Day 2',
        duration: '50 min',
        videoUrl: 'https://www.canva.com/design/DAGlv8e6ALY/lme3TdgSHm66pKVkYl2pYA/view?utm_content=DAGlv8e6ALY&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h4f3e571ec3',
        category: 'Reporting'
    },
    {
        id: 'caption-writing',
        title: 'How to Write Captions',
        description: 'Master the art of engaging caption writing',
        type: 'lesson',
        week: 'Week 2',
        day: 'Day 2',
        duration: '35 min',
        videoUrl: 'https://www.canva.com/design/DAGlwWp3XA0/QeI83vBRDEXcsUqeJI0pVA/view?utm_content=DAGlwWp3XA0&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=hdd89b929bb',
        category: 'Content Creation'
    },
    {
        id: 'scheduling-tools',
        title: 'Social Media Scheduling & Analytics Tools',
        description: 'Learn to use professional scheduling and analytics tools',
        type: 'lesson',
        week: 'Week 2',
        day: 'Day 3',
        duration: '55 min',
        videoUrl: 'https://www.canva.com/design/DAGmCEgSzvU/nov3dR43srAUlQY-lwNYlQ/view?utm_content=DAGmCEgSzvU&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h322ba456ba',
        category: 'Tools'
    },
    {
        id: 'bio-optimization',
        title: 'Bio Optimization & Platform Management',
        description: 'Optimize profiles and manage multiple platforms effectively',
        type: 'lesson',
        week: 'Week 2',
        day: 'Day 4',
        duration: '45 min',
        videoUrl: 'https://www.canva.com/design/DAGm24noGjI/BjzW3MgfOOjiFw8M9js8aQ/view?utm_content=DAGm24noGjI&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h922401713d',
        category: 'Optimization'
    },
    {
        id: 'highlights-creation',
        title: 'How to Create Simple Highlights',
        description: 'Design professional Instagram highlights using design tools',
        type: 'lesson',
        week: 'Week 2',
        day: 'Day 5',
        duration: '25 min',
        videoUrl: 'https://youtu.be/hUHtpxHHZ-8?si=UYtwsRJbA9GafSBv',
        category: 'Design'
    },
    {
        id: 'hashtag-research',
        title: 'How to Source for Hashtags Manually',
        description: 'Master manual hashtag research techniques',
        type: 'lesson',
        week: 'Week 2',
        day: 'Day 5',
        duration: '30 min',
        videoUrl: 'https://youtu.be/sr-XFc4F3kc?si=hl0aeS4P5_wxhFLN',
        category: 'Research'
    },
    {
        id: 'content-calendar-live',
        title: 'How to Draft a Content Calendar',
        description: 'Live session on creating effective content calendars',
        type: 'live',
        week: 'Week 2',
        day: 'Saturday',
        duration: '90 min',
        videoUrl: '#',
        category: 'Planning'
    },
    
    {
        id: 'negotiation-skills',
        title: 'Negotiation and Closing Skills for Social Media Managers',
        description: 'Master negotiation techniques for social media managers',
        type: 'lesson',
        week: 'Week 3',
        day: 'Day 1',
        duration: '50 min',
        videoUrl: 'https://www.canva.com/design/DAGm4CkZwhM/OF0Ecdl3st9yn3hOE5hMEA/view?utm_content=DAGm4CkZwhM&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h4c5e42ef95',
        category: 'Business'
    },
    {
        id: 'client-onboarding',
        title: 'How to Onboard New Clients Professionally',
        description: 'Professional client onboarding processes and best practices',
        type: 'lesson',
        week: 'Week 3',
        day: 'Day 1',
        duration: '45 min',
        videoUrl: 'https://www.canva.com/design/DAGnltsT6pQ/43XSw2qVl5INQGkhULzT7g/view?utm_content=DAGnltsT6pQ&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=haa5bc0599d',
        category: 'Business'
    },
    {
        id: 'client-pricing',
        title: 'How to Charge Your Clients',
        description: 'Pricing strategies and value-based charging methods',
        type: 'lesson',
        week: 'Week 3',
        day: 'Day 2',
        duration: '40 min',
        videoUrl: 'https://www.canva.com/design/DAGnlv-_XEI/fnxSQHzd_F-K2bmXed_m8A/view?utm_content=DAGnlv-_XEI&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h9d9eb9fa67',
        category: 'Business'
    },
    {
        id: 'ai-for-smm',
        title: 'How to Use AI as a Social Media Manager',
        description: 'Leverage AI tools to enhance your social media management',
        type: 'lesson',
        week: 'Week 3',
        day: 'Day 2',
        duration: '35 min',
        videoUrl: 'https://www.canva.com/design/DAGnnhWNNOM/vrtiSlZORLr_8f7b0HzwYg/view?utm_content=DAGnnhWNNOM&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h00d40c9d3a',
        category: 'Technology'
    },
    {
        id: 'portfolio-creation',
        title: 'How to Create a Simple Portfolio',
        description: 'Build a professional portfolio to showcase your work',
        type: 'lesson',
        week: 'Week 3',
        day: 'Day 3',
        duration: '45 min',
        videoUrl: 'https://www.canva.com/design/DAGntAxGeNg/_nHRrarxV7vV3Ws2x1CkbA/view?utm_content=DAGntAxGeNg&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=he63d61cdd1',
        category: 'Business'
    },
    {
        id: 'upwork-clients',
        title: 'How to Win Clients on Upwork',
        description: 'Strategies for finding and winning clients on Upwork',
        type: 'lesson',
        week: 'Week 3',
        day: 'Day 3',
        duration: '30 min',
        videoUrl: 'https://youtu.be/HdUSx5xaIWM',
        category: 'Freelancing'
    },
    {
        id: 'ad-campaigns',
        title: 'What is an Ad Campaign?',
        description: 'Introduction to social media advertising campaigns',
        type: 'lesson',
        week: 'Week 3',
        day: 'Day 4',
        duration: '40 min',
        videoUrl: 'https://www.canva.com/design/DAGnzGjRlYI/cxmer5Y9Q_BZilyWPwoD2g/view?utm_content=DAGnzGjRlYI&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=hb1856f930f',
        category: 'Advertising'
    },
    {
        id: 'common-mistakes',
        title: 'Common Mistakes & How to Fix Them',
        description: 'Learn from common social media management mistakes',
        type: 'lesson',
        week: 'Week 3',
        day: 'Day 5',
        duration: '35 min',
        videoUrl: 'https://www.canva.com/design/DAGoGsX_vE8/5UWqsKBTq7me1X1GCniZ-Q/view?utm_content=DAGoGsX_vE8&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=hef83d726d7',
        category: 'Best Practices'
    },
    {
        id: 'ads-practical-live',
        title: 'Practical Session: Creating and Targeting Ads',
        description: 'Hands-on session for creating and targeting social media ads',
        type: 'live',
        week: 'Week 3',
        day: 'Saturday',
        duration: '120 min',
        videoUrl: '#',
        category: 'Advertising'
    },
  
    {
        id: 'ab-testing',
        title: 'Understanding A/B Testing',
        description: 'Master A/B testing for social media campaigns',
        type: 'lesson',
        week: 'Week 4',
        day: 'Day 1',
        duration: '40 min',
        videoUrl: 'https://www.canva.com/design/DAGoGsirep4/NAM84vAjaKos7LHRSL2qow/view?utm_content=DAGoGsirep4&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h652d159225',
        category: 'Analytics'
    },
    {
        id: 'advanced-targeting',
        title: 'Advanced Targeting Strategies on Meta (Facebook & Instagram Ads)',
        description: 'Advanced Facebook & Instagram advertising targeting techniques',
        type: 'lesson',
        week: 'Week 4',
        day: 'Day 2',
        duration: '55 min',
        videoUrl: 'https://www.canva.com/design/DAGoKDyvZLY/K0M4309bgDrUaT_hTuN5oQ/view?utm_content=DAGoKDyvZLY&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=hbb0243116b',
        category: 'Advertising'
    },
    {
        id: 'smartphone-ads',
        title: 'SMMI Smartphone Ads by FII',
        description: 'Mobile-first advertising strategies and implementation',
        type: 'lesson',
        week: 'Week 4',
        day: 'Day 3',
        duration: '45 min',
        videoUrl: 'https://youtu.be/yvubFy1WAv0?si=lNM6RCJgVAUhCZ_r',
        category: 'Mobile Marketing'
    },
    {
        id: 'smm-workflow',
        title: 'Social Media Management Workflow',
        description: 'Establish efficient workflows for social media management',
        type: 'practical',
        week: 'Week 4',
        day: 'Day 4',
        duration: '60 min',
        videoUrl: 'https://us06web.zoom.us/rec/share/BBi7AOBXPhNiYhEXoYlAIUDdIcltiOFhQ4q3Fi1u0U1nnKMMO7sqrf6b0YmWwjYh.YJkpae5xlWRNo9cZ',
        zoomPasscode: '=.R8@C1Q',
        category: 'Workflow'
    }
]
        
        return jsonify({
            'courses': courses,
            'total_count': len(courses)
        }), 200
        
    except Exception as e:
        logger.error(f"Get courses error: {str(e)}")
        return jsonify({'error': 'Failed to fetch courses'}), 500


print("âœ… Social Media Management System API Routes Loaded")
# Add these endpoints to your Flask backend for admin analytics

@app.route('/api/social-media/task/<int:task_id>/complete', methods=['POST'])
def complete_social_media_task(task_id):
    """
    Complete a social media task and update student progress
    """
    try:
        # Get auth token
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            logger.warning("Task completion without valid auth token")
            return jsonify({'error': 'Authentication required'}), 401
        
        token = auth_header.split(' ')[1]
        
        # Decode token
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            student_id = payload.get('student_id')
            
            if payload.get('student_type') != 'social_media':
                return jsonify({'error': 'Invalid token type'}), 401
                
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
        
        # Get the task
        task = SocialMediaTask.query.filter_by(
            id=task_id,
            student_id=student_id
        ).first()
        
        if not task:
            logger.warning(f"Task {task_id} not found for student {student_id}")
            return jsonify({'error': 'Task not found'}), 404
        
        # Get submission data
        data = request.get_json()
        score = data.get('score', 0)
        max_score = data.get('max_score', 100)
        time_spent_minutes = data.get('time_spent_minutes', 0)
        
        logger.info(f"Task {task_id} completion - Score: {score}/{max_score}, Time: {time_spent_minutes}min")
        
        # Calculate completion percentage
        completion_percentage = (score / max_score * 100) if max_score > 0 else 0
        
        # Store the quiz score in the task
        task.quiz_score = score
        task.quiz_max_score = max_score
        task.completion_percentage = completion_percentage
        
        # Mark task as completed
        task.status = 'completed'
        task.completed_at = datetime.utcnow()
        
        # Update student
        student = SocialMediaStudent.query.get(student_id)
        if not student:
            return jsonify({'error': 'Student not found'}), 404
        
        student.total_tasks_completed = (student.total_tasks_completed or 0) + 1
        
        # Get or determine week_number
        week_number = task.week_number
        if not week_number:
            logger.warning(f"Task {task_id} has no week_number, using default week 1")
            week_number = 1
            task.week_number = week_number
        
        logger.info(f"Using week_number: {week_number}")
        
        # CRITICAL: Count total lessons correctly for this week
        total_week_tasks = SocialMediaTask.query.filter_by(
            student_id=student_id,
            week_number=week_number
        ).count()
        
        # Count completed tasks in this week
        completed_week_tasks = SocialMediaTask.query.filter_by(
            student_id=student_id,
            week_number=week_number,
            status='completed'
        ).count()
        
        # Calculate week progress
        week_progress = (completed_week_tasks / total_week_tasks * 100) if total_week_tasks > 0 else 0
        
        # CRITICAL: Calculate OVERALL progress across ALL weeks (assuming 4 weeks total)
        # Count ALL tasks for this student (all weeks)
        total_all_tasks = SocialMediaTask.query.filter_by(
            student_id=student_id
        ).count()
        
        # Count ALL completed tasks
        completed_all_tasks = SocialMediaTask.query.filter_by(
            student_id=student_id,
            status='completed'
        ).count()
        
        # Overall progress = completed tasks / total tasks * 100
        overall_progress = (completed_all_tasks / total_all_tasks * 100) if total_all_tasks > 0 else 0
        
        logger.info(f"Week {week_number}: {completed_week_tasks}/{total_week_tasks} ({week_progress:.1f}%)")
        logger.info(f"Overall: {completed_all_tasks}/{total_all_tasks} ({overall_progress:.1f}%)")
        
        # Update or create progress record for this week
        progress = SocialMediaProgress.query.filter_by(
            student_id=student_id,
            week_number=week_number
        ).first()
        
        if not progress:
            progress = SocialMediaProgress(
                student_id=student_id,
                task_id=None,
                week_number=week_number,
                completed_lessons=completed_week_tasks,
                total_lessons=total_week_tasks,
                time_spent_minutes=time_spent_minutes,
                progress_percentage=week_progress,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            db.session.add(progress)
            logger.info(f"Created new progress record for Week {week_number}")
        else:
            # Update with actual counts
            progress.completed_lessons = completed_week_tasks
            progress.total_lessons = total_week_tasks
            progress.progress_percentage = week_progress
            progress.time_spent_minutes = (progress.time_spent_minutes or 0) + time_spent_minutes
            progress.updated_at = datetime.utcnow()
            logger.info(f"Updated progress for Week {week_number}")
        
        # Commit all changes
        try:
            db.session.commit()
            logger.info(f"âœ… Task {task_id} completed. Score: {score}/{max_score}, Week Progress: {week_progress:.1f}%, Overall: {overall_progress:.1f}%")
        except Exception as e:
            db.session.rollback()
            logger.error(f"Database commit error: {str(e)}")
            logger.error(traceback.format_exc())
            raise
        
        # Return success response with BOTH week and overall progress
        return jsonify({
            'success': True,
            'message': 'Task completed successfully',
            'quiz_score': score,
            'quiz_max_score': max_score,
            'completion_percentage': round(completion_percentage, 1),
            'time_spent': time_spent_minutes,
            'progress': {
                'week_number': progress.week_number,
                'completed_lessons': progress.completed_lessons,
                'total_lessons': progress.total_lessons,
                'week_progress_percentage': round(week_progress, 1),  # Week-specific
                'overall_progress_percentage': round(overall_progress, 1),  # Overall across all weeks
                'time_spent_minutes': progress.time_spent_minutes
            },
            'student': {
                'total_tasks_completed': student.total_tasks_completed,
                'total_tasks': total_all_tasks,
                'overall_completion': round(overall_progress, 1)
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Error completing task: {str(e)}")
        logger.error(traceback.format_exc())
        db.session.rollback()
        return jsonify({
            'error': f'Failed to complete task: {str(e)}'
        }), 500
    
@app.route('/api/social-media/scoreboard', methods=['GET'])
def get_social_media_scoreboard():
    """
    Get scoreboard of all social media students
    """
    try:
        students = SocialMediaStudent.query.all()
        
        scoreboard = []
        
        for student in students:
            # Count total tasks
            total_tasks = SocialMediaTask.query.filter_by(
                student_id=student.id
            ).count()
            
            # Count completed tasks
            completed_tasks = SocialMediaTask.query.filter_by(
                student_id=student.id,
                status='completed'
            ).count()
            
            # Calculate overall progress
            overall_progress = (completed_tasks / total_tasks * 100) if total_tasks > 0 else 0
            
            # FIXED: Get unique time spent per week (not summing duplicates)
            # Get distinct weeks and their time
            weekly_times = db.session.query(
                SocialMediaProgress.week_number,
                SocialMediaProgress.time_spent_minutes
            ).filter_by(
                student_id=student.id
            ).distinct().all()
            
            # Sum the time from distinct weeks
            total_time_spent = sum(week.time_spent_minutes or 0 for week in weekly_times)
            
            # Calculate average quiz score
            tasks_with_scores = SocialMediaTask.query.filter(
                SocialMediaTask.student_id == student.id,
                SocialMediaTask.quiz_score.isnot(None),
                SocialMediaTask.quiz_max_score.isnot(None),
                SocialMediaTask.quiz_max_score > 0
            ).all()
            
            if tasks_with_scores:
                total_percentage = sum(
                    (task.quiz_score / task.quiz_max_score * 100) 
                    for task in tasks_with_scores
                )
                average_score = total_percentage / len(tasks_with_scores)
            else:
                average_score = 0
            
            scoreboard.append({
                'id': student.id,
                'name': student.full_name,
                'email': student.email,
                'category': student.category or 'General',
                'lessons_completed': completed_tasks,
                'total_lessons': total_tasks,
                'overall_progress': round(overall_progress, 1),
                'time_spent': int(total_time_spent),
                'average_score': round(average_score, 1)
            })
        
        # Sort by overall progress (descending)
        scoreboard.sort(key=lambda x: x['overall_progress'], reverse=True)
        
        logger.info(f"Scoreboard generated with {len(scoreboard)} students")
        
        return jsonify({
            'success': True,
            'scoreboard': scoreboard,
            'total_students': len(scoreboard)
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching scoreboard: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({'error': str(e)}), 500
            
@app.route('/api/admin/social-media/task/<int:task_id>', methods=['DELETE'])
@admin_required
def delete_social_media_task(task_id):
    """Delete a social media task (Admin only)"""
    try:
        # Find the task
        task = SocialMediaTask.query.get(task_id)
        if not task:
            return jsonify({'error': 'Task not found'}), 404
        
        # Store task info for response
        task_info = {
            'id': task.id,
            'title': task.task_title,
            'student_id': task.student_id
        }
        
        # Delete the task
        db.session.delete(task)
        db.session.commit()
        
        logger.info(f"âœ… Admin {request.current_admin.name} deleted task {task_id}")
        
        return jsonify({
            'success': True,
            'message': 'Task deleted successfully',
            'deleted_task': task_info
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error deleting task: {str(e)}")
        return jsonify({'error': f'Failed to delete task: {str(e)}'}), 500


@app.route('/api/admin/social-media/tasks/bulk-delete', methods=['POST'])
@admin_required
def bulk_delete_social_media_tasks():
    """Delete multiple social media tasks at once (Admin only)"""
    try:
        data = request.get_json()
        task_ids = data.get('task_ids', [])
        
        if not task_ids or not isinstance(task_ids, list):
            return jsonify({'error': 'task_ids must be a non-empty list'}), 400
        
        # Find and delete tasks
        deleted_count = 0
        for task_id in task_ids:
            task = SocialMediaTask.query.get(task_id)
            if task:
                db.session.delete(task)
                deleted_count += 1
        
        db.session.commit()
        
        logger.info(f"âœ… Admin {request.current_admin.name} bulk deleted {deleted_count} tasks")
        
        return jsonify({
            'success': True,
            'message': f'Successfully deleted {deleted_count} tasks',
            'deleted_count': deleted_count
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error bulk deleting tasks: {str(e)}")
        return jsonify({'error': f'Failed to delete tasks: {str(e)}'}), 500

print("âœ… Social Media Task Management API Routes Loaded")

# Also add this helper route to get overall student summary
@app.route('/api/social-media/student/summary', methods=['GET'])
def get_social_media_student_summarys():
    """Get overall summary statistics for the progress page"""
    try:
        auth_header = request.headers.get('Authorization')
        token = auth_header.split(' ')[1]
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
        # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

        student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

        if not student_id:

            logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

            return jsonify({'error': 'Invalid token'}), 401
        
        student = SocialMediaStudent.query.get(student_id)
        if not student:
            return jsonify({'error': 'Student not found'}), 404
        
        # Get all progress records
        progress_records = SocialMediaProgress.query.filter_by(student_id=student_id).all()
        
        # Calculate totals
        total_lessons_completed = sum([p.completed_lessons for p in progress_records])
        total_lessons = sum([p.total_lessons for p in progress_records])
        total_time_spent = sum([p.time_spent_minutes for p in progress_records])
        
        # Calculate overall progress percentage
        overall_progress = 0
        if total_lessons > 0:
            overall_progress = (total_lessons_completed / total_lessons) * 100
        
        # Convert minutes to hours
        total_time_spent_hours = round(total_time_spent / 60, 1)
        
        return jsonify({
            'success': True,
            'statistics': {
                'completed_lessons': total_lessons_completed,
                'total_lessons': total_lessons,
                'overall_progress': round(overall_progress, 1),
                'total_points': student.total_points or 0,
                'total_time_spent_minutes': total_time_spent,
                'total_time_spent_hours': total_time_spent_hours,
                'tasks_completed': student.total_tasks_completed or 0
            },
            'progress_by_week': [p.to_dict() for p in progress_records]
        }), 200
        
    except Exception as e:
        logger.error(f"Get summary error: {str(e)}")
        return jsonify({'error': 'Failed to fetch summary'}), 500

@app.route('/api/social-media/progress/update', methods=['POST'])
def update_social_media_progress():
    """Update progress for a specific week"""
    try:
        # Get authorization token
        auth_header = request.headers.get('Authorization')
        if not auth_header:
            return jsonify({'error': 'No authorization token'}), 401
        
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except:
            return jsonify({'error': 'Invalid token'}), 401
        
        # Get data from request
        data = request.get_json() or {}
        week_number = data.get('week_number')
        time_spent_minutes = data.get('time_spent_minutes', 0)
        notes = data.get('notes', '')
        
        if not week_number:
            return jsonify({'error': 'Week number is required'}), 400
        
        # Find or create progress record
        progress = SocialMediaProgress.query.filter_by(
            student_id=student_id,
            week_number=week_number
        ).first()
        
        if not progress:
            # Count total lessons for this week
            total_lessons = SocialMediaTask.query.filter_by(
                student_id=student_id,
                week_number=week_number
            ).count()
            
            # Create new progress
            progress = SocialMediaProgress(
                student_id=student_id,
                week_number=week_number,
                completed_lessons=0,
                total_lessons=total_lessons,
                time_spent_minutes=time_spent_minutes,
                notes=notes
            )
            db.session.add(progress)
        else:
            # Update existing progress
            progress.time_spent_minutes += time_spent_minutes
            if notes:
                progress.notes = notes
        
        progress.update_progress()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'progress': progress.to_dict()
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error updating progress: {str(e)}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/social-media/student/summary', methods=['GET'])
def get_social_media_student_summary():
    """Get comprehensive summary of student's performance"""
    try:
        # Get authorization token
        auth_header = request.headers.get('Authorization')
        if not auth_header:
            return jsonify({'error': 'No authorization token'}), 401
        
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except:
            return jsonify({'error': 'Invalid token'}), 401
        
        # Get student
        student = SocialMediaStudent.query.get(student_id)
        if not student:
            return jsonify({'error': 'Student not found'}), 404
        
        # Get all tasks
        all_tasks = SocialMediaTask.query.filter_by(student_id=student_id).all()
        completed_tasks = [t for t in all_tasks if t.status == 'completed']
        
        # Get all progress records
        progress_records = SocialMediaProgress.query.filter_by(
            student_id=student_id
        ).order_by(SocialMediaProgress.week_number).all()
        
        # Calculate overall statistics
        total_time_spent = sum([p.time_spent_minutes for p in progress_records])
        total_lessons = sum([p.total_lessons for p in progress_records])
        completed_lessons = sum([p.completed_lessons for p in progress_records])
        
        overall_progress = (completed_lessons / total_lessons * 100) if total_lessons > 0 else 0
        
        # Get average completion percentage
        completion_percentages = [t.completion_percentage for t in completed_tasks if t.completion_percentage]
        avg_completion = sum(completion_percentages) / len(completion_percentages) if completion_percentages else 0
        
        return jsonify({
            'student': student.to_dict(),
            'statistics': {
                'total_tasks': len(all_tasks),
                'completed_tasks': len(completed_tasks),
                'pending_tasks': len([t for t in all_tasks if t.status == 'pending']),
                'in_progress_tasks': len([t for t in all_tasks if t.status == 'in_progress']),
                'total_points': student.total_points,
                'total_time_spent_minutes': total_time_spent,
                'total_time_spent_hours': round(total_time_spent / 60, 1),
                'overall_progress': round(overall_progress, 1),
                'average_completion': round(avg_completion, 1),
                'completed_lessons': completed_lessons,
                'total_lessons': total_lessons
            },
            'weekly_progress': [p.to_dict() for p in progress_records],
            'recent_completions': [t.to_dict() for t in completed_tasks[-5:]]
        }), 200
        
    except Exception as e:
        logger.error(f"Error getting student summary: {str(e)}")
        return jsonify({'error': str(e)}), 500

print("âœ… Social Media Performance Tracking API Routes Loaded")



# 1. FIXED: Get Students by Category (Restore original behavior)
@app.route('/api/admin/social-media/students/by-category', methods=['GET'])
@admin_required
def get_students_by_category():
    """
    Get students filtered by skill category (Admin only)
    FIXED: Properly handles NULL categories WITHOUT auto-loading
    """
    try:
        category = request.args.get('category') or request.args.get('skill_category')
        
        if not category:
            logger.error("âŒ No category parameter provided")
            return jsonify({'error': 'Category parameter is required'}), 400
        
        logger.info(f"ðŸ” Searching for students in category: {category}")
        
        # Build query based on category
        if category == 'social-media':
            # For social-media, include students with NULL category (legacy students)
            students = SocialMediaStudent.query.filter(
                db.or_(
                    SocialMediaStudent.category == category,
                    SocialMediaStudent.category == None,
                    SocialMediaStudent.category == ''
                )
            ).filter_by(is_active=True).order_by(SocialMediaStudent.full_name).all()
            
            logger.info(f"âœ… Social Media query (including NULL): Found {len(students)} students")
        else:
            # For other categories, strict matching
            students = SocialMediaStudent.query.filter_by(
                category=category,
                is_active=True
            ).order_by(SocialMediaStudent.full_name).all()
            
            logger.info(f"âœ… {category} query: Found {len(students)} students")
        
        # Debug: Log each found student (first 3)
        for student in students[:3]:
            logger.info(f"   ðŸ“ Student: {student.full_name} (ID: {student.id}, Category: {student.category or 'NULL'})")
        
        logger.info(f"âœ… Admin {request.current_admin.name} retrieved {len(students)} students in {category} category")
        
        return jsonify({
            'success': True,
            'category': category,
            'students': [s.to_dict() for s in students],
            'total_count': len(students)
        }), 200
        
    except Exception as e:
        logger.error(f"âŒ Get students by category error: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return jsonify({'error': f'Failed to fetch students: {str(e)}'}), 500

# Workshop Registration and Token Management Endpoints
# Add these to your Flask application

from datetime import datetime, timedelta
import jwt

# ==================== WORKSHOP REGISTRATION ====================
# FIXED WORKSHOP REGISTRATION ENDPOINT
# Replace the existing /api/workshop/register endpoint in your Flask app

@app.route('/api/workshop/register', methods=['POST'])
def workshop_register():
    """
    Register a new workshop student
    """
    try:
        data = request.get_json()
        
        # Required fields validation
        required_fields = ['username', 'password', 'full_name', 'email', 'skill_category', 'age_range', 'institution_type']
        for field in required_fields:
            if field not in data or not data[field]:
                return jsonify({'error': f'Missing required field: {field}'}), 400
        
        # Check if username already exists
        existing_username = SocialMediaStudent.query.filter_by(username=data['username']).first()
        if existing_username:
            return jsonify({'error': 'Username already exists'}), 400
        
        # Check if email already exists
        existing_email = SocialMediaStudent.query.filter_by(email=data['email']).first()
        if existing_email:
            return jsonify({'error': 'Email already exists'}), 400
        
        # Create new workshop student
        student = SocialMediaStudent(
            username=data['username'],
            full_name=data['full_name'],
            email=data['email'],
            phone_number=data.get('phone_number'),
            location=data.get('location'),
            skill_level='Beginner',
            category=data['skill_category'],  # âœ… FIXED: Use 'category' not 'skill_category'
            is_active=True
        )
        
        # Set additional fields if they exist in the model
        if hasattr(student, 'age_range'):
            student.age_range = data.get('age_range')
        if hasattr(student, 'birth_month'):
            student.birth_month = data.get('birth_month')
        if hasattr(student, 'birth_day'):
            student.birth_day = data.get('birth_day')
        if hasattr(student, 'institution_type'):
            student.institution_type = data.get('institution_type')
        if hasattr(student, 'institution_name'):
            student.institution_name = data.get('institution_name')
        
        # Set password
        student.set_password(data['password'])
        
        db.session.add(student)
        db.session.commit()
        
        logger.info(f"âœ… New workshop student registered: {student.full_name} ({data['skill_category']})")
        
        return jsonify({
            'success': True,
            'message': 'Registration successful! You can now login.',
            'student': student.to_dict()
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Workshop registration error: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return jsonify({'error': f'Registration failed: {str(e)}'}), 500


# Also update the updated_model.py to clarify the field name
print("âœ… Fixed Workshop Registration Endpoint - Using 'category' field")

# ==================== TOKEN REFRESH ====================

@app.route('/api/auth/refresh-token', methods=['POST'])
def refresh_token():
    """
    Refresh an expired or expiring JWT token
    """
    try:
        # Get the old token from request
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No token provided'}), 401
        
        old_token = auth_header.split(' ')[1]
        
        try:
            # Try to decode the token (even if expired)
            payload = jwt.decode(old_token, JWT_SECRET_KEY, algorithms=['HS256'], options={"verify_exp": False})
            
            student_id = payload.get('student_id')
            student_type = payload.get('student_type', 'social_media')
            
            # Verify student still exists and is active
            student = SocialMediaStudent.query.get(student_id)
            if not student or not student.is_active:
                return jsonify({'error': 'Student not found or inactive'}), 401
            
            # Generate new token
            new_token = create_sm_student_token(student_id)
            
            logger.info(f"âœ… Token refreshed for student {student.full_name}")
            
            return jsonify({
                'success': True,
                'token': new_token,
                'student': student.to_dict()
            }), 200
            
        except jwt.InvalidTokenError as e:
            logger.error(f"Invalid token during refresh: {str(e)}")
            return jsonify({'error': 'Invalid token'}), 401
            
    except Exception as e:
        logger.error(f"Token refresh error: {str(e)}")
        return jsonify({'error': 'Token refresh failed'}), 500


# ==================== ADMIN TOKEN REFRESH ====================

@app.route('/api/admin/auth/refresh-token', methods=['POST'])
def admin_refresh_token():
    """
    Refresh an expired or expiring admin JWT token
    """
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No token provided'}), 401
        
        old_token = auth_header.split(' ')[1]
        
        try:
            # Decode token (even if expired)
            payload = jwt.decode(old_token, JWT_SECRET_KEY, algorithms=['HS256'], options={"verify_exp": False})
            
            admin_id = payload.get('admin_id')
            
            # Verify admin still exists and is active
            admin = Admin.query.get(admin_id)
            if not admin or not admin.is_active:
                return jsonify({'error': 'Admin not found or inactive'}), 401
            
            # Generate new token
            new_payload = {
                'admin_id': admin.id,
                'email': admin.email,
                'role': admin.role,
                'exp': datetime.utcnow() + timedelta(days=1)
            }
            new_token = jwt.encode(new_payload, JWT_SECRET_KEY, algorithm='HS256')
            
            logger.info(f"âœ… Admin token refreshed for {admin.name}")
            
            return jsonify({
                'success': True,
                'token': new_token,
                'admin': {
                    'id': admin.id,
                    'name': admin.name,
                    'email': admin.email,
                    'role': admin.role
                }
            }), 200
            
        except jwt.InvalidTokenError as e:
            logger.error(f"Invalid admin token during refresh: {str(e)}")
            return jsonify({'error': 'Invalid token'}), 401
            
    except Exception as e:
        logger.error(f"Admin token refresh error: {str(e)}")
        return jsonify({'error': 'Token refresh failed'}), 500


@app.route('/api/admin/analytics/comprehensive', methods=['GET'])
@admin_required
def get_admin_comprehensive_analytics():
    """Get comprehensive analytics for all students' tasks"""
    try:
        # Get query parameters for filtering
        school_filter = request.args.get('school', '')
        grade_filter = request.args.get('grade', '')
        date_from = request.args.get('date_from', '')
        date_to = request.args.get('date_to', '')
        
        # Build base query
        tasks_query = StudentTask.query.join(Student)
        
        # Apply filters
        if school_filter:
            tasks_query = tasks_query.filter(Student.school_name.ilike(f'%{school_filter}%'))
        
        if grade_filter:
            tasks_query = tasks_query.filter(Student.grade_level == grade_filter)
        
        if date_from:
            try:
                from_date = datetime.fromisoformat(date_from)
                tasks_query = tasks_query.filter(StudentTask.assigned_at >= from_date)
            except ValueError:
                pass
        
        if date_to:
            try:
                to_date = datetime.fromisoformat(date_to)
                tasks_query = tasks_query.filter(StudentTask.assigned_at <= to_date)
            except ValueError:
                pass
        
        # Get all filtered tasks
        all_tasks = tasks_query.all()
        
        # Initialize analytics data
        analytics = {
            'overview': {
                'total_tasks': len(all_tasks),
                'total_students': len(set(task.student_id for task in all_tasks)),
                'completed_tasks': 0,
                'pending_tasks': 0,
                'in_progress_tasks': 0,
                'avg_time_spent': 0,
                'avg_score': 0,
                'total_points_awarded': 0,
                'total_acard_distributed': 0
            },
            'task_types': {},
            'grade_performance': {},
            'school_performance': {},
            'recent_submissions': [],
            'top_performers': [],
            'completion_trends': [],
            'time_analysis': {
                'avg_time_by_type': {},
                'fastest_completions': [],
                'longest_completions': []
            },
            'score_distribution': {
                'excellent': 0,  # 90-100%
                'good': 0,       # 70-89%
                'fair': 0,       # 50-69%
                'needs_improvement': 0  # <50%
            }
        }
        
        # Process each task
        total_time = 0
        total_score = 0
        total_max_score = 0
        completed_count = 0
        time_by_type = {}
        submissions_for_sorting = []
        
        for task in all_tasks:
            student = task.student
            
            # Count by status
            if task.status == 'completed':
                analytics['overview']['completed_tasks'] += 1
                completed_count += 1
                
                # Process task data
                task_data = json.loads(task.task_data) if task.task_data else {}
                completion_data = task_data.get('completion_data', {})
                
                # Add to submissions for sorting
                submissions_for_sorting.append({
                    'id': task.id,
                    'task_title': task.task_title,
                    'task_type': task.task_type,
                    'student_name': student.name,
                    'student_grade': getattr(student, 'grade_level', 'N/A'),
                    'school_name': getattr(student, 'school_name', 'N/A'),
                    'status': task.status,
                    'completed_at': task.completed_at.isoformat() if task.completed_at else None,
                    'completion_data': completion_data,
                    'points_reward': task.points_reward,
                    'acard_credit': float(task.acard_credit or 0)
                })
                
                # Calculate totals
                analytics['overview']['total_points_awarded'] += task.points_reward or 0
                analytics['overview']['total_acard_distributed'] += float(task.acard_credit or 0)
                
                # Process completion data
                if completion_data:
                    time_spent = completion_data.get('time_spent', 0)
                    score = completion_data.get('score', 0)
                    max_score = completion_data.get('max_score', 100)
                    
                    total_time += time_spent
                    total_score += score
                    total_max_score += max_score
                    
                    # Time analysis by type
                    task_type = task.task_type
                    if task_type not in time_by_type:
                        time_by_type[task_type] = {'total_time': 0, 'count': 0}
                    time_by_type[task_type]['total_time'] += time_spent
                    time_by_type[task_type]['count'] += 1
                    
                    # Score distribution
                    if max_score > 0:
                        score_percentage = (score / max_score) * 100
                        if score_percentage >= 90:
                            analytics['score_distribution']['excellent'] += 1
                        elif score_percentage >= 70:
                            analytics['score_distribution']['good'] += 1
                        elif score_percentage >= 50:
                            analytics['score_distribution']['fair'] += 1
                        else:
                            analytics['score_distribution']['needs_improvement'] += 1
                
            elif task.status == 'pending':
                analytics['overview']['pending_tasks'] += 1
            elif task.status == 'in_progress':
                analytics['overview']['in_progress_tasks'] += 1
            
            # Count task types
            task_type = task.task_type
            if task_type not in analytics['task_types']:
                analytics['task_types'][task_type] = {
                    'total': 0,
                    'completed': 0,
                    'pending': 0,
                    'avg_score': 0,
                    'avg_time': 0
                }
            
            analytics['task_types'][task_type]['total'] += 1
            if task.status == 'completed':
                analytics['task_types'][task_type]['completed'] += 1
            elif task.status == 'pending':
                analytics['task_types'][task_type]['pending'] += 1
            
            # Grade performance analysis
            grade = getattr(student, 'grade_level', 'Unknown')
            if grade not in analytics['grade_performance']:
                analytics['grade_performance'][grade] = {
                    'total_tasks': 0,
                    'completed_tasks': 0,
                    'avg_score': 0,
                    'student_count': 0
                }
            
            analytics['grade_performance'][grade]['total_tasks'] += 1
            if task.status == 'completed':
                analytics['grade_performance'][grade]['completed_tasks'] += 1
            
            # School performance analysis
            school = getattr(student, 'school_name', 'Unknown')
            if school not in analytics['school_performance']:
                analytics['school_performance'][school] = {
                    'total_tasks': 0,
                    'completed_tasks': 0,
                    'avg_score': 0,
                    'student_count': 0
                }
            
            analytics['school_performance'][school]['total_tasks'] += 1
            if task.status == 'completed':
                analytics['school_performance'][school]['completed_tasks'] += 1
        
        # Calculate averages
        if completed_count > 0:
            analytics['overview']['avg_time_spent'] = total_time / completed_count
            if total_max_score > 0:
                analytics['overview']['avg_score'] = (total_score / total_max_score) * 100
        
        # Calculate average time by task type
        for task_type, data in time_by_type.items():
            if data['count'] > 0:
                analytics['time_analysis']['avg_time_by_type'][task_type] = data['total_time'] / data['count']
        
        # Sort recent submissions by completion date
        submissions_for_sorting.sort(
            key=lambda x: x['completed_at'] or '0000-01-01T00:00:00', 
            reverse=True
        )
        analytics['recent_submissions'] = submissions_for_sorting[:20]  # Last 20 submissions
        
        # Generate top performers (students with highest avg scores)
        student_performances = {}
        for submission in submissions_for_sorting:
            student_name = submission['student_name']
            if student_name not in student_performances:
                student_performances[student_name] = {
                    'name': student_name,
                    'grade': submission['student_grade'],
                    'school': submission['school_name'],
                    'total_tasks': 0,
                    'completed_tasks': 0,
                    'total_score': 0,
                    'total_max_score': 0,
                    'avg_score': 0
                }
            
            perf = student_performances[student_name]
            perf['total_tasks'] += 1
            
            if submission['completion_data']:
                perf['completed_tasks'] += 1
                perf['total_score'] += submission['completion_data'].get('score', 0)
                perf['total_max_score'] += submission['completion_data'].get('max_score', 100)
        
        # Calculate avg scores for top performers
        for student_name, perf in student_performances.items():
            if perf['total_max_score'] > 0:
                perf['avg_score'] = (perf['total_score'] / perf['total_max_score']) * 100
        
        # Sort by avg score and take top 10
        top_performers = sorted(
            student_performances.values(), 
            key=lambda x: x['avg_score'], 
            reverse=True
        )[:10]
        
        analytics['top_performers'] = top_performers
        
        # Generate completion trends (last 7 days)
        from datetime import timedelta
        today = datetime.utcnow().date()
        trends = []
        
        for i in range(6, -1, -1):  # Last 7 days
            date = today - timedelta(days=i)
            date_start = datetime.combine(date, datetime.min.time())
            date_end = datetime.combine(date, datetime.max.time())
            
            day_completed = sum(1 for task in all_tasks 
                              if task.status == 'completed' and task.completed_at and 
                              date_start <= task.completed_at <= date_end)
            
            trends.append({
                'date': date.isoformat(),
                'completed_tasks': day_completed
            })
        
        analytics['completion_trends'] = trends
        
        # Calculate fastest and longest completions
        completed_with_time = [
            {
                'task_title': sub['task_title'],
                'student_name': sub['student_name'],
                'time_spent': sub['completion_data'].get('time_spent', 0)
            }
            for sub in submissions_for_sorting 
            if sub['completion_data'] and sub['completion_data'].get('time_spent', 0) > 0
        ]
        
        analytics['time_analysis']['fastest_completions'] = sorted(
            completed_with_time, 
            key=lambda x: x['time_spent']
        )[:5]
        
        analytics['time_analysis']['longest_completions'] = sorted(
            completed_with_time, 
            key=lambda x: x['time_spent'], 
            reverse=True
        )[:5]
        
        # Calculate grade and school averages
        student_grades = {}
        student_schools = {}
        
        for submission in submissions_for_sorting:
            if submission['completion_data']:
                grade = submission['student_grade']
                school = submission['school_name']
                score = submission['completion_data'].get('score', 0)
                max_score = submission['completion_data'].get('max_score', 100)
                
                if max_score > 0:
                    score_pct = (score / max_score) * 100
                    
                    # Grade averages
                    if grade not in student_grades:
                        student_grades[grade] = []
                    student_grades[grade].append(score_pct)
                    
                    # School averages
                    if school not in student_schools:
                        student_schools[school] = []
                    student_schools[school].append(score_pct)
        
        # Calculate final averages
        for grade, scores in student_grades.items():
            if grade in analytics['grade_performance'] and scores:
                analytics['grade_performance'][grade]['avg_score'] = sum(scores) / len(scores)
        
        for school, scores in student_schools.items():
            if school in analytics['school_performance'] and scores:
                analytics['school_performance'][school]['avg_score'] = sum(scores) / len(scores)
        
        return jsonify(analytics), 200
        
    except Exception as e:
        logger.error(f"Get admin comprehensive analytics error: {str(e)}")
        return jsonify({'error': 'Failed to fetch comprehensive analytics'}), 500

@app.route('/api/admin/analytics/summary', methods=['GET'])
@admin_required
def get_admin_analytics_summary():
    """Get quick analytics summary for admin dashboard"""
    try:
        # Quick counts
        total_students = Student.query.count()
        total_tasks = StudentTask.query.count()
        completed_tasks = StudentTask.query.filter_by(status='completed').count()
        pending_tasks = StudentTask.query.filter_by(status='pending').count()
        
        # Calculate completion rate
        completion_rate = 0
        if total_tasks > 0:
            completion_rate = (completed_tasks / total_tasks) * 100
        
        # Get total points and A-Card distributed
        total_points = db.session.query(db.func.sum(StudentTask.points_reward)).filter(
            StudentTask.status == 'completed'
        ).scalar() or 0
        
        total_acard = db.session.query(db.func.sum(StudentTask.acard_credit)).filter(
            StudentTask.status == 'completed'
        ).scalar() or 0
        
        # Get active students (students with tasks)
        active_students = len(set(task.student_id for task in StudentTask.query.all()))
        
        summary = {
            'total_students': total_students,
            'active_students': active_students,
            'total_tasks': total_tasks,
            'completed_tasks': completed_tasks,
            'pending_tasks': pending_tasks,
            'completion_rate': round(completion_rate, 1),
            'total_points_distributed': total_points,
            'total_acard_distributed': float(total_acard or 0)
        }
        
        return jsonify(summary), 200
        
    except Exception as e:
        logger.error(f"Get admin analytics summary error: {str(e)}")
        return jsonify({'error': 'Failed to fetch analytics summary'}), 500

@app.route('/api/admin/tasks', methods=['GET'])
@admin_required
def get_admin_tasks():
    """Get tasks with proper separation between super admin and grade admin tasks - WITH DEBUG"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 50, type=int)
        search = request.args.get('search', '')
        status_filter = request.args.get('status', '')
        task_type_filter = request.args.get('task_type', '')
        
        # DEBUG: Log the requesting admin
        logger.info(f"ðŸ” DEBUG: /api/admin/tasks called by Admin ID: {request.current_admin.id}, Role: {request.current_admin.role}, Name: {request.current_admin.name}")
        
        # Build base query with joins
        query = StudentTask.query.join(Student)
        
        # Count total tasks before filtering
        total_tasks_before_filter = query.count()
        logger.info(f"ðŸ” DEBUG: Total tasks in database before filtering: {total_tasks_before_filter}")
        
        # CRITICAL FILTERING LOGIC WITH DEBUG
        if request.current_admin.role == 'super_admin':
            # Super admin sees ALL tasks - no additional filters
            logger.info(f"ðŸ” DEBUG: Super admin detected - showing ALL tasks")
            # No additional filtering for super admin
        else:
            # Grade section admins ONLY see tasks they personally assigned
            logger.info(f"ðŸ” DEBUG: Grade admin detected - filtering by admin_id = {request.current_admin.id}")
            query = query.filter(StudentTask.admin_id == request.current_admin.id)
        
        # Count tasks after admin filtering
        total_tasks_after_admin_filter = query.count()
        logger.info(f"ðŸ” DEBUG: Total tasks after admin filtering: {total_tasks_after_admin_filter}")
        
        # Apply other filters
        if search:
            query = query.filter(
                db.or_(
                    StudentTask.task_title.ilike(f'%{search}%'),
                    StudentTask.task_description.ilike(f'%{search}%'),
                    Student.name.ilike(f'%{search}%')
                )
            )
            logger.info(f"ðŸ” DEBUG: Applied search filter: '{search}'")
        
        if status_filter:
            query = query.filter(StudentTask.status == status_filter)
            logger.info(f"ðŸ” DEBUG: Applied status filter: '{status_filter}'")
        
        if task_type_filter:
            query = query.filter(StudentTask.task_type == task_type_filter)
            logger.info(f"ðŸ” DEBUG: Applied task type filter: '{task_type_filter}'")
        
        # Count final tasks after all filters
        total_tasks_final = query.count()
        logger.info(f"ðŸ” DEBUG: Total tasks after all filters: {total_tasks_final}")
        
        query = query.order_by(StudentTask.assigned_at.desc())
        
        tasks_paginated = query.paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        # DEBUG: Log details about each task being returned
        logger.info(f"ðŸ” DEBUG: Returning {len(tasks_paginated.items)} tasks on page {page}")
        
        tasks_data = []
        for i, task in enumerate(tasks_paginated.items):
            task_data_dict = json.loads(task.task_data) if task.task_data else {}
            completion_data = task_data_dict.get('completion_data', {})
            
            # DEBUG: Log each task details
            logger.info(f"ðŸ” DEBUG: Task {i+1}: ID={task.id}, Title='{task.task_title}', Assigned_by_admin_id={task.admin_id}, Student='{task.student.name}'")
            
            # Check task flags
            assigned_by_super_admin = task_data_dict.get('assigned_by_super_admin', False)
            assigned_by_grade_admin = task_data_dict.get('assigned_by_grade_admin', False)
            assigned_by_admin_id = task_data_dict.get('assigned_by_admin_id')
            
            logger.info(f"ðŸ” DEBUG: Task {task.id} flags - super_admin: {assigned_by_super_admin}, grade_admin: {assigned_by_grade_admin}, assigned_by_admin_id: {assigned_by_admin_id}")
            
            # Get resource information if available
            resource_info = None
            resource_id = task_data_dict.get('resource_id')
            if resource_id:
                try:
                    resource = AdminResource.query.get(resource_id)
                    if resource:
                        resource_info = {
                            'id': resource.id,
                            'resource_title': resource.resource_title,
                            'resource_type': resource.resource_type,
                            'subject_category': resource.subject_category,
                            'resource_url': resource.resource_url,
                            'task_file': resource.task_file
                        }
                except Exception as e:
                    logger.error(f"ðŸ” DEBUG: Error getting resource {resource_id}: {str(e)}")
            
            # Get admin who assigned this task (for super admin view)
            assigned_by_admin = None
            if task.admin_id:
                try:
                    assigning_admin = Admin.query.get(task.admin_id)
                    if assigning_admin:
                        assigned_by_admin = {
                            'id': assigning_admin.id,
                            'name': assigning_admin.name,
                            'role': assigning_admin.role,
                            'grade_section': getattr(assigning_admin, 'grade_section', 'N/A')
                        }
                        logger.info(f"ðŸ” DEBUG: Task {task.id} assigned by: {assigning_admin.name} ({assigning_admin.role})")
                except Exception as e:
                    logger.error(f"ðŸ” DEBUG: Error getting assigning admin for task {task.id}: {str(e)}")
            
            task_info = {
                'id': task.id,
                'task_type': task.task_type,
                'task_title': task.task_title,
                'task_description': task.task_description,
                'status': task.status,
                'points_reward': task.points_reward,
                'acard_credit': float(task.acard_credit),
                'due_date': task.due_date.isoformat() if task.due_date else None,
                'assigned_at': task.assigned_at.isoformat(),
                'completed_at': task.completed_at.isoformat() if task.completed_at else None,
                'admin_id': task.admin_id,
                'assigned_by_admin': assigned_by_admin,
                'student': {
                    'id': task.student.id,
                    'name': task.student.name,
                    'grade_level': getattr(task.student, 'grade_level', 'N/A'),
                    'school_name': getattr(task.student, 'school_name', 'N/A')
                },
                'task_data': task_data_dict,
                'completion_data': completion_data,
                'external_url': task_data_dict.get('external_url'),
                'resource': resource_info,
                # DEBUG: Add debug info to response
                'debug_info': {
                    'assigned_by_super_admin': assigned_by_super_admin,
                    'assigned_by_grade_admin': assigned_by_grade_admin,
                    'assigned_by_admin_id': assigned_by_admin_id,
                    'current_admin_id': request.current_admin.id,
                    'should_be_visible': True  # Will be calculated
                }
            }
            
            # Calculate if this task should be visible to current admin
            if request.current_admin.role == 'super_admin':
                task_info['debug_info']['should_be_visible'] = True
                task_info['debug_info']['reason'] = 'Super admin sees all tasks'
            else:
                should_be_visible = task.admin_id == request.current_admin.id
                task_info['debug_info']['should_be_visible'] = should_be_visible
                task_info['debug_info']['reason'] = f"Grade admin - task.admin_id ({task.admin_id}) == current_admin.id ({request.current_admin.id}): {should_be_visible}"
            
            tasks_data.append(task_info)
        
        logger.info(f"ðŸ” DEBUG: Final response contains {len(tasks_data)} tasks for admin {request.current_admin.id} ({request.current_admin.role})")
        
        return jsonify({
            'tasks': tasks_data,
            'pagination': {
                'page': tasks_paginated.page,
                'pages': tasks_paginated.pages,
                'per_page': tasks_paginated.per_page,
                'total': tasks_paginated.total,
                'has_next': tasks_paginated.has_next,
                'has_prev': tasks_paginated.has_prev
            },
            'debug_info': {
                'admin_id': request.current_admin.id,
                'admin_role': request.current_admin.role,
                'admin_name': request.current_admin.name,
                'total_tasks_before_filter': total_tasks_before_filter,
                'total_tasks_after_admin_filter': total_tasks_after_admin_filter,
                'total_tasks_final': total_tasks_final,
                'returned_tasks_count': len(tasks_data),
                'filtering_logic': 'all_tasks' if request.current_admin.role == 'super_admin' else f'admin_id == {request.current_admin.id}',
                'search_filter': search,
                'status_filter': status_filter,
                'task_type_filter': task_type_filter
            }
        }), 200
        
    except Exception as e:
        logger.error(f"ðŸ” DEBUG: Get admin tasks error: {str(e)}")
        import traceback
        logger.error(f"ðŸ” DEBUG: Full traceback: {traceback.format_exc()}")
        return jsonify({'error': 'Failed to fetch tasks'}), 500

@app.route('/api/admin/my-tasks', methods=['GET'])
@admin_required
def get_my_assigned_tasks():
    """Get tasks assigned by the current admin (for grade section admins) - WITH DEBUG"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 50, type=int)
        search = request.args.get('search', '')
        status_filter = request.args.get('status', '')
        
        # DEBUG: Log the requesting admin
        logger.info(f"ðŸ” DEBUG: /api/admin/my-tasks called by Admin ID: {request.current_admin.id}, Role: {request.current_admin.role}, Name: {request.current_admin.name}")
        
        # IMPORTANT: This endpoint is specifically for grade admins to see only their tasks
        if request.current_admin.role == 'super_admin':
            logger.info(f"ðŸ” DEBUG: Super admin tried to access /my-tasks - BLOCKING")
            return jsonify({
                'error': 'Super admins should use /api/admin/tasks endpoint',
                'message': 'This endpoint is for grade section admins only'
            }), 400
        
        logger.info(f"ðŸ” DEBUG: Grade admin accessing /my-tasks - proceeding with admin_id filter")
        
        # Only get tasks assigned by this specific admin
        query = StudentTask.query.join(Student).filter(
            StudentTask.admin_id == request.current_admin.id
        )
        
        # Count total tasks for this admin
        total_admin_tasks = query.count()
        logger.info(f"ðŸ” DEBUG: Total tasks assigned by admin {request.current_admin.id}: {total_admin_tasks}")
        
        # Apply search filter
        if search:
            query = query.filter(
                db.or_(
                    StudentTask.task_title.ilike(f'%{search}%'),
                    StudentTask.task_description.ilike(f'%{search}%'),
                    Student.name.ilike(f'%{search}%')
                )
            )
            logger.info(f"ðŸ” DEBUG: Applied search filter: '{search}'")
        
        # Apply status filter
        if status_filter:
            query = query.filter(StudentTask.status == status_filter)
            logger.info(f"ðŸ” DEBUG: Applied status filter: '{status_filter}'")
        
        # Count after filters
        total_filtered_tasks = query.count()
        logger.info(f"ðŸ” DEBUG: Total tasks after filters: {total_filtered_tasks}")
        
        # Order by most recent first
        query = query.order_by(StudentTask.assigned_at.desc())
        
        # Paginate results
        tasks_paginated = query.paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        logger.info(f"ðŸ” DEBUG: Returning {len(tasks_paginated.items)} tasks on page {page}")
        
        tasks_data = []
        for i, task in enumerate(tasks_paginated.items):
            task_data_dict = json.loads(task.task_data) if task.task_data else {}
            
            # DEBUG: Log each task
            logger.info(f"ðŸ” DEBUG: My Task {i+1}: ID={task.id}, Title='{task.task_title}', admin_id={task.admin_id}, Student='{task.student.name}'")
            
            # Get resource information
            resource_info = None
            resource_id = task_data_dict.get('resource_id')
            if resource_id:
                try:
                    resource = AdminResource.query.get(resource_id)
                    if resource:
                        resource_info = {
                            'id': resource.id,
                            'resource_title': resource.resource_title,
                            'resource_type': resource.resource_type,
                            'subject_category': resource.subject_category,
                            'resource_url': resource.resource_url,
                            'task_file': resource.task_file,
                            'description': resource.description
                        }
                except:
                    pass
            
            task_info = {
                'id': task.id,
                'task_title': task.task_title,
                'task_description': task.task_description,
                'status': task.status,
                'points_reward': task.points_reward,
                'acard_credit': float(task.acard_credit),
                'due_date': task.due_date.isoformat() if task.due_date else None,
                'assigned_at': task.assigned_at.isoformat(),
                'completed_at': task.completed_at.isoformat() if task.completed_at else None,
                'student': {
                    'id': task.student.id,
                    'name': task.student.name,
                    'grade_level': getattr(task.student, 'grade_level', 'N/A'),
                    'school_name': getattr(task.student, 'school_name', 'N/A')
                },
                'resource': resource_info,
                'task_data': task_data_dict,
                'completion_data': task_data_dict.get('completion_data', {}),
                'debug_info': {
                    'admin_id': task.admin_id,
                    'current_admin_id': request.current_admin.id,
                    'matches': task.admin_id == request.current_admin.id
                }
            }
            
            tasks_data.append(task_info)
        
        logger.info(f"ðŸ” DEBUG: /my-tasks returning {len(tasks_data)} tasks for grade admin {request.current_admin.id}")
        
        return jsonify({
            'tasks': tasks_data,
            'pagination': {
                'page': tasks_paginated.page,
                'pages': tasks_paginated.pages,
                'per_page': tasks_paginated.per_page,
                'total': tasks_paginated.total,
                'has_next': tasks_paginated.has_next,
                'has_prev': tasks_paginated.has_prev
            },
            'debug_info': {
                'admin_id': request.current_admin.id,
                'admin_role': request.current_admin.role,
                'total_admin_tasks': total_admin_tasks,
                'total_filtered_tasks': total_filtered_tasks,
                'returned_tasks_count': len(tasks_data)
            }
        }), 200
        
    except Exception as e:
        logger.error(f"ðŸ” DEBUG: Get my tasks error: {str(e)}")
        import traceback
        logger.error(f"ðŸ” DEBUG: Full traceback: {traceback.format_exc()}")
        return jsonify({'error': 'Failed to fetch tasks'}), 500


@app.route('/api/super-admin/assign-resource-task', methods=['POST'])
@admin_required
def assign_resource_task():
    """Assign tasks using assigned resources - for grade section admins only"""
    try:
        # Ensure this is not a super admin using this endpoint
        if request.current_admin.role == 'super_admin':
            return jsonify({'error': 'Super admins should use the main task assignment endpoint'}), 403
        
        data = request.get_json()
        required_fields = ['student_ids', 'resource_id', 'task_title', 'task_description']
        
        if not all(field in data for field in required_fields):
            return jsonify({'error': 'Missing required fields'}), 400
        
        student_ids = data['student_ids']
        resource_id = data['resource_id']
        
        if not isinstance(student_ids, list) or not student_ids:
            return jsonify({'error': 'student_ids must be a non-empty list'}), 400
        
        # Verify the resource belongs to this admin
        resource = AdminResource.query.filter_by(
            id=resource_id,
            admin_id=request.current_admin.id  # Fixed: was assigned_admin_id
        ).first()
        
        if not resource:
            return jsonify({'error': 'Resource not found or not assigned to you'}), 404
        
        # Verify all students are assigned to this admin using AdminAssignment
        assignment = AdminAssignment.query.filter_by(
            admin_id=request.current_admin.id,
            assignment_type='grade_section'
        ).first()
        
        if not assignment or not assignment.student_ids:
            return jsonify({'error': 'No students assigned to you'}), 403
        
        assigned_student_ids = set(assignment.student_ids)
        
        for student_id in student_ids:
            if student_id not in assigned_student_ids:
                return jsonify({'error': f'Student {student_id} is not assigned to you'}), 403
        
        # Check A-Card credit limit
        acard_credit = float(data.get('acard_credit', 0))
        max_acard_per_task = request.current_admin.max_acard_amount or assignment.max_acard_amount or 0
        
        if acard_credit > max_acard_per_task:
            return jsonify({'error': f'A-Card credit cannot exceed {max_acard_per_task} per task'}), 400
        
        # Parse due date
        due_date = None
        if data.get('due_date'):
            try:
                due_date_str = data['due_date']
                if 'T' in due_date_str and 'Z' not in due_date_str and '+' not in due_date_str:
                    due_date = datetime.fromisoformat(due_date_str)
                else:
                    due_date = datetime.fromisoformat(due_date_str.replace('Z', '+00:00'))
                
                if due_date.hour == 0 and due_date.minute == 0:
                    due_date = due_date.replace(hour=23, minute=59, second=59)
                    
            except ValueError as e:
                return jsonify({'error': f'Invalid due date format: {str(e)}'}), 400
        
        # Prepare task data with resource information
        task_data = {
            'resource_id': resource.id,
            'resource_type': resource.resource_type,
            'resource_title': resource.resource_title,
            'subject_category': resource.subject_category,
            'assigned_by_grade_admin': True,  # Flag to identify tasks assigned by grade admins
            'assigned_by_admin_id': request.current_admin.id  # Track which admin assigned it
        }
        
        # Set up link configuration based on resource type
        if resource.resource_type == 'internal_file' and resource.task_file:
            external_url = f'https://deciph.ai.deciphersacad.online/{resource.task_file}'
            task_data.update({
                'task_file': resource.task_file,
                'external_url': external_url,
                'link_type': 'internal',
                'is_external': True
            })
        elif resource.resource_url:
            task_data.update({
                'external_url': resource.resource_url,
                'link_type': 'external',
                'is_external': True
            })
        
        # Determine appropriate task type for database
        task_type_mapping = {
            'mathematics': 'math',
            'basic_science': 'science',
            'social_studies': 'history',
            'humanities': 'history',
            'physics': 'science',
            'chemistry': 'science',
            'biology': 'science',
            'economics': 'history'
        }
        
        db_task_type = task_type_mapping.get(resource.subject_category, resource.subject_category)
        
        assigned_tasks = []
        
        # Create tasks for each student
        for student_id in student_ids:
            student = Student.query.get(student_id)
            if not student:
                logger.warning(f"Student with ID {student_id} not found, skipping")
                continue
            
            try:
                task = StudentTask(
                    student_id=student_id,
                    admin_id=request.current_admin.id,  # This ensures proper ownership
                    task_type=db_task_type,
                    task_title=data['task_title'],
                    task_description=data['task_description'],
                    task_data=json.dumps(task_data),
                    points_reward=data.get('points_reward', 0),
                    acard_credit=acard_credit,
                    due_date=due_date,
                    status='pending'
                )
                
                db.session.add(task)
                db.session.flush()
                
                logger.info(f"Grade admin {request.current_admin.id} created task {task.id} for student {student_id}")
                
                assigned_tasks.append({
                    'student_id': student_id,
                    'student_name': student.name,
                    'task_id': task.id,
                    'resource_used': resource.resource_title,
                    'external_url': task_data.get('external_url'),
                    'due_date': due_date.isoformat() if due_date else None
                })
                
            except Exception as task_error:
                logger.error(f"Error creating resource task for student {student_id}: {str(task_error)}")
                continue
        
        db.session.commit()
        logger.info(f"Grade admin {request.current_admin.id} successfully assigned {len(assigned_tasks)} resource-based tasks")
        
        return jsonify({
            'message': f'Task assigned to {len(assigned_tasks)} students using resource: {resource.resource_title}',
            'assigned_tasks': assigned_tasks,
            'resource_used': {
                'id': resource.id,
                'title': resource.resource_title,
                'type': resource.resource_type,
                'category': resource.subject_category
            },
            'success': True
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Resource task assignment error: {str(e)}")
        return jsonify({
            'error': f'Failed to assign task: {str(e)}',
            'success': False
        }), 500

@app.route('/api/admin/bulk-assign-tasks', methods=['POST'])
@admin_required
def bulk_assign_tasks():
    """
    Bulk task assignment endpoint - assign multiple tasks to multiple students
    """
    try:
        data = request.get_json()
        
        # Validate input structure
        if 'tasks' not in data or 'student_ids' not in data:
            return jsonify({'error': 'Missing required fields: tasks and student_ids'}), 400
        
        tasks_data = data['tasks']
        student_ids = data['student_ids']
        
        # Validate tasks data
        if not isinstance(tasks_data, list) or not tasks_data:
            return jsonify({'error': 'tasks must be a non-empty list'}), 400
        
        # Validate student IDs
        if not isinstance(student_ids, list) or not student_ids:
            return jsonify({'error': 'student_ids must be a non-empty list'}), 400
        
        # Database constraint mapping
        task_type_mapping = {
            'mathematics': 'math',
            'basic_science': 'science',
            'social_studies': 'history',
            'humanities': 'history',
            'physics': 'science',
            'chemistry': 'science',
            'biology': 'science',
            'economics': 'history',
            'coding': 'coding',
            'graphics': 'graphics',
            'video-editing': 'video-editing',
            'graphics-design': 'graphics-design',
            'social-media': 'social-media'
        }
        
        # Validate each task
        for i, task_data in enumerate(tasks_data):
            required_task_fields = ['task_type', 'task_title', 'task_description']
            missing_fields = [field for field in required_task_fields if not task_data.get(field)]
            if missing_fields:
                return jsonify({
                    'error': f'Task {i+1} missing required fields: {", ".join(missing_fields)}'
                }), 400
        
        # Verify all students exist and admin has access to them
        students = Student.query.filter(Student.id.in_(student_ids)).all()
        found_student_ids = {s.id for s in students}
        missing_students = set(student_ids) - found_student_ids
        
        if missing_students:
            return jsonify({
                'error': f'Students not found: {list(missing_students)}'
            }), 400
        
        # For grade admins, verify they have access to these students
        if request.current_admin.role != 'super_admin':
            admin_assignment = AdminAssignment.query.filter_by(
                admin_id=request.current_admin.id
            ).first()
            
            if not admin_assignment:
                return jsonify({'error': 'No grade section assignment found'}), 403
            
            # Check if students belong to admin's grade section
            invalid_students = []
            for student in students:
                if student.grade_level not in admin_assignment.grade_section:
                    invalid_students.append(f"{student.name} (Grade {student.grade_level})")
            
            if invalid_students:
                return jsonify({
                    'error': f'You do not have permission to assign tasks to: {", ".join(invalid_students)}'
                }), 403
        
        successful_assignments = []
        failed_assignments = []
        
        # Process each task for each student
        for student in students:
            for task_index, task_data in enumerate(tasks_data):
                try:
                    # Map frontend task type to database constraint
                    frontend_task_type = task_data['task_type']
                    db_task_type = task_type_mapping.get(frontend_task_type, frontend_task_type)
                    
                    # Parse due date
                    due_date = None
                    if task_data.get('due_date'):
                        try:
                            due_date_str = task_data['due_date']
                            if 'T' in due_date_str and 'Z' not in due_date_str and '+' not in due_date_str:
                                due_date = datetime.fromisoformat(due_date_str)
                            else:
                                due_date = datetime.fromisoformat(due_date_str.replace('Z', '+00:00'))
                            
                            if due_date.hour == 0 and due_date.minute == 0:
                                due_date = due_date.replace(hour=23, minute=59, second=59)
                        except ValueError as e:
                            logger.error(f"Date parsing error for task {task_index+1}: {str(e)}")
                            failed_assignments.append({
                                'student_id': student.id,
                                'student_name': student.name,
                                'task_index': task_index + 1,
                                'error': f'Invalid due date format: {str(e)}'
                            })
                            continue
                    
                    # Prepare enhanced task data
                    enhanced_task_data = task_data.get('task_data', {})
                    
                    # Flag based on admin role
                    if request.current_admin.role == 'super_admin':
                        enhanced_task_data['assigned_by_super_admin'] = True
                    else:
                        enhanced_task_data['assigned_by_grade_admin'] = True
                    
                    enhanced_task_data['assigned_by_admin_id'] = request.current_admin.id
                    enhanced_task_data['bulk_assignment'] = True
                    enhanced_task_data['bulk_assignment_batch'] = datetime.now().isoformat()
                    
                    # Store original task type for reference
                    enhanced_task_data['original_task_type'] = frontend_task_type
                    
                    # Create the task
                    task = StudentTask(
                        student_id=student.id,
                        admin_id=request.current_admin.id,
                        task_type=db_task_type,
                        task_title=task_data['task_title'],
                        task_description=task_data['task_description'],
                        task_data=json.dumps(enhanced_task_data),
                        points_reward=task_data.get('points_reward', 0),
                        acard_credit=task_data.get('acard_credit', 0.0),
                        due_date=due_date,
                        status='pending'
                    )
                    
                    db.session.add(task)
                    db.session.flush()  # Get the task ID
                    
                    successful_assignments.append({
                        'student_id': student.id,
                        'student_name': student.name,
                        'task_id': task.id,
                        'task_title': task_data['task_title'],
                        'task_index': task_index + 1,
                        'task_type_used': db_task_type,
                        'original_task_type': frontend_task_type,
                        'points_reward': task_data.get('points_reward', 0),
                        'acard_credit': task_data.get('acard_credit', 0.0),
                        'due_date': due_date.isoformat() if due_date else None
                    })
                    
                    logger.info(f"Bulk assignment: Admin {request.current_admin.id} created task {task.id} "
                              f"'{task_data['task_title']}' for student {student.id} ({student.name})")
                
                except Exception as task_error:
                    logger.error(f"Error creating task {task_index+1} for student {student.id}: {str(task_error)}")
                    failed_assignments.append({
                        'student_id': student.id,
                        'student_name': student.name,
                        'task_index': task_index + 1,
                        'task_title': task_data.get('task_title', 'Unknown'),
                        'error': str(task_error)
                    })
                    continue
        
        # Commit all successful assignments
        db.session.commit()
        
        # Prepare response
        response_data = {
            'message': f'Bulk assignment completed',
            'total_assignments': len(successful_assignments),
            'successful_assignments': len(successful_assignments),
            'failed_assignments': len(failed_assignments),
            'tasks_count': len(tasks_data),
            'students_count': len(students),
            'assigned_by': request.current_admin.role,
            'assignments': successful_assignments,
            'success': True
        }
        
        if failed_assignments:
            response_data['failures'] = failed_assignments
            response_data['warning'] = f'{len(failed_assignments)} assignments failed'
        
        logger.info(f"Bulk assignment completed by {request.current_admin.role} "
                   f"({request.current_admin.id}): {len(successful_assignments)} successful, "
                   f"{len(failed_assignments)} failed")
        
        status_code = 201 if len(failed_assignments) == 0 else 207  # 207 = Multi-Status
        return jsonify(response_data), status_code
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Bulk task assignment error: {str(e)}")
        return jsonify({
            'error': f'Failed to process bulk assignment: {str(e)}',
            'success': False
        }), 500

@app.route('/api/admin/assign-task', methods=['POST'])
@admin_required
def assign_task():
    """Enhanced task assignment with proper link type handling and MySQL compatibility"""
    try:
        data = request.get_json()
        required_fields = ['student_ids', 'task_type', 'task_title', 'task_description']
        
        if not all(field in data for field in required_fields):
            return jsonify({'error': 'Missing required fields'}), 400
        
        student_ids = data['student_ids']
        if not isinstance(student_ids, list) or not student_ids:
            return jsonify({'error': 'student_ids must be a non-empty list'}), 400
        
        # Database constraint mapping
        task_type_mapping = {
            'mathematics': 'math',
            'basic_science': 'science',
            'social_studies': 'history',
            'humanities': 'history',
            'physics': 'science',
            'chemistry': 'science',
            'biology': 'science',
            'economics': 'history',
            'coding': 'coding',
            'graphics': 'graphics',
            'video-editing': 'video-editing',
            'graphics-design': 'graphics-design',
            'social-media': 'social-media'
        }
        
        frontend_task_type = data['task_type']
        db_task_type = task_type_mapping.get(frontend_task_type, frontend_task_type)
        
        # Parse due date with proper timezone handling
        due_date = None
        if data.get('due_date'):
            try:
                # Handle both ISO format and datetime-local format
                due_date_str = data['due_date']
                if 'T' in due_date_str and 'Z' not in due_date_str and '+' not in due_date_str:
                    # datetime-local format, assume local timezone
                    due_date = datetime.fromisoformat(due_date_str)
                else:
                    # ISO format
                    due_date = datetime.fromisoformat(due_date_str.replace('Z', '+00:00'))
                
                # Ensure time is set to end of day if not specified
                if due_date.hour == 0 and due_date.minute == 0:
                    due_date = due_date.replace(hour=23, minute=59, second=59)
                    
                logger.info(f"Parsed due date: {due_date.isoformat()} from input: {due_date_str}")
                    
            except ValueError as e:
                logger.error(f"Date parsing error: {str(e)} for input: {data.get('due_date')}")
                return jsonify({'error': f'Invalid due date format: {str(e)}'}), 400
        
        # Prepare task data with enhanced link handling
        task_data = data.get('task_data', {})
        
        # FIXED: Properly flag tasks based on admin role
        if request.current_admin.role == 'super_admin':
            task_data['assigned_by_super_admin'] = True
            task_data['assigned_by_admin_id'] = request.current_admin.id
        else:
            task_data['assigned_by_grade_admin'] = True
            task_data['assigned_by_admin_id'] = request.current_admin.id
        
        # Handle different link types from frontend
        link_config = task_data.get('link_config') or {}
        link_type = link_config.get('type')
        
        # Process link configuration
        external_url = None
        is_external = False
        
        logger.info(f"Processing link config: {link_config}")
        
        if link_type == 'internal':
            # Internal Deciph.AI task file
            task_file = link_config.get('task_file', '').strip()
            if task_file:
                external_url = f'https://deciph.ai.deciphersacad.online/{task_file}'
                task_data['task_file'] = task_file
                is_external = True
                logger.info(f"Internal task: {task_file} -> {external_url}")
                
        elif link_type == 'external':
            # External URL
            external_url = link_config.get('external_url', '').strip()
            if external_url:
                is_external = True
                logger.info(f"External URL: {external_url}")
                
        elif link_type == 'common':
            # Common link or custom URL
            external_url = link_config.get('external_url', '').strip()
            if external_url:
                is_external = True
                logger.info(f"Common/Custom URL: {external_url}")
        
        # Store link information
        if external_url:
            task_data['external_url'] = external_url
            task_data['link_type'] = link_type
            task_data['is_external'] = is_external

        # Handle class link (Zoom) configuration - optional
        class_link = task_data.get('class_link')
        if class_link and class_link.get('url'):
            task_data['class_link'] = {
                'url': class_link['url'],
                'start_time': class_link.get('start_time')
            }
            # If only class link is provided (no task link), still mark as external
            if not external_url:
                is_external = True
                task_data['is_external'] = True
            task_data['has_class_link'] = True
            logger.info(f"Class link configured: {class_link['url']} at {class_link.get('start_time')}")
        else:
            task_data['has_class_link'] = False

        # Store original task type for reference
        task_data['original_task_type'] = frontend_task_type

        logger.info(f"Final task data: {task_data}")

        assigned_tasks = []

        # Create tasks for each student
        for student_id in student_ids:
            student = Student.query.get(student_id)
            if not student:
                logger.warning(f"Student with ID {student_id} not found, skipping")
                continue

            try:
                task = StudentTask(
                    student_id=student_id,
                    admin_id=request.current_admin.id,  # This ensures proper ownership tracking
                    task_type=db_task_type,
                    task_title=data['task_title'],
                    task_description=data['task_description'],
                    task_data=json.dumps(task_data),
                    points_reward=data.get('points_reward', 0),
                    acard_credit=data.get('acard_credit', 0.0),
                    due_date=due_date,
                    status='pending'
                )
                
                db.session.add(task)
                db.session.flush()
                
                logger.info(f"Admin {request.current_admin.id} ({request.current_admin.role}) created task {task.id} for student {student_id}")
                
                assigned_tasks.append({
                    'student_id': student_id,
                    'student_name': student.name,
                    'task_id': task.id,
                    'task_type_used': db_task_type,
                    'original_task_type': frontend_task_type,
                    'external_url': external_url,
                    'due_date': due_date.isoformat() if due_date else None,
                    'link_type': link_type,
                    'assigned_by': request.current_admin.role
                })
                
            except Exception as task_error:
                logger.error(f"Error creating task for student {student_id}: {str(task_error)}")
                continue
        
        db.session.commit()
        logger.info(f"Successfully assigned {len(assigned_tasks)} tasks by {request.current_admin.role}")
        
        return jsonify({
            'message': f'Task assigned to {len(assigned_tasks)} students',
            'assigned_tasks': assigned_tasks,
            'task_type_mapping': f"{frontend_task_type} -> {db_task_type}",
            'assigned_by': request.current_admin.role,
            'success': True
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Task assignment error: {str(e)}")
        return jsonify({
            'error': f'Failed to assign task: {str(e)}',
            'success': False
        }), 500

@app.route('/api/student/withdrawal/request', methods=['POST'])
def submit_withdrawal_request():
    """Submit a new withdrawal request (cash or gift)"""
    try:
        # Get student from token
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401
            
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
            
        student = Student.query.get(student_id)
        if not student:
            return jsonify({'error': 'Student not found'}), 404
        
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        # Validate required fields
        required_fields = ['type', 'amount']
        for field in required_fields:
            if field not in data:
                return jsonify({'error': f'Missing required field: {field}'}), 400
        
        request_type = data['type']
        amount = float(data['amount'])
        
        # Check if student has sufficient balance
        current_balance = float(student.acard_balance or 0)
        if amount > current_balance:
            return jsonify({'error': 'Insufficient balance'}), 400
        
        # Validate amount limits
        if amount < 1.0:
            return jsonify({'error': 'Minimum withdrawal amount is â‚³1.00'}), 400
        if amount > 1000.0:
            return jsonify({'error': 'Maximum withdrawal amount is â‚³1000.00'}), 400
        
        # Create withdrawal request
        withdrawal = WithdrawalRequest(
            student_id=student_id,
            request_type=request_type,
            amount=amount,
            status='pending'
        )
        
        # Add type-specific data
        if request_type == 'cash':
            withdrawal.user_location = data.get('location')
            withdrawal.bank_details = data.get('bankDetails', {})
            
            # Validate location-specific required fields
            if not withdrawal.user_location:
                return jsonify({'error': 'Location is required for cash withdrawals'}), 400
            
            if not withdrawal.bank_details:
                return jsonify({'error': 'Bank details are required for cash withdrawals'}), 400
                
        elif request_type == 'gift':
            withdrawal.gift_name = data.get('gift_name')
            withdrawal.delivery_address = data.get('delivery_address')
            withdrawal.phone_number = data.get('phone_number')
            withdrawal.special_instructions = data.get('special_instructions', '')
            
            # Validate gift-specific required fields
            required_gift_fields = ['gift_name', 'delivery_address', 'phone_number']
            for field in required_gift_fields:
                if not data.get(field):
                    return jsonify({'error': f'Missing required field for gift: {field}'}), 400
        else:
            return jsonify({'error': 'Invalid request type. Must be "cash" or "gift"'}), 400
        
        # Save withdrawal request
        db.session.add(withdrawal)
        
        # Deduct amount from student balance (hold it)
        student.acard_balance = current_balance - amount
        
        # Create transaction record for the hold
        hold_transaction = ACardTransaction(
            student_id=student_id,
            transaction_type='withdrawal_hold',
            amount=-amount,
            description=f'Hold for {request_type} withdrawal request',
            balance_after=student.acard_balance
        )
        db.session.add(hold_transaction)
        
        db.session.commit()
        
        # Notify admins (you can implement email/push notifications here)
        notify_admins_of_withdrawal_request(withdrawal)
        
        return jsonify({
            'message': f'{request_type.title()} withdrawal request submitted successfully',
            'request_id': withdrawal.id,
            'status': 'pending',
            'new_balance': float(student.acard_balance)
        }), 201
        
    except ValueError as ve:
        return jsonify({'error': f'Invalid amount: {str(ve)}'}), 400
    except Exception as e:
        db.session.rollback()
        logger.error(f"Withdrawal request error: {str(e)}")
        return jsonify({'error': 'Failed to submit withdrawal request'}), 500

@app.route('/api/student/withdrawal/status', methods=['GET'])
def get_withdrawal_status():
    """Get student's withdrawal request status"""
    try:
        # Get student from token
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401
            
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
        
        # Get recent withdrawal requests
        withdrawals = WithdrawalRequest.query.filter_by(
            student_id=student_id
        ).order_by(WithdrawalRequest.created_at.desc()).limit(10).all()
        
        withdrawal_data = []
        for withdrawal in withdrawals:
            withdrawal_data.append({
                'id': withdrawal.id,
                'type': withdrawal.request_type,
                'amount': float(withdrawal.amount),
                'status': withdrawal.status,
                'gift_name': withdrawal.gift_name,
                'created_at': withdrawal.created_at.isoformat(),
                'approved_at': withdrawal.approved_at.isoformat() if withdrawal.approved_at else None,
                'admin_notes': withdrawal.admin_notes
            })
        
        return jsonify({
            'withdrawals': withdrawal_data
        }), 200
        
    except Exception as e:
        logger.error(f"Get withdrawal status error: {str(e)}")
        return jsonify({'error': 'Failed to fetch withdrawal status'}), 500

# Admin endpoints for managing withdrawals

@app.route('/api/admin/withdrawals', methods=['GET'])
@admin_required
def get_withdrawal_requests():
    """Get all withdrawal requests for admin review"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        status_filter = request.args.get('status', '')
        request_type = request.args.get('type', '')
        
        # Build query
        query = WithdrawalRequest.query.join(Student)
        
        # Apply filters
        if status_filter:
            query = query.filter(WithdrawalRequest.status == status_filter)
        
        if request_type:
            query = query.filter(WithdrawalRequest.request_type == request_type)
        
        # Order by most recent pending first, then by creation date
        query = query.order_by(
            db.case(
                (WithdrawalRequest.status == 'pending', 0),
                else_=1
            ),
            WithdrawalRequest.created_at.desc()
        )
        
        # Paginate
        withdrawals_paginated = query.paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        withdrawal_data = []
        for withdrawal in withdrawals_paginated.items:
            withdrawal_info = {
                'id': withdrawal.id,
                'student': {
                    'id': withdrawal.student.id,
                    'name': withdrawal.student.name,
                    'email': withdrawal.student.email,
                    'grade_level': withdrawal.student.grade_level,
                    'school_name': withdrawal.student.school_name
                },
                'type': withdrawal.request_type,
                'amount': float(withdrawal.amount),
                'status': withdrawal.status,
                'created_at': withdrawal.created_at.isoformat(),
                'approved_at': withdrawal.approved_at.isoformat() if withdrawal.approved_at else None,
                'admin_notes': withdrawal.admin_notes
            }
            
            # Add type-specific data
            if withdrawal.request_type == 'cash':
                withdrawal_info['location'] = withdrawal.user_location
                withdrawal_info['bank_details'] = withdrawal.bank_details
            elif withdrawal.request_type == 'gift':
                withdrawal_info['gift_name'] = withdrawal.gift_name
                withdrawal_info['delivery_address'] = withdrawal.delivery_address
                withdrawal_info['phone_number'] = withdrawal.phone_number
                withdrawal_info['special_instructions'] = withdrawal.special_instructions
            
            withdrawal_data.append(withdrawal_info)
        
        return jsonify({
            'withdrawals': withdrawal_data,
            'pagination': {
                'page': withdrawals_paginated.page,
                'pages': withdrawals_paginated.pages,
                'per_page': withdrawals_paginated.per_page,
                'total': withdrawals_paginated.total,
                'has_next': withdrawals_paginated.has_next,
                'has_prev': withdrawals_paginated.has_prev
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Get withdrawal requests error: {str(e)}")
        return jsonify({'error': 'Failed to fetch withdrawal requests'}), 500

@app.route('/api/admin/withdrawal/<int:withdrawal_id>/approve', methods=['POST'])
@admin_required
def approve_withdrawal(withdrawal_id):
    """Approve a withdrawal request (Super admin only)"""
    try:
        # Check if current admin is super admin
        if not hasattr(request, 'current_admin') or request.current_admin.role != 'super_admin':
            return jsonify({'error': 'Only super admin can approve withdrawals'}), 403
        
        withdrawal = WithdrawalRequest.query.get(withdrawal_id)
        if not withdrawal:
            return jsonify({'error': 'Withdrawal request not found'}), 404
        
        if withdrawal.status != 'pending':
            return jsonify({'error': 'Only pending withdrawals can be approved'}), 400
        
        data = request.get_json() or {}
        admin_notes = data.get('admin_notes', '')
        
        # Update withdrawal status
        withdrawal.status = 'approved'
        withdrawal.admin_id = request.current_admin.id
        withdrawal.approved_at = datetime.utcnow()
        withdrawal.admin_notes = admin_notes
        
        # Log the approval
        logger.info(f"Withdrawal {withdrawal_id} approved by admin {request.current_admin.id}")
        logger.info(f"Student {withdrawal.student_id} - Amount: ${withdrawal.amount}")
        
        db.session.commit()
        
        # Send notification to student
        notify_student_withdrawal_approved(withdrawal)
        
        return jsonify({
            'message': 'Withdrawal request approved successfully',
            'withdrawal_id': withdrawal.id,
            'status': 'approved',
            'amount': float(withdrawal.amount)
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Approve withdrawal error: {str(e)}")
        return jsonify({'error': 'Failed to approve withdrawal request'}), 500

@app.route('/api/admin/withdrawal/<int:withdrawal_id>/reject', methods=['POST'])
@admin_required
def reject_withdrawal(withdrawal_id):
    """Reject a withdrawal request and refund balance"""
    try:
        # Check if current admin is super admin
        if not hasattr(request, 'current_admin') or request.current_admin.role != 'super_admin':
            return jsonify({'error': 'Only super admin can reject withdrawals'}), 403
        
        withdrawal = WithdrawalRequest.query.get(withdrawal_id)
        if not withdrawal:
            return jsonify({'error': 'Withdrawal request not found'}), 404
        
        if withdrawal.status != 'pending':
            return jsonify({'error': 'Only pending withdrawals can be rejected'}), 400
        
        data = request.get_json() or {}
        admin_notes = data.get('admin_notes', 'Withdrawal request rejected')
        
        # Update withdrawal status
        withdrawal.status = 'rejected'
        withdrawal.admin_id = request.current_admin.id
        withdrawal.approved_at = datetime.utcnow()
        withdrawal.admin_notes = admin_notes
        
        # Refund the amount back to student balance
        student = withdrawal.student
        current_balance = float(student.acard_balance or 0)
        refund_amount = float(withdrawal.amount)
        student.acard_balance = current_balance + refund_amount
        
        # Create refund transaction
        refund_transaction = ACardTransaction(
            student_id=withdrawal.student_id,
            admin_id=request.current_admin.id,
            transaction_type='manual_credit',
            amount=refund_amount,
            description=f'Refund for rejected {withdrawal.request_type} withdrawal',
            balance_after=student.acard_balance
        )
        db.session.add(refund_transaction)
        
        db.session.commit()
        
        # Send notification to student
        notify_student_withdrawal_rejected(withdrawal)
        
        return jsonify({
            'message': 'Withdrawal request rejected and amount refunded',
            'withdrawal_id': withdrawal.id,
            'status': 'rejected',
            'refunded_amount': refund_amount
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Reject withdrawal error: {str(e)}")
        return jsonify({'error': 'Failed to reject withdrawal request'}), 500

@app.route('/api/admin/withdrawal/stats', methods=['GET'])
@admin_required
def get_withdrawal_stats():
    """Get withdrawal statistics for admin dashboard"""
    try:
        # Get counts by status
        pending_count = WithdrawalRequest.query.filter_by(status='pending').count()
        approved_count = WithdrawalRequest.query.filter_by(status='approved').count()
        rejected_count = WithdrawalRequest.query.filter_by(status='rejected').count()
        
        # Get total amounts
        total_pending = db.session.query(db.func.sum(WithdrawalRequest.amount)).filter_by(status='pending').scalar() or 0
        total_approved = db.session.query(db.func.sum(WithdrawalRequest.amount)).filter_by(status='approved').scalar() or 0
        
        # Get recent requests (last 30 days)
        thirty_days_ago = datetime.utcnow() - timedelta(days=30)
        recent_requests = WithdrawalRequest.query.filter(
            WithdrawalRequest.created_at >= thirty_days_ago
        ).count()
        
        return jsonify({
            'pending_count': pending_count,
            'approved_count': approved_count,
            'rejected_count': rejected_count,
            'total_pending_amount': float(total_pending),
            'total_approved_amount': float(total_approved),
            'recent_requests_30d': recent_requests
        }), 200
        
    except Exception as e:
        logger.error(f"Get withdrawal stats error: {str(e)}")
        return jsonify({'error': 'Failed to fetch withdrawal statistics'}), 500

# Notification functions (implement based on your notification system)

def notify_admins_of_withdrawal_request(withdrawal):
    """Notify admins about new withdrawal request"""
    try:
        # Get all super admins
        super_admins = Admin.query.filter_by(role='super_admin', is_active=True).all()
        
        # Send notifications (email, push, etc.)
        for admin in super_admins:
            # Implement your notification logic here
            # Example: send_email, send_push_notification, etc.
            logger.info(f"Withdrawal request {withdrawal.id} notification sent to admin {admin.id}")
            
    except Exception as e:
        logger.error(f"Failed to notify admins: {str(e)}")

def notify_student_withdrawal_approved(withdrawal):
    """Notify student that withdrawal was approved"""
    try:
        # Implement notification to student
        # Example: email, in-app notification, etc.
        logger.info(f"Approval notification sent to student {withdrawal.student_id} for withdrawal {withdrawal.id}")
        
    except Exception as e:
        logger.error(f"Failed to notify student of approval: {str(e)}")

def notify_student_withdrawal_rejected(withdrawal):
    """Notify student that withdrawal was rejected"""
    try:
        # Implement notification to student
        # Example: email, in-app notification, etc.
        logger.info(f"Rejection notification sent to student {withdrawal.student_id} for withdrawal {withdrawal.id}")
        
    except Exception as e:
        logger.error(f"Failed to notify student of rejection: {str(e)}")

# Add this to your database initialization
def create_withdrawal_tables():
    """Verify withdrawal-related tables exist (does not create tables)"""
    try:
        with current_app.app_context():
            from sqlalchemy import text
            # Verify database connectivity
            db.session.execute(text("SELECT 1")).fetchone()
            logger.info("âœ… Withdrawal tables verification complete - use migrations to create tables")
    except Exception as e:
        logger.error(f"âŒ Failed to verify withdrawal tables: {str(e)}")

# Add withdrawal management to admin dashboard stats
@app.route('/api/admin/dashboard/stats', methods=['GET'])
@admin_required
def get_admin_dashboard_stats():
    """Enhanced dashboard stats including withdrawal data"""
    try:
        # Existing stats
        total_students = Student.query.count()
        active_students = Student.query.filter_by(is_active=True).count()
        total_tasks = StudentTask.query.count()
        pending_tasks = StudentTask.query.filter_by(status='pending').count()
        completed_tasks = StudentTask.query.filter_by(status='completed').count()
        
        # A-Card stats
        total_acard_value = db.session.query(db.func.sum(Student.acard_balance)).scalar() or 0
        
        # Withdrawal stats
        pending_withdrawals = WithdrawalRequest.query.filter_by(status='pending').count()
        total_withdrawal_amount = db.session.query(db.func.sum(WithdrawalRequest.amount)).filter_by(status='pending').scalar() or 0
        
        return jsonify({
            'stats': {
                'total_students': total_students,
                'active_students': active_students,
                'total_tasks': total_tasks,
                'pending_tasks': pending_tasks,
                'completed_tasks': completed_tasks,
                'total_acard_value': float(total_acard_value),
                'pending_withdrawals': pending_withdrawals,
                'total_withdrawal_amount': float(total_withdrawal_amount),
                'recent_registrations': 0,  # Implement based on your needs
                'recent_task_assignments': 0  # Implement based on your needs
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Dashboard stats error: {str(e)}")
        return jsonify({'error': 'Failed to fetch dashboard statistics'}), 500

@app.route('/api/student/tasks/week', methods=['GET'])
def get_student_tasks_by_week():
    """Get tasks by week including overdue tasks from previous periods"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401

        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401

        # Get week start parameter
        week_start = request.args.get('week_start')
        if week_start:
            try:
                week_start_date = datetime.fromisoformat(week_start)
            except ValueError:
                return jsonify({'error': 'Invalid week_start format'}), 400
        else:
            # Default to current week (Monday start)
            today = datetime.now()
            days_since_monday = today.weekday()
            week_start_date = today - timedelta(days=days_since_monday)
            
        week_start_date = week_start_date.replace(hour=0, minute=0, second=0, microsecond=0)
        week_end_date = week_start_date + timedelta(days=6, hours=23, minutes=59, seconds=59)

        # Get tasks for the week INCLUDING overdue incomplete tasks from any time period
        tasks = StudentTask.query.filter(
            StudentTask.student_id == student_id,
            db.or_(
                # Tasks due in this week
                db.and_(
                    StudentTask.due_date >= week_start_date,
                    StudentTask.due_date <= week_end_date
                ),
                # Tasks without due dates assigned this week
                db.and_(
                    StudentTask.due_date.is_(None),
                    StudentTask.assigned_at >= week_start_date,
                    StudentTask.assigned_at <= week_end_date
                ),
                # IMPORTANT: Include ALL overdue incomplete tasks regardless of due date
                db.and_(
                    StudentTask.due_date < week_start_date,  # Overdue
                    StudentTask.status != 'completed'        # Not completed
                )
            )
        ).order_by(
            # Completed tasks last, then by due date
            StudentTask.status.desc(),
            db.func.isnull(StudentTask.due_date),
            StudentTask.due_date.asc()
        ).all()

        tasks_data = []
        for task in tasks:
            task_data_dict = json.loads(task.task_data) if task.task_data else {}
            completion_data = task_data_dict.get('completion_data', {})

            # Enhanced URL handling
            task_url = None
            is_external = False
            
            if task_data_dict.get('external_url'):
                task_url = task_data_dict['external_url']
                is_external = True
            elif task_data_dict.get('task_file'):
                task_url = f"https://deciph.ai.deciphersacad.online/{task_data_dict['task_file']}"
                is_external = True

            task_info = {
                'id': task.id,
                'task_type': task.task_type,
                'task_title': task.task_title,
                'task_description': task.task_description,
                'status': task.status,  # Keep original status from DB
                'points_reward': task.points_reward,
                'acard_credit': float(task.acard_credit),
                'due_date': task.due_date.isoformat() if task.due_date else None,
                'assigned_at': task.assigned_at.isoformat(),
                'completed_at': task.completed_at.isoformat() if task.completed_at else None,
                'task_data': task_data_dict,
                'completion_data': completion_data,
                'task_url': task_url,
                'is_external': is_external,
                'is_overdue': task.due_date and task.due_date < datetime.now() and task.status != 'completed'
            }
            
            tasks_data.append(task_info)

        return jsonify({
            'tasks': tasks_data,
            'week_start': week_start_date.isoformat(),
            'week_end': week_end_date.isoformat(),
            'total_count': len(tasks_data),
            'overdue_count': len([t for t in tasks_data if t.get('is_overdue')])
        }), 200

    except Exception as e:
        logger.error(f"Get student weekly tasks error: {str(e)}")
        return jsonify({'error': 'Failed to fetch weekly tasks'}), 500

@app.route('/api/admin/task/<int:task_id>', methods=['PUT'])
@admin_required
def edit_task(task_id):
    """Edit an assigned task"""
    try:
        data = request.get_json()
        
        task = StudentTask.query.get(task_id)
        if not task:
            return jsonify({'error': 'Task not found'}), 404
        
        # Check if admin owns this task or is super admin
        if task.admin_id != request.current_admin.id and request.current_admin.role != 'super_admin':
            return jsonify({'error': 'Unauthorized to edit this task'}), 403
        
        # Prevent editing completed tasks
        if task.status == 'completed':
            return jsonify({'error': 'Cannot edit completed tasks'}), 400
        
        # Update fields
        if 'task_title' in data:
            task.task_title = data['task_title']
        if 'task_description' in data:
            task.task_description = data['task_description']
        if 'points_reward' in data:
            task.points_reward = data['points_reward']
        if 'acard_credit' in data:
            task.acard_credit = data['acard_credit']
        if 'due_date' in data:
            if data['due_date']:
                try:
                    due_date = datetime.fromisoformat(data['due_date'].replace('Z', '+00:00'))
                    if due_date.hour == 0 and due_date.minute == 0:
                        due_date = due_date.replace(hour=23, minute=59, second=59)
                    task.due_date = due_date
                except ValueError:
                    return jsonify({'error': 'Invalid due date format'}), 400
            else:
                task.due_date = None
        
        # Update task data including link configuration
        if 'task_data' in data:
            existing_task_data = json.loads(task.task_data) if task.task_data else {}
            new_task_data = data['task_data']
            
            # Handle link configuration updates
            link_config = new_task_data.get('link_config', {})
            if link_config:
                link_type = link_config.get('type')
                external_url = None
                
                if link_type == 'internal':
                    task_file = link_config.get('task_file', '').strip()
                    if task_file:
                        external_url = f'https://deciph.ai.deciphersacad.online/{task_file}'
                        new_task_data['task_file'] = task_file
                        
                elif link_type in ['external', 'common']:
                    external_url = link_config.get('external_url', '').strip()
                
                if external_url:
                    new_task_data['external_url'] = external_url
                    new_task_data['link_type'] = link_type
                    new_task_data['is_external'] = True
            
            # Merge with existing data
            existing_task_data.update(new_task_data)
            task.task_data = json.dumps(existing_task_data)
        
        db.session.commit()
        
        return jsonify({
            'message': 'Task updated successfully',
            'task': {
                'id': task.id,
                'task_title': task.task_title,
                'task_description': task.task_description,
                'points_reward': task.points_reward,
                'acard_credit': float(task.acard_credit),
                'due_date': task.due_date.isoformat() if task.due_date else None,
                'task_data': json.loads(task.task_data) if task.task_data else {}
            }
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Edit task error: {str(e)}")
        return jsonify({'error': f'Failed to update task: {str(e)}'}), 500


@app.route('/api/admin/task/<int:task_id>', methods=['DELETE'])
@admin_required
def delete_task(task_id):
    """Delete an assigned task"""
    try:
        task = StudentTask.query.get(task_id)
        if not task:
            return jsonify({'error': 'Task not found'}), 404
        
        # Check if admin owns this task or is super admin
        if task.admin_id != request.current_admin.id and request.current_admin.role != 'super_admin':
            return jsonify({'error': 'Unauthorized to delete this task'}), 403
        
        # Prevent deleting completed tasks (optional - you can remove this if you want to allow it)
        if task.status == 'completed':
            return jsonify({'error': 'Cannot delete completed tasks'}), 400
        
        # Store task info for response
        task_info = {
            'id': task.id,
            'title': task.task_title,
            'student_name': task.student.name if task.student else 'Unknown'
        }
        
        db.session.delete(task)
        db.session.commit()
        
        return jsonify({
            'message': f'Task "{task_info["title"]}" deleted successfully',
            'deleted_task': task_info
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Delete task error: {str(e)}")
        return jsonify({'error': f'Failed to delete task: {str(e)}'}), 500
    
@app.route('/api/admin/acard/credit', methods=['POST'])
@admin_required
def credit_acard():
    """Credit A-Card balance for students"""
    try:
        data = request.get_json()
        
        # Validate required fields
        if not data or 'student_ids' not in data or 'amount' not in data or 'description' not in data:
            return jsonify({'error': 'Missing required fields'}), 400
            
        student_ids = data['student_ids']
        amount = float(data['amount'])
        description = data['description']
        
        if not isinstance(student_ids, list):
            return jsonify({'error': 'student_ids must be a list'}), 400
            
        if amount <= 0:
            return jsonify({'error': 'Amount must be positive'}), 400
            
        credited_students = []
        
        for student_id in student_ids:
            try:
                student = Student.query.get(student_id)
                if not student:
                    continue
                    
                # Get current balance (handle None case)
                current_balance = float(student.acard_balance or 0)
                new_balance = current_balance + amount
                
                # Update student balance
                student.acard_balance = new_balance
                
                # Create transaction record
                transaction = ACardTransaction(
                    student_id=student_id,
                    admin_id=request.current_admin.id,
                    transaction_type='manual_credit',
                    amount=amount,
                    description=description,
                    balance_after=new_balance
                )
                db.session.add(transaction)
                
                credited_students.append({
                    'student_id': student_id,
                    'student_name': student.name,
                    'new_balance': new_balance
                })
                
            except Exception as e:
                logger.error(f"Error crediting student {student_id}: {str(e)}")
                continue
                
        db.session.commit()
        
        return jsonify({
            'message': f'A-Card credited for {len(credited_students)} students',
            'credited_students': credited_students
        }), 200
        
    except ValueError:
        return jsonify({'error': 'Invalid amount value'}), 400
    except Exception as e:
        db.session.rollback()
        logger.error(f"A-Card credit error: {str(e)}")
        return jsonify({'error': 'Failed to process A-Card credit'}), 500

# Get A-Card Transactions
@app.route('/api/admin/acard/transactions', methods=['GET'])
@admin_required
def get_acard_transactions():
    """Get A-Card transaction history"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 50, type=int)
        student_id = request.args.get('student_id', type=int)
        transaction_type = request.args.get('type', '')
        
        # Build query
        query = ACardTransaction.query.join(Student)
        
        # Apply filters
        if student_id:
            query = query.filter(ACardTransaction.student_id == student_id)
        
        if transaction_type:
            query = query.filter(ACardTransaction.transaction_type == transaction_type)
        
        # Order by most recent
        query = query.order_by(ACardTransaction.created_at.desc())
        
        # Paginate
        transactions_paginated = query.paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        transactions_data = []
        for transaction in transactions_paginated.items:
            transactions_data.append({
                'id': transaction.id,
                'student': {
                    'id': transaction.student.id,
                    'name': transaction.student.name
                },
                'transaction_type': transaction.transaction_type,
                'amount': float(transaction.amount),
                'description': transaction.description,
                'balance_after': float(transaction.balance_after),
                'created_at': transaction.created_at.isoformat(),
                'admin_name': transaction.admin.name if transaction.admin else None
            })
        
        return jsonify({
            'transactions': transactions_data,
            'pagination': {
                'page': transactions_paginated.page,
                'pages': transactions_paginated.pages,
                'per_page': transactions_paginated.per_page,
                'total': transactions_paginated.total,
                'has_next': transactions_paginated.has_next,
                'has_prev': transactions_paginated.has_prev
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Get A-Card transactions error: {str(e)}")
        return jsonify({'error': 'Failed to fetch transactions'}), 500

# Application startup
if __name__ == '__main__':
    with app.app_context():
        # Verify database connectivity (tables must already exist)
        try:
            from sqlalchemy import text
            db.session.execute(text("SELECT 1")).fetchone()
            logger.info("âœ“ Database connection verified successfully")
            logger.info("ðŸ“‹ Note: Database tables must be created via migrations or manual setup")

        except Exception as e:
            logger.error(f"Database connectivity error: {str(e)}")
            logger.error("âš ï¸ Please ensure database is accessible and tables are created")

    app.run(debug=True)

# Admin Task Completion Endpoint
@app.route('/api/admin/task/<int:task_id>/complete', methods=['PUT'])
@admin_required
def admin_complete_task(task_id):
    """Admin manually marks a task as completed"""
    try:
        task = StudentTask.query.get_or_404(task_id)
        
        if task.status == 'completed':
            return jsonify({'error': 'Task already completed'}), 400
        
        # Mark task as completed
        task.status = 'completed'
        task.completed_at = datetime.utcnow()
        
        # Add admin completion note to task data
        task_data_dict = json.loads(task.task_data) if task.task_data else {}
        task_data_dict['admin_completion'] = {
            'completed_by_admin': True,
            'admin_id': request.current_admin.id,
            'admin_name': request.current_admin.name,
            'completion_timestamp': datetime.utcnow().isoformat(),
            'note': 'Manually completed by admin'
        }
        task.task_data = json.dumps(task_data_dict)
        
        # Get student and award rewards
        student = Student.query.get(task.student_id)
        
        # Award points
        if task.points_reward > 0:
            current_points = getattr(student, 'total_points', 0) or 0
            student.total_points = current_points + task.points_reward
        
        # Credit A-Card
        if task.acard_credit > 0:
            current_balance = float(getattr(student, 'acard_balance', 0) or 0)
            new_balance = current_balance + float(task.acard_credit)
            student.acard_balance = new_balance
            
            # Create transaction record
            transaction = ACardTransaction(
                student_id=task.student_id,
                admin_id=request.current_admin.id,
                task_id=task.id,
                transaction_type='admin_completion',
                amount=float(task.acard_credit),
                description=f'Admin completed task: {task.task_title}',
                balance_after=new_balance
            )
            db.session.add(transaction)
        
        db.session.commit()
        
        return jsonify({
            'message': 'Task completed successfully by admin',
            'task': {
                'id': task.id,
                'status': task.status,
                'completed_at': task.completed_at.isoformat()
            },
            'rewards': {
                'points_awarded': task.points_reward,
                'acard_credited': float(task.acard_credit),
                'new_acard_balance': float(getattr(student, 'acard_balance', 0) or 0)
            }
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Admin complete task error: {str(e)}")
        return jsonify({'error': 'Failed to complete task'}), 500


# Replace your super_admin_required decorator with this corrected version
# that works with your existing role-based Admin model
# Replace your super_admin_required decorator with this debug version

def super_admin_required(f):
    """Decorator to require super admin authentication - DEBUG VERSION"""
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        logger.info(f"DEBUG - Auth header: {token}")
        
        if not token:
            logger.error("DEBUG - No token provided")
            return jsonify({'error': 'No token provided'}), 401
        
        try:
            if token.startswith('Bearer '):
                token = token[7:]
            
            logger.info(f"DEBUG - Extracted token: {token[:50]}...")
            
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            logger.info(f"DEBUG - Token payload: {payload}")
            
            admin_id = payload.get('admin_id')
            
            if not admin_id:
                logger.error("DEBUG - No admin_id in token")
                return jsonify({'error': 'Invalid token'}), 401
            
            admin = Admin.query.get(admin_id)
            logger.info(f"DEBUG - Found admin: {admin}")
            
            if not admin:
                logger.error(f"DEBUG - Admin with ID {admin_id} not found")
                return jsonify({'error': 'Admin account not found'}), 403
            
            if not admin.is_active:
                logger.error(f"DEBUG - Admin {admin.email} is inactive")
                return jsonify({'error': 'Admin account inactive'}), 403
            
            logger.info(f"DEBUG - Admin role: {admin.role}")
            
            # Check if admin has super admin role - using your existing role field
            if admin.role != 'super_admin':
                logger.error(f"DEBUG - Admin {admin.email} has role '{admin.role}', not 'super_admin'")
                return jsonify({'error': 'Super admin access required'}), 403
            
            logger.info(f"DEBUG - Super admin access granted to {admin.email}")
            request.current_admin = admin
            return f(*args, **kwargs)
            
        except jwt.ExpiredSignatureError:
            logger.error("DEBUG - Token expired")
            return jsonify({'error': 'Token expired'}), 401
        except jwt.InvalidTokenError as e:
            logger.error(f"DEBUG - Invalid token: {str(e)}")
            return jsonify({'error': 'Invalid token'}), 401
        except Exception as e:
            logger.error(f"DEBUG - Super admin authentication error: {str(e)}")
            return jsonify({'error': 'Authentication failed'}), 500
    
    return decorated


# Replace your existing create_new_admin endpoint with this corrected version

@app.route('/api/super-admin/create-admin', methods=['POST'])
@super_admin_required
def create_new_admin():
    """Super admin creates new admin account"""
    try:
        data = request.get_json()
        required_fields = ['name', 'email', 'password']
        
        if not all(field in data for field in required_fields):
            return jsonify({'error': 'Name, email, and password are required'}), 400
        
        email = data['email'].strip().lower()
        
        # Check if admin already exists
        existing_admin = Admin.query.filter_by(email=email).first()
        if existing_admin:
            return jsonify({'error': 'Admin with this email already exists'}), 400
        
        # Validate password strength
        password = data['password']
        if len(password) < 6:
            return jsonify({'error': 'Password must be at least 6 characters long'}), 400
        
        # Create new admin using your existing model structure
        new_admin = Admin(
            name=data['name'].strip(),
            email=email,
            password_hash=generate_password_hash(password),
            role=data.get('role', 'admin'),  # Use role field instead of is_super_admin
            is_active=True,
            created_at=datetime.utcnow()
        )
        
        db.session.add(new_admin)
        db.session.flush()
        
        # Try to create initial assignment record if AdminAssignment table exists
        grade_section = data.get('grade_section', '1-3')
        max_acard = data.get('max_acard_amount', 50.00)
        
        try:
            assignment = AdminAssignment(
                admin_id=new_admin.id,
                assignment_type='grade_section',
                grade_section=grade_section,
                max_acard_amount=max_acard,
                permissions={
                    'assign_tasks': True,
                    'credit_acard': True,
                    'max_acard_per_credit': max_acard,
                    'view_students': True,
                    'export_data': True
                },
                created_by=request.current_admin.id
            )
            
            db.session.add(assignment)
        except Exception as assignment_error:
            # If AdminAssignment table doesn't exist yet, just create the admin without assignment
            logger.warning(f"Could not create assignment: {str(assignment_error)}")
        
        db.session.commit()
        
        logger.info(f"New admin created: {new_admin.email} by {request.current_admin.email}")
        
        return jsonify({
            'message': 'Admin account created successfully',
            'admin': {
                'id': new_admin.id,
                'name': new_admin.name,
                'email': new_admin.email,
                'role': new_admin.role,
                'grade_section': grade_section,
                'max_acard_amount': float(max_acard)
            }
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Create admin error: {str(e)}")
        return jsonify({'error': 'Failed to create admin account'}), 500

# Replace your existing get_all_admins endpoint with this corrected version

@app.route('/api/super-admin/admins', methods=['GET'])
@super_admin_required
def get_all_admins():
    """Get all admin accounts with their assignments"""
    try:
        # Filter out super admins to only show regular admins
        admins = Admin.query.filter(Admin.role != 'super_admin').all()
        
        admins_data = []
        for admin in admins:
            # Try to get admin assignment (may not exist yet)
            assignment = None
            try:
                assignment = AdminAssignment.query.filter_by(
                    admin_id=admin.id, 
                    assignment_type='grade_section'
                ).first()
            except:
                # If AdminAssignment table doesn't exist yet, skip assignment data
                pass
            
            # Count assigned students
            assigned_students = 0
            if assignment and assignment.student_ids:
                assigned_students = len(assignment.student_ids)
            
            # Count resources
            resources_count = 0
            try:
                resources_count = AdminResource.query.filter_by(
                    admin_id=admin.id,
                    is_active=True
                ).count()
            except:
                # If AdminResource table doesn't exist yet, skip resources count
                pass
            
            admins_data.append({
                'id': admin.id,
                'name': admin.name,
                'email': admin.email,
                'role': admin.role,
                'is_active': admin.is_active,  # This field exists in your model
                'grade_section': assignment.grade_section if assignment else None,
                'max_acard_amount': float(assignment.max_acard_amount) if assignment else 0.00,
                'assigned_students': assigned_students,
                'resources_count': resources_count,
                'created_at': admin.created_at.isoformat() if admin.created_at else None,
                'last_login': admin.last_login.isoformat() if admin.last_login else None
            })
        
        return jsonify({
            'admins': admins_data,
            'total_count': len(admins_data)
        }), 200
        
    except Exception as e:
        logger.error(f"Get all admins error: {str(e)}")
        return jsonify({'error': 'Failed to fetch admins'}), 500

# Replace your assign students endpoint with this simplified version

@app.route('/api/super-admin/assign-students', methods=['POST'])
@super_admin_required
def assign_students_to_admin():
    """Assign students to an admin - SIMPLIFIED VERSION"""
    try:
        data = request.get_json()
        
        # Basic validation
        if not data:
            return jsonify({'error': 'No data provided'}), 400
            
        if 'admin_id' not in data or 'student_ids' not in data:
            return jsonify({'error': 'Admin ID and student IDs are required'}), 400
        
        admin_id = data['admin_id']
        student_ids = data['student_ids']
        
        # Convert admin_id to int if it's a string
        try:
            admin_id = int(admin_id)
        except (ValueError, TypeError):
            return jsonify({'error': 'Invalid admin ID format'}), 400
        
        if not isinstance(student_ids, list):
            return jsonify({'error': 'Student IDs must be a list'}), 400
        
        # Check if admin exists
        admin = Admin.query.get(admin_id)
        if not admin:
            return jsonify({'error': f'Admin with ID {admin_id} not found'}), 400
        
        # Check if admin is not a super admin
        if admin.role == 'super_admin':
            return jsonify({'error': 'Cannot assign students to super admin'}), 400
        
        # Verify students exist
        students = Student.query.filter(Student.id.in_(student_ids)).all()
        if len(students) != len(student_ids):
            found_ids = [s.id for s in students]
            missing_ids = [sid for sid in student_ids if sid not in found_ids]
            return jsonify({'error': f'Students not found: {missing_ids}'}), 400
        
        # Get or create admin assignment
        assignment = AdminAssignment.query.filter_by(
            admin_id=admin_id,
            assignment_type='grade_section'
        ).first()
        
        if not assignment:
            # Create new assignment
            assignment = AdminAssignment(
                admin_id=admin_id,
                assignment_type='grade_section',
                grade_section='1-3',
                max_acard_amount=50.00,
                permissions={'assign_tasks': True, 'credit_acard': True},
                created_by=request.current_admin.id
            )
            db.session.add(assignment)
            db.session.flush()
        
        # Update student assignments
        current_student_ids = assignment.student_ids if assignment.student_ids else []
        all_student_ids = list(set(current_student_ids + student_ids))
        assignment.student_ids = all_student_ids
        
        db.session.commit()
        
        return jsonify({
            'message': f'Successfully assigned {len(student_ids)} students to {admin.name}',
            'admin_name': admin.name,
            'total_students': len(all_student_ids),
            'newly_assigned': len(student_ids)
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Assign students error: {str(e)}")
        return jsonify({'error': f'Server error: {str(e)}'}), 500
        
# Replace your assign_resources_to_admin endpoint with this debug version
# Super Admin - Update Admin Settings
@app.route('/api/super-admin/admin/<int:admin_id>/settings', methods=['PUT'])
@super_admin_required
def update_admin_settings(admin_id):
    """Update admin settings including A-Card limits and permissions"""
    try:
        data = request.get_json()
        
        admin = Admin.query.get(admin_id)
        if not admin or admin.role:
            return jsonify({'error': 'Invalid admin ID'}), 400
        
        # Update admin basic info
        if 'name' in data:
            admin.name = data['name']
        if 'is_active' in data:
            admin.is_active = data['is_active']
        
        # Update assignment settings
        assignment = AdminAssignment.query.filter_by(
            admin_id=admin_id,
            assignment_type='grade_section'
        ).first()
        
        if assignment:
            if 'max_acard_amount' in data:
                assignment.max_acard_amount = data['max_acard_amount']
            if 'grade_section' in data:
                assignment.grade_section = data['grade_section']
            if 'permissions' in data:
                current_permissions = assignment.permissions or {}
                current_permissions.update(data['permissions'])
                assignment.permissions = current_permissions
        
        db.session.commit()
        
        return jsonify({
            'message': f'Updated settings for {admin.name}',
            'admin': {
                'id': admin.id,
                'name': admin.name,
                'is_active': admin.is_active,
                'max_acard_amount': float(assignment.max_acard_amount) if assignment else 0.00,
                'grade_section': assignment.grade_section if assignment else None
            }
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Update admin settings error: {str(e)}")
        return jsonify({'error': 'Failed to update admin settings'}), 500

# Regular Admin - Get My Assignment and Resources
@app.route('/api/admin/my-assignment', methods=['GET'])
@admin_required
def get_my_admin_assignment():
    """Get current admin's assignment, students, and resources"""
    try:
        admin = request.current_admin
        
        # Get assignment
        assignment = AdminAssignment.query.filter_by(
            admin_id=admin.id,
            assignment_type='grade_section'
        ).first()
        
        if not assignment:
            return jsonify({'error': 'No assignment found for this admin'}), 404
        
        # Get assigned students
        assigned_students = []
        if assignment.student_ids:
            students = Student.query.filter(Student.id.in_(assignment.student_ids)).all()
            for student in students:
                assigned_students.append({
                    'id': student.id,
                    'name': student.name,
                    'email': student.email,
                    'grade_level': getattr(student, 'grade_level', 'N/A'),
                    'school_name': getattr(student, 'school_name', 'N/A'),
                    'total_points': getattr(student, 'total_points', 0),
                    'acard_balance': float(getattr(student, 'acard_balance', 0) or 0)
                })
        
        # Get assigned resources
        resources = AdminResource.query.filter_by(
            admin_id=admin.id,
            is_active=True
        ).all()
        
        resources_data = []
        for resource in resources:
            resources_data.append({
                'id': resource.id,
                'resource_type': resource.resource_type,
                'resource_title': resource.resource_title,
                'resource_url': resource.resource_url,
                'task_file': resource.task_file,
                'subject_category': resource.subject_category,
                'description': resource.description,
                'created_at': resource.created_at.isoformat()
            })
        
        return jsonify({
            'assignment': {
                'grade_section': assignment.grade_section,
                'max_acard_amount': float(assignment.max_acard_amount),
                'permissions': assignment.permissions or {}
            },
            'assigned_students': assigned_students,
            'assigned_students_count': len(assigned_students),
            'available_resources': resources_data,
            'resources_count': len(resources_data)
        }), 200
        
    except Exception as e:
        logger.error(f"Get admin assignment error: {str(e)}")
        return jsonify({'error': 'Failed to fetch assignment data'}), 500

@app.route('/api/admin/my-admin-assignment', methods=['GET'])
@admin_required
def get_my_admin_assignments():
    """Get current admin's assignment, students, and resources"""
    try:
        admin = request.current_admin
        
        # Get assignment
        assignment = AdminAssignment.query.filter_by(
            admin_id=admin.id,
            assignment_type='grade_section'
        ).first()
        
        if not assignment:
            return jsonify({'error': 'No assignment found for this admin'}), 404
        
        # Get assigned students
        assigned_students = []
        if assignment.student_ids:
            students = Student.query.filter(Student.id.in_(assignment.student_ids)).all()
            for student in students:
                assigned_students.append({
                    'id': student.id,
                    'name': student.name,
                    'email': student.email,
                    'grade_level': getattr(student, 'grade_level', 'N/A'),
                    'school_name': getattr(student, 'school_name', 'N/A'),
                    'total_points': getattr(student, 'total_points', 0),
                    'acard_balance': float(getattr(student, 'acard_balance', 0) or 0)
                })
        
        # Get assigned resources
        resources = AdminResource.query.filter_by(
            admin_id=admin.id,
            is_active=True
        ).all()
        
        resources_data = []
        for resource in resources:
            resources_data.append({
                'id': resource.id,
                'resource_type': resource.resource_type,
                'resource_title': resource.resource_title,
                'resource_url': resource.resource_url,
                'task_file': resource.task_file,
                'subject_category': resource.subject_category,
                'description': resource.description,
                'created_at': resource.created_at.isoformat()
            })
        
        return jsonify({
            'assignment': {
                'grade_section': assignment.grade_section,
                'max_acard_amount': float(assignment.max_acard_amount),
                'permissions': assignment.permissions or {}
            },
            'assigned_students': assigned_students,
            'assigned_students_count': len(assigned_students),
            'available_resources': resources_data,
            'resources_count': len(resources_data)
        }), 200
        
    except Exception as e:
        logger.error(f"Get admin assignment error: {str(e)}")
        return jsonify({'error': 'Failed to fetch assignment data'}), 500



@app.route('/api/admin/assign-resource-task', methods=['POST'])
@admin_required
def assign_grade_admin_task():
    """Assign tasks using assigned resources - supports both single and bulk assignment for grade admins"""
    try:
        # Ensure this is not a super admin using this endpoint
        if request.current_admin.role == 'super_admin':
            return jsonify({'error': 'Super admins should use the main task assignment endpoint'}), 403
        
        data = request.get_json()
        
        # Check if this is bulk assignment (has 'tasks' array) or single assignment
        is_bulk = 'tasks' in data and isinstance(data['tasks'], list)
        
        if is_bulk:
            # Bulk assignment validation
            if 'student_ids' not in data:
                return jsonify({'error': 'Missing student_ids for bulk assignment'}), 400
            
            tasks_data = data['tasks']
            if not tasks_data:
                return jsonify({'error': 'tasks array cannot be empty'}), 400
                
            # Validate each task has required fields
            for i, task_data in enumerate(tasks_data):
                required_fields = ['task_title', 'task_description', 'task_type']
                missing_fields = [field for field in required_fields if not task_data.get(field)]
                if missing_fields:
                    return jsonify({
                        'error': f'Task {i+1} missing required fields: {", ".join(missing_fields)}'
                    }), 400
        else:
            # Single assignment validation
            required_fields = ['student_ids', 'task_title', 'task_description']
            if not all(field in data for field in required_fields):
                return jsonify({'error': 'Missing required fields'}), 400

            # Resource or link config is required
            if 'resource_id' not in data and 'link_config' not in data:
                return jsonify({'error': 'Either resource_id or link_config is required'}), 400
        
        student_ids = data['student_ids']
        if not isinstance(student_ids, list) or not student_ids:
            return jsonify({'error': 'student_ids must be a non-empty list'}), 400
        
        # Get admin assignment to check limits and access
        admin_assignment = AdminAssignment.query.filter_by(
            admin_id=request.current_admin.id
        ).first()
        
        if not admin_assignment:
            return jsonify({'error': 'Admin assignment not found. Contact super admin.'}), 403
        
        # Get assigned students from AdminAssignment
        assigned_student_ids = set(admin_assignment.student_ids or [])
        
        # Verify all students are assigned to this admin
        for student_id in student_ids:
            if student_id not in assigned_student_ids:
                return jsonify({'error': f'Student {student_id} is not assigned to you'}), 403
        
        # Get admin's available resources
        admin_resources = AdminResource.query.filter_by(
            admin_id=request.current_admin.id,
            is_active=True
        ).all()
        
        available_resource_ids = {r.id for r in admin_resources}
        admin_resources_dict = {r.id: r for r in admin_resources}
        
        # Task type mapping
        task_type_mapping = {
            'mathematics': 'math',
            'basic_science': 'science',
            'social_studies': 'history',
            'humanities': 'history',
            'physics': 'science',
            'chemistry': 'science',
            'biology': 'science',
            'economics': 'history'
        }
        
        successful_assignments = []
        failed_assignments = []
        
        if is_bulk:
            # Process bulk assignment
            batch_id = datetime.now().isoformat()
            
            for student_id in student_ids:
                student = Student.query.get(student_id)
                if not student:
                    failed_assignments.append({
                        'student_id': student_id,
                        'error': 'Student not found'
                    })
                    continue
                
                for task_index, task_data in enumerate(tasks_data):
                    try:
                        # Check A-Card limit
                        acard_credit = float(task_data.get('acard_credit', 0))
                        max_acard_per_task = admin_assignment.max_acard_amount or 0
                        
                        if acard_credit > max_acard_per_task:
                            failed_assignments.append({
                                'student_id': student_id,
                                'student_name': student.name,
                                'task_index': task_index + 1,
                                'task_title': task_data.get('task_title', 'Unknown'),
                                'error': f'A-Card credit {acard_credit} exceeds limit of {max_acard_per_task}'
                            })
                            continue
                        
                        # Parse due date
                        due_date = None
                        if task_data.get('due_date'):
                            try:
                                due_date_str = task_data['due_date']
                                if 'T' in due_date_str and 'Z' not in due_date_str and '+' not in due_date_str:
                                    due_date = datetime.fromisoformat(due_date_str)
                                else:
                                    due_date = datetime.fromisoformat(due_date_str.replace('Z', '+00:00'))
                                
                                if due_date.hour == 0 and due_date.minute == 0:
                                    due_date = due_date.replace(hour=23, minute=59, second=59)
                            except ValueError as e:
                                failed_assignments.append({
                                    'student_id': student_id,
                                    'student_name': student.name,
                                    'task_index': task_index + 1,
                                    'error': f'Invalid due date: {str(e)}'
                                })
                                continue
                        
                        # Prepare task data
                        enhanced_task_data = task_data.get('task_data', {})
                        resource_id = enhanced_task_data.get('resource_id')
                        
                        if resource_id:
                            # Validate resource access
                            if resource_id not in available_resource_ids:
                                failed_assignments.append({
                                    'student_id': student_id,
                                    'student_name': student.name,
                                    'task_index': task_index + 1,
                                    'error': 'Resource not assigned to you'
                                })
                                continue
                            
                            resource = admin_resources_dict[resource_id]
                            enhanced_task_data.update({
                                'resource_id': resource.id,
                                'resource_type': resource.resource_type,
                                'resource_title': resource.resource_title,
                                'subject_category': resource.subject_category
                            })
                            
                            # Set up resource links
                            if resource.resource_type == 'internal_file' and resource.task_file:
                                enhanced_task_data.update({
                                    'task_file': resource.task_file,
                                    'external_url': f'https://deciph.ai.deciphersacad.online/{resource.task_file}',
                                    'link_type': 'internal',
                                    'is_external': True
                                })
                            elif resource.resource_url:
                                enhanced_task_data.update({
                                    'external_url': resource.resource_url,
                                    'link_type': 'external',
                                    'is_external': True
                                })
                        
                        # Add bulk assignment metadata
                        enhanced_task_data.update({
                            'assigned_by_grade_admin': True,
                            'grade_section': admin_assignment.grade_section,
                            'bulk_assignment': True,
                            'bulk_assignment_batch': batch_id,
                            'assigned_by_admin_id': request.current_admin.id
                        })
                        
                        # Determine task type
                        frontend_task_type = task_data.get('task_type', 'mathematics')
                        db_task_type = task_type_mapping.get(frontend_task_type, frontend_task_type)
                        
                        # Create task
                        task = StudentTask(
                            student_id=student_id,
                            admin_id=request.current_admin.id,
                            task_type=db_task_type,
                            task_title=task_data['task_title'],
                            task_description=task_data['task_description'],
                            task_data=json.dumps(enhanced_task_data),
                            points_reward=task_data.get('points_reward', 0),
                            acard_credit=acard_credit,
                            due_date=due_date,
                            status='pending'
                        )
                        
                        db.session.add(task)
                        db.session.flush()
                        
                        successful_assignments.append({
                            'student_id': student_id,
                            'student_name': student.name,
                            'task_id': task.id,
                            'task_title': task_data['task_title'],
                            'task_index': task_index + 1,
                            'resource_used': resource.resource_title if resource_id else None,
                            'external_url': enhanced_task_data.get('external_url'),
                            'due_date': due_date.isoformat() if due_date else None
                        })
                        
                    except Exception as task_error:
                        logger.error(f"Error creating bulk task: {str(task_error)}")
                        failed_assignments.append({
                            'student_id': student_id,
                            'student_name': student.name,
                            'task_index': task_index + 1,
                            'task_title': task_data.get('task_title', 'Unknown'),
                            'error': str(task_error)
                        })
        else:
            # Process single assignment (existing logic)
            resource_id = data.get('resource_id')
            link_config = data.get('link_config')

            # Check A-Card credit limit
            acard_credit = float(data.get('acard_credit', 0))
            max_acard_per_task = admin_assignment.max_acard_amount or 0

            if acard_credit > max_acard_per_task:
                return jsonify({'error': f'A-Card credit cannot exceed {max_acard_per_task} per task'}), 400

            # Parse due date
            due_date = None
            if data.get('due_date'):
                try:
                    due_date_str = data['due_date']
                    if 'T' in due_date_str and 'Z' not in due_date_str and '+' not in due_date_str:
                        due_date = datetime.fromisoformat(due_date_str)
                    else:
                        due_date = datetime.fromisoformat(due_date_str.replace('Z', '+00:00'))

                    if due_date.hour == 0 and due_date.minute == 0:
                        due_date = due_date.replace(hour=23, minute=59, second=59)

                except ValueError as e:
                    return jsonify({'error': f'Invalid due date format: {str(e)}'}), 400

            # Prepare task data
            task_data = {
                'assigned_by_grade_admin': True,
                'grade_section': admin_assignment.grade_section,
                'assigned_by_admin_id': request.current_admin.id
            }

            # Handle resource-based assignment
            resource_used_title = None
            db_task_type = 'math'  # Default

            if resource_id:
                # Validate resource access
                if resource_id not in available_resource_ids:
                    return jsonify({'error': 'Resource not found or not assigned to you'}), 404

                resource = admin_resources_dict[resource_id]
                resource_used_title = resource.resource_title

                task_data.update({
                    'resource_id': resource.id,
                    'resource_type': resource.resource_type,
                    'resource_title': resource.resource_title,
                    'subject_category': resource.subject_category
                })

                # Set up link configuration from resource
                if resource.resource_type == 'internal_file' and resource.task_file:
                    task_data.update({
                        'task_file': resource.task_file,
                        'external_url': f'https://deciph.ai.deciphersacad.online/{resource.task_file}',
                        'link_type': 'internal',
                        'is_external': True
                    })
                elif resource.resource_url:
                    task_data.update({
                        'external_url': resource.resource_url,
                        'link_type': 'external',
                        'is_external': True
                    })

                db_task_type = task_type_mapping.get(resource.subject_category, resource.subject_category)

            # Handle link_config-based assignment (overrides resource links if both provided)
            if link_config:
                resource_used_title = 'Custom Link'
                link_type = link_config.get('type', 'external')

                if link_type == 'internal' and link_config.get('task_file'):
                    task_data.update({
                        'task_file': link_config['task_file'],
                        'external_url': link_config.get('external_url', f"https://deciph.ai.deciphersacad.online/{link_config['task_file']}"),
                        'link_type': 'internal',
                        'link_config': link_config,
                        'is_external': True
                    })
                elif link_config.get('external_url'):
                    task_data.update({
                        'external_url': link_config['external_url'],
                        'link_type': link_type,
                        'link_config': link_config,
                        'is_external': True
                    })

                # Use task_type from data if provided, otherwise default to math
                db_task_type = task_type_mapping.get(data.get('task_type', 'mathematics'), 'math')
            
            # Create tasks for each student
            for student_id in student_ids:
                student = Student.query.get(student_id)
                if not student:
                    failed_assignments.append({
                        'student_id': student_id,
                        'error': 'Student not found'
                    })
                    continue
                
                try:
                    task = StudentTask(
                        student_id=student_id,
                        admin_id=request.current_admin.id,
                        task_type=db_task_type,
                        task_title=data['task_title'],
                        task_description=data['task_description'],
                        task_data=json.dumps(task_data),
                        points_reward=data.get('points_reward', 0),
                        acard_credit=acard_credit,
                        due_date=due_date,
                        status='pending'
                    )
                    
                    db.session.add(task)
                    db.session.flush()
                    
                    successful_assignments.append({
                        'student_id': student_id,
                        'student_name': student.name,
                        'task_id': task.id,
                        'resource_used': resource_used_title or 'Direct Assignment',
                        'external_url': task_data.get('external_url'),
                        'due_date': due_date.isoformat() if due_date else None
                    })
                    
                except Exception as task_error:
                    logger.error(f"Error creating single resource task: {str(task_error)}")
                    failed_assignments.append({
                        'student_id': student_id,
                        'error': str(task_error)
                    })
        
        # Commit all successful assignments
        db.session.commit()
        
        # Prepare response
        assignment_type = 'bulk' if is_bulk else 'single'
        
        response_data = {
            'message': f'{assignment_type.capitalize()} assignment completed: {len(successful_assignments)} successful',
            'total_assignments': len(successful_assignments),
            'successful_assignments': len(successful_assignments),
            'failed_assignments': len(failed_assignments),
            'assignment_type': assignment_type,
            'assigned_tasks': successful_assignments,
            'grade_section': admin_assignment.grade_section,
            'success': True
        }
        
        if failed_assignments:
            response_data['failures'] = failed_assignments
            response_data['warning'] = f'{len(failed_assignments)} assignments failed'
        
        logger.info(f"Grade admin {request.current_admin.id} completed {assignment_type} assignment: "
                   f"{len(successful_assignments)} successful, {len(failed_assignments)} failed")
        
        status_code = 201 if len(failed_assignments) == 0 else 207
        return jsonify(response_data), status_code
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Resource task assignment error: {str(e)}")
        return jsonify({
            'error': f'Failed to assign task: {str(e)}',
            'success': False
        }), 500
    
@app.route('/api/super-admin/assign-resources', methods=['POST'])
@super_admin_required
def assign_resources_to_admin():
    """Assign resources to an admin - Super Admin Only"""
    try:
        data = request.get_json()
        
        # Validate required fields
        if not data.get('admin_id') or not data.get('resources'):
            return jsonify({'error': 'admin_id and resources are required'}), 400
        
        admin_id = data['admin_id']
        resources_data = data['resources']
        
        # Validate admin exists and is not super admin
        target_admin = Admin.query.get(admin_id)
        if not target_admin:
            return jsonify({'error': 'Admin not found'}), 404
        
        if target_admin.role == 'super_admin':
            return jsonify({'error': 'Cannot assign resources to super admin'}), 400
        
        # Get admin's grade section from AdminAssignment
        admin_assignment = AdminAssignment.query.filter_by(admin_id=admin_id).first()
        target_grade_section = admin_assignment.grade_section if admin_assignment else '1-12'
        
        # Validate resources data
        if not isinstance(resources_data, list) or not resources_data:
            return jsonify({'error': 'Resources must be a non-empty list'}), 400
        
        created_resources = []
        
        for resource_data in resources_data:
            # Validate required fields for each resource
            required_fields = ['resource_type', 'resource_title', 'subject_category']
            if not all(field in resource_data for field in required_fields):
                return jsonify({'error': f'Missing required fields in resource: {required_fields}'}), 400
            
            # Create the resource - matches your existing AdminResource model
            resource = AdminResource(
                admin_id=admin_id,  # Directly assign to admin
                grade_section=target_grade_section,  # Use admin's grade section
                resource_type=resource_data['resource_type'],
                resource_title=resource_data['resource_title'],
                subject_category=resource_data['subject_category'],
                description=resource_data.get('description', ''),
                created_by=request.current_admin.id,  # Use your model's field name
                is_active=True
            )
            
            # Set type-specific fields based on your model structure
            if resource_data['resource_type'] == 'internal_file':
                if not resource_data.get('task_file'):
                    return jsonify({'error': 'task_file is required for internal_file type'}), 400
                resource.task_file = resource_data['task_file']
                resource.resource_url = f"https://deciph.ai.deciphersacad.online/{resource_data['task_file']}"
            else:
                if not resource_data.get('resource_url'):
                    return jsonify({'error': 'resource_url is required for external/common link types'}), 400
                resource.resource_url = resource_data['resource_url']
            
            db.session.add(resource)
            db.session.flush()  # Get the resource ID
            
            created_resources.append({
                'id': resource.id,
                'title': resource.resource_title,
                'type': resource.resource_type,
                'category': resource.subject_category,
                'url': resource.resource_url,
                'grade_section': resource.grade_section
            })
            
            logger.info(f"Super admin {request.current_admin.id} created resource {resource.id} for admin {admin_id}")
        
        db.session.commit()
        
        # Count admin's total resources
        admin_resources_count = AdminResource.query.filter_by(
            admin_id=admin_id, 
            is_active=True
        ).count()
        
        return jsonify({
            'message': f'Successfully assigned {len(created_resources)} resources to {target_admin.name}',
            'resources_created': created_resources,
            'admin': {
                'id': target_admin.id,
                'name': target_admin.name,
                'grade_section': target_grade_section,
                'total_resources': admin_resources_count
            },
            'success': True
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error assigning resources: {str(e)}")
        return jsonify({
            'error': f'Failed to assign resources: {str(e)}',
            'success': False
        }), 500
    
# Students filter by grade for super admin
@app.route('/api/super-admin/students-by-grade', methods=['GET'])
@super_admin_required
def get_students_by_grade():
    """Get students filtered by grade sections for assignment"""
    try:
        grade_section = request.args.get('grade_section', '')
        
        # Define grade mappings
        grade_mappings = {
            '1-3': ['K', '1', '2', '3'],
            '4-6': ['4', '5', '6'],
            '7-9': ['7', '8', '9'],
            '10-12': ['10', '11', '12']
        }
        
        query = Student.query
        
        if grade_section and grade_section in grade_mappings:
            grades = grade_mappings[grade_section]
            query = query.filter(Student.grade_level.in_(grades))
        
        students = query.all()
        
        students_data = []
        for student in students:
            students_data.append({
                'id': student.id,
                'name': student.name,
                'email': student.email,
                'grade_level': getattr(student, 'grade_level', 'N/A'),
                'school_name': getattr(student, 'school_name', 'N/A'),
                'total_points': getattr(student, 'total_points', 0),
                'acard_balance': float(getattr(student, 'acard_balance', 0) or 0)
            })
        
        return jsonify({
            'students': students_data,
            'grade_section': grade_section,
            'total_count': len(students_data)
        }), 200
        
    except Exception as e:
        logger.error(f"Get students by grade error: {str(e)}")
        return jsonify({'error': 'Failed to fetch students'}), 500

# Get quiz-mas registrations for skill-based filtering
@app.route('/api/super-admin/quiz-mas-registrations', methods=['GET'])
@super_admin_required
def get_quiz_mas_registrations():
    """Get quiz-mas registrations to filter students by skills (workshop types)"""
    try:
        skill = request.args.get('skill', '')  # Video Editing, Graphics Design, Coding

        query = QuizMasRegistration.query

        # Filter by workshop/skill if provided
        if skill:
            query = query.filter(QuizMasRegistration.workshop.ilike(f'%{skill}%'))

        registrations = query.all()

        # Create a mapping of student names/emails to registration data
        registrations_data = []
        for reg in registrations:
            # Get all children from this registration
            children = []

            # Child 1
            if reg.child1_name:
                children.append({
                    'name': reg.child1_name,
                    'grade': reg.child1_grade,
                    'contact_value': reg.child1_contact_value,
                    'workshop': reg.workshop
                })

            # Child 2
            if reg.child2_name:
                children.append({
                    'name': reg.child2_name,
                    'grade': reg.child2_grade,
                    'contact_value': reg.child2_contact_value,
                    'workshop': reg.workshop
                })

            # Child 3
            if reg.child3_name:
                children.append({
                    'name': reg.child3_name,
                    'grade': reg.child3_grade,
                    'contact_value': reg.child3_contact_value,
                    'workshop': reg.workshop
                })

            registrations_data.append({
                'id': reg.id,
                'workshop': reg.workshop,
                'children': children,
                'created_at': reg.created_at.isoformat() if reg.created_at else None
            })

        return jsonify({
            'registrations': registrations_data,
            'skill': skill,
            'total_count': len(registrations_data)
        }), 200

    except Exception as e:
        logger.error(f"Get quiz-mas registrations error: {str(e)}")
        return jsonify({'error': 'Failed to fetch quiz-mas registrations'}), 500

# Add these endpoints to your Flask application

@app.route('/api/super-admin/resources', methods=['GET'])
@super_admin_required
def get_admin_resources():
    """Get all resources assigned to admins with filtering options - Super Admin Only"""
    try:
        # Get query parameters for filtering
        admin_id = request.args.get('admin_id')
        resource_type = request.args.get('resource_type')
        subject_category = request.args.get('subject_category')
        is_active = request.args.get('is_active')
        page = int(request.args.get('page', 1))
        per_page = min(int(request.args.get('per_page', 50)), 100)
        
        # Build the base query with joins
        query = db.session.query(AdminResource, Admin).join(
            Admin, AdminResource.admin_id == Admin.id
        ).filter(Admin.role != 'super_admin')  # Exclude super admin resources
        
        # Apply filters
        if admin_id:
            query = query.filter(AdminResource.admin_id == admin_id)
        
        if resource_type:
            query = query.filter(AdminResource.resource_type == resource_type)
        
        if subject_category:
            query = query.filter(AdminResource.subject_category == subject_category)
        
        if is_active is not None:
            active_bool = is_active.lower() == 'true'
            query = query.filter(AdminResource.is_active == active_bool)
        
        # Order by creation date (newest first)
        query = query.order_by(AdminResource.created_at.desc())
        
        # Paginate results
        total = query.count()
        results = query.offset((page - 1) * per_page).limit(per_page).all()
        
        # Format response
        resources = []
        for resource, admin in results:
            # Get creator info safely
            creator = None
            if resource.created_by:
                try:
                    creator = Admin.query.get(resource.created_by)
                except:
                    creator = None
            
            resource_data = {
                'id': resource.id,
                'admin_id': admin.id,
                'admin_name': admin.name,
                'grade_section': resource.grade_section or 'N/A',
                'resource_type': resource.resource_type,
                'resource_title': resource.resource_title,
                'subject_category': resource.subject_category or 'general',
                'description': resource.description or '',
                'resource_url': resource.resource_url or '',
                'task_file': resource.task_file or '',
                'is_active': resource.is_active,
                'created_at': resource.created_at.isoformat(),
                'updated_at': resource.created_at.isoformat(),  # Use created_at since updated_at doesn't exist
                'created_by': resource.created_by,
                'created_by_name': creator.name if creator else 'System'
            }
            resources.append(resource_data)
        
        return jsonify({
            'resources': resources,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'pages': (total + per_page - 1) // per_page
            },
            'filters_applied': {
                'admin_id': admin_id,
                'resource_type': resource_type,
                'subject_category': subject_category,
                'is_active': is_active
            },
            'success': True
        }), 200
        
    except Exception as e:
        logger.error(f"Error getting admin resources: {str(e)}")
        import traceback
        logger.error(f"Full traceback: {traceback.format_exc()}")
        return jsonify({
            'error': f'Failed to get resources: {str(e)}',
            'success': False
        }), 500
        
@app.route('/api/super-admin/resource/<int:resource_id>', methods=['GET'])
@super_admin_required
def get_admin_resource_details(resource_id):
    """Get detailed information about a specific resource - Super Admin Only"""
    try:
        # Get the resource with admin and creator info
        result = db.session.query(AdminResource, Admin).join(
            Admin, AdminResource.admin_id == Admin.id
        ).filter(AdminResource.id == resource_id).first()
        
        if not result:
            return jsonify({'error': 'Resource not found'}), 404
        
        resource, admin = result
        
        # Get creator info
        creator = Admin.query.get(resource.created_by) if resource.created_by else None
        
        # Get usage statistics (if you track resource usage)
        # You might want to add a table to track when resources are used in tasks
        usage_count = db.session.query(StudentTask).filter(
            StudentTask.task_data.contains(f'"resource_id": {resource.id}')
        ).count()
        
        resource_data = {
            'id': resource.id,
            'admin_id': admin.id,
            'admin_name': admin.name,
            'admin_email': admin.email,
            'grade_section': resource.grade_section,
            'resource_type': resource.resource_type,
            'resource_title': resource.resource_title,
            'subject_category': resource.subject_category,
            'description': resource.description,
            'resource_url': resource.resource_url,
            'task_file': resource.task_file,
            'is_active': resource.is_active,
            'created_at': resource.created_at.isoformat(),
            'updated_at': resource.updated_at.isoformat() if resource.updated_at else resource.created_at.isoformat(),
            'created_by': resource.created_by,
            'created_by_name': creator.name if creator else 'Unknown',
            'usage_count': usage_count
        }
        
        return jsonify({
            'resource': resource_data,
            'success': True
        }), 200
        
    except Exception as e:
        logger.error(f"Error getting resource details: {str(e)}")
        return jsonify({
            'error': f'Failed to get resource details: {str(e)}',
            'success': False
        }), 500

@app.route('/api/super-admin/resource/<int:resource_id>', methods=['PUT'])
@super_admin_required
def update_admin_resource(resource_id):
    """Update a resource assigned to an admin - Super Admin Only"""
    try:
        data = request.get_json()
        
        # Get the resource
        resource = AdminResource.query.get(resource_id)
        if not resource:
            return jsonify({'error': 'Resource not found'}), 404
        
        # Validate required fields
        if not data.get('resource_title') or not data.get('resource_type') or not data.get('subject_category'):
            return jsonify({'error': 'resource_title, resource_type, and subject_category are required'}), 400
        
        # Update basic fields
        resource.resource_title = data['resource_title']
        resource.resource_type = data['resource_type']
        resource.subject_category = data['subject_category']
        resource.description = data.get('description', '')
        resource.is_active = data.get('is_active', True)
        resource.updated_at = datetime.utcnow()
        
        # Handle type-specific fields
        if data['resource_type'] == 'internal_file':
            task_file = data.get('task_file', '').strip()
            if not task_file:
                return jsonify({'error': 'task_file is required for internal_file type'}), 400
            resource.task_file = task_file
            resource.resource_url = f"https://deciph.ai.deciphersacad.online/{task_file}"
        else:
            resource_url = data.get('resource_url', '').strip()
            if not resource_url:
                return jsonify({'error': 'resource_url is required for external/common link types'}), 400
            resource.resource_url = resource_url
            resource.task_file = None  # Clear task_file for non-internal types
        
        db.session.commit()
        
        # Get updated resource with admin info
        result = db.session.query(AdminResource, Admin).join(
            Admin, AdminResource.admin_id == Admin.id
        ).filter(AdminResource.id == resource_id).first()
        
        resource, admin = result
        creator = Admin.query.get(resource.created_by) if resource.created_by else None
        
        resource_data = {
            'id': resource.id,
            'admin_id': admin.id,
            'admin_name': admin.name,
            'grade_section': resource.grade_section,
            'resource_type': resource.resource_type,
            'resource_title': resource.resource_title,
            'subject_category': resource.subject_category,
            'description': resource.description,
            'resource_url': resource.resource_url,
            'task_file': resource.task_file,
            'is_active': resource.is_active,
            'updated_at': resource.updated_at.isoformat(),
            'created_by_name': creator.name if creator else 'Unknown'
        }
        
        logger.info(f"Super admin {request.current_admin.id} updated resource {resource_id}")
        
        return jsonify({
            'message': 'Resource updated successfully',
            'resource': resource_data,
            'success': True
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error updating resource: {str(e)}")
        return jsonify({
            'error': f'Failed to update resource: {str(e)}',
            'success': False
        }), 500

@app.route('/api/super-admin/resource/<int:resource_id>', methods=['DELETE'])
@super_admin_required
def delete_admin_resource(resource_id):
    """Delete a resource assigned to an admin - Super Admin Only"""
    try:
        # Get the resource
        resource = AdminResource.query.get(resource_id)
        if not resource:
            return jsonify({'error': 'Resource not found'}), 404
        
        # Get admin info for logging
        admin = Admin.query.get(resource.admin_id)
        admin_name = admin.name if admin else 'Unknown Admin'
        resource_title = resource.resource_title
        
        # Check if resource is being used in any active tasks
        active_tasks = db.session.query(StudentTask).filter(
            StudentTask.task_data.contains(f'"resource_id": {resource.id}'),
            StudentTask.status.in_(['pending', 'in_progress'])
        ).count()
        
        if active_tasks > 0:
            return jsonify({
                'error': f'Cannot delete resource. It is currently being used in {active_tasks} active task(s)',
                'active_tasks': active_tasks
            }), 400
        
        # Soft delete or hard delete based on preference
        # For audit purposes, you might want to do a soft delete:
        resource.is_active = False
        resource.deleted_at = datetime.utcnow()
        resource.deleted_by = request.current_admin.id
        
        # Or for hard delete, uncomment this:
        # db.session.delete(resource)
        
        db.session.commit()
        
        logger.info(f"Super admin {request.current_admin.id} deleted resource {resource_id} ({resource_title}) from admin {admin_name}")
        
        return jsonify({
            'message': f'Resource "{resource_title}" deleted successfully',
            'deleted_resource': {
                'id': resource_id,
                'title': resource_title,
                'admin_name': admin_name
            },
            'success': True
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error deleting resource: {str(e)}")
        return jsonify({
            'error': f'Failed to delete resource: {str(e)}',
            'success': False
        }), 500

@app.route('/api/super-admin/resource/<int:resource_id>/toggle-status', methods=['PUT'])
@super_admin_required
def toggle_resource_status(resource_id):
    """Toggle the active status of a resource - Super Admin Only"""
    try:
        resource = AdminResource.query.get(resource_id)
        if not resource:
            return jsonify({'error': 'Resource not found'}), 404
        
        # Toggle the status
        resource.is_active = not resource.is_active
        resource.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        status = 'activated' if resource.is_active else 'deactivated'
        
        return jsonify({
            'message': f'Resource {status} successfully',
            'resource_id': resource_id,
            'is_active': resource.is_active,
            'success': True
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error toggling resource status: {str(e)}")
        return jsonify({
            'error': f'Failed to toggle resource status: {str(e)}',
            'success': False
        }), 500

# Optional: Bulk operations endpoint
@app.route('/api/super-admin/resources/bulk-action', methods=['POST'])
@super_admin_required
def bulk_resource_action():
    """Perform bulk actions on resources - Super Admin Only"""
    try:
        data = request.get_json()
        
        if not data.get('resource_ids') or not data.get('action'):
            return jsonify({'error': 'resource_ids and action are required'}), 400
        
        resource_ids = data['resource_ids']
        action = data['action']
        
        if action not in ['activate', 'deactivate', 'delete']:
            return jsonify({'error': 'Invalid action. Must be activate, deactivate, or delete'}), 400
        
        # Get resources
        resources = AdminResource.query.filter(AdminResource.id.in_(resource_ids)).all()
        
        if not resources:
            return jsonify({'error': 'No resources found'}), 404
        
        affected_count = 0
        
        for resource in resources:
            if action == 'activate':
                resource.is_active = True
                resource.updated_at = datetime.utcnow()
                affected_count += 1
            elif action == 'deactivate':
                resource.is_active = False
                resource.updated_at = datetime.utcnow()
                affected_count += 1
            elif action == 'delete':
                # Check if resource is in use
                active_tasks = db.session.query(StudentTask).filter(
                    StudentTask.task_data.contains(f'"resource_id": {resource.id}'),
                    StudentTask.status.in_(['pending', 'in_progress'])
                ).count()
                
                if active_tasks == 0:
                    resource.is_active = False
                    resource.deleted_at = datetime.utcnow()
                    resource.deleted_by = request.current_admin.id
                    affected_count += 1
        
        db.session.commit()
        
        return jsonify({
            'message': f'Bulk {action} completed successfully',
            'affected_resources': affected_count,
            'total_requested': len(resource_ids),
            'success': True
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error in bulk resource action: {str(e)}")
        return jsonify({
            'error': f'Failed to perform bulk action: {str(e)}',
            'success': False
        }), 500
    
# Student Registration Endpoint
@app.route('/api/student/register', methods=['POST', 'OPTIONS'])
def student_register():
    if request.method == 'OPTIONS':
        return '', 204
        
    try:
        logger.debug(f"Received student registration request: {request.get_json()}")
        
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400
            
        # Validate required fields
        required_fields = ['name', 'email', 'password', 'age', 'grade_level', 'school_name']
        missing_fields = [field for field in required_fields if field not in data]
        if missing_fields:
            return jsonify({'error': f'Missing required fields: {", ".join(missing_fields)}'}), 400
            
        # Check if student already exists
        if Student.query.filter_by(email=data['email']).first():
            return jsonify({'error': 'Email already registered'}), 400
        
        # Validate age
        try:
            age = int(data['age'])
            if age < 5 or age > 18:
                return jsonify({'error': 'Age must be between 5 and 18'}), 400
        except ValueError:
            return jsonify({'error': 'Invalid age format'}), 400
            
        # Validate grade level
        valid_grades = ['K', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']
        if data['grade_level'] not in valid_grades:
            return jsonify({'error': 'Invalid grade level'}), 400
        
        # Generate verification token (optional for students)
        verification_token, token_expiry = generate_verification_token()
            
        # Create new student
        new_student = Student(
            name=data['name'],
            email=data['email'],
            password_hash=generate_password_hash(data['password']),
            age=age,
            grade_level=data['grade_level'],
            school_name=data['school_name'],
            is_active=True,
            auth_provider='email',
            email_verified=True,  # For students, we can auto-verify or make it optional
            verification_token=verification_token,
            verification_token_expires=token_expiry
        )
        
        db.session.add(new_student)
        db.session.commit()
        
        # Generate JWT token for immediate login
        token = jwt.encode(
            {'student_id': new_student.id, 'exp': datetime.utcnow() + timedelta(days=7)},
            JWT_SECRET_KEY,
            algorithm='HS256'
        )
        
        return jsonify({
            'message': 'Student registration successful!',
            'token': token,
            'user': {
                'id': new_student.id,
                'name': new_student.name,
                'email': new_student.email,
                'age': new_student.age,
                'grade_level': new_student.grade_level,
                'school_name': new_student.school_name,
                'total_points': new_student.total_points,
                'current_level': new_student.current_level
            }
        }), 201
        
    except Exception as e:
        logger.error(f"Student registration error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/tutor-signup', methods=['POST'])
def tutor_signup():
    try:
        # Get JSON data from form
        data_json = request.form.get('data')
        if not data_json:
            return jsonify({'error': 'No data provided'}), 400
        
        try:
            data = json.loads(data_json)
        except json.JSONDecodeError:
            return jsonify({'error': 'Invalid JSON data'}), 400
        
        # Validate required fields
        required_fields = [
            'firstName', 'lastName', 'email', 'phone', 'dateOfBirth', 
            'country', 'timezone', 'password', 'subjects', 'education', 
            'bio', 'motivation', 'terms'
        ]
        
        missing_fields = []
        for field in required_fields:
            if field not in data or not data[field]:
                missing_fields.append(field)
        
        if missing_fields:
            return jsonify({
                'error': 'Missing required fields',
                'missing_fields': missing_fields
            }), 400
        
        # Validate email format
        try:
            email_validation = validate_email(data['email'])
            validated_email = email_validation.email
        except EmailNotValidError:
            return jsonify({'error': 'Invalid email address format'}), 400
        
        # Check if email already exists
        existing_tutor = Tutor.query.filter_by(email=validated_email).first()
        if existing_tutor:
            return jsonify({'error': 'Email address already registered'}), 409
        
        # Validate age (must be 18+)
        if not validate_age(data['dateOfBirth']):
            return jsonify({'error': 'You must be at least 18 years old to apply'}), 400
        
        # Validate phone number
        if not validate_phone(data['phone']):
            return jsonify({'error': 'Invalid phone number format'}), 400
        
        # Validate password strength
        password_valid, password_message = validate_password_strength(data['password'])
        if not password_valid:
            return jsonify({'error': password_message}), 400
        
        # Validate subjects (at least one must be selected)
        if not data['subjects'] or len(data['subjects']) == 0:
            return jsonify({'error': 'Please select at least one subject to teach'}), 400
        
        # Validate bio length
        if len(data['bio'].strip()) < 50:
            return jsonify({'error': 'Bio must be at least 50 characters long'}), 400
        
        # Validate terms acceptance
        if not data['terms']:
            return jsonify({'error': 'You must agree to the terms and conditions'}), 400
        
        # Handle file upload (resume)
        resume_filename = None
        if 'resume' in request.files:
            file = request.files['resume']
            if file and file.filename != '':
                if allowed_file(file.filename):
                    # Check file size
                    file.seek(0, os.SEEK_END)
                    file_size = file.tell()
                    file.seek(0)
                    
                    if file_size > MAX_FILE_SIZE:
                        return jsonify({'error': 'Resume file size must be less than 5MB'}), 400
                    
                    # Create unique filename
                    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                    safe_filename = secure_filename(file.filename)
                    resume_filename = f"{timestamp}_{data['firstName']}_{data['lastName']}_{safe_filename}"
                    
                    # Ensure upload directory exists
                    os.makedirs(UPLOAD_FOLDER, exist_ok=True)
                    
                    # Save file
                    file_path = os.path.join(UPLOAD_FOLDER, resume_filename)
                    file.save(file_path)
                    
                    logger.info(f"Resume uploaded: {resume_filename}")
                else:
                    return jsonify({'error': 'Invalid file type. Only PDF, DOC, and DOCX files are allowed'}), 400
        
        # Hash password
        password_hash = generate_password_hash(data['password'])
        
        # Parse date of birth
        try:
            date_of_birth = datetime.strptime(data['dateOfBirth'], '%Y-%m-%d')
        except ValueError:
            return jsonify({'error': 'Invalid date of birth format'}), 400
        
        # Create new tutor record
        try:
            new_tutor = Tutor(
                first_name=data['firstName'].strip(),
                last_name=data['lastName'].strip(),
                email=validated_email,
                phone=data['phone'].strip(),
                date_of_birth=date_of_birth,
                country=data['country'],
                timezone=data['timezone'],
                password_hash=password_hash,
                subjects=data['subjects'],
                education_level=data['education'],
                teaching_experience=data.get('experience', 'none'),
                bio=data['bio'].strip(),
                schedule_preferences=data.get('schedule', []),
                motivation=data['motivation'].strip(),
                resume_filename=resume_filename,
                application_status='pending',
                email_verified=False,
                created_at=datetime.utcnow()
            )
            
            db.session.add(new_tutor)
            db.session.commit()
            
            logger.info(f"New tutor application submitted: {validated_email}")
            
            # Send confirmation email (implement this function)
            try:
                send_tutor_confirmation_email(new_tutor)
            except Exception as email_error:
                logger.error(f"Failed to send confirmation email: {str(email_error)}")
                # Don't fail the registration if email fails
            
            # Send notification to admin (implement this function)
            try:
                send_admin_notification_email(new_tutor)
            except Exception as admin_email_error:
                logger.error(f"Failed to send admin notification: {str(admin_email_error)}")
            
            return jsonify({
                'message': 'Application submitted successfully',
                'tutor_id': new_tutor.id,
                'status': 'pending_review',
                'next_steps': [
                    'Check your email for confirmation',
                    'We will review your application within 24-48 hours',
                    'Complete subject assessment if approved',
                    'Attend onboarding session'
                ]
            }), 201
            
        except Exception as db_error:
            db.session.rollback()
            logger.error(f"Database error during tutor registration: {str(db_error)}")
            return jsonify({
                'error': 'Database error during registration',
                'details': str(db_error)
            }), 500
            
    except Exception as e:
        logger.error(f"Tutor signup error: {str(e)}")
        return jsonify({
            'error': 'Registration failed',
            'details': str(e)
        }), 500

def send_tutor_confirmation_email(tutor):
    """Send confirmation email to the new tutor applicant"""
    # Implement email sending logic here
    # This could use Flask-Mail, SendGrid, AWS SES, etc.
    pass

def send_admin_notification_email(tutor):
    """Send notification to admin about new tutor application"""
    # Implement admin notification logic here
    pass

# Additional endpoint to check application status
@app.route('/api/tutor-application-status/<int:tutor_id>', methods=['GET'])
def get_tutor_application_status(tutor_id):
    try:
        tutor = Tutor.query.get(tutor_id)
        if not tutor:
            return jsonify({'error': 'Application not found'}), 404
        
        return jsonify({
            'status': tutor.application_status,
            'email_verified': tutor.email_verified,
            'assessment_completed': tutor.assessment_completed,
            'onboarding_completed': tutor.onboarding_completed,
            'created_at': tutor.created_at.isoformat(),
            'updated_at': tutor.updated_at.isoformat() if tutor.updated_at else None
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching application status: {str(e)}")
        return jsonify({'error': 'Failed to fetch application status'}), 500



# Admin login endpoint
@app.route('/api/tutor-admin/login', methods=['POST'])
def tutor_admin_login():
    try:
        data = request.get_json()
        if not data or 'email' not in data or 'password' not in data:
            return jsonify({'error': 'Email and password are required'}), 400
        
        # For now, use a simple admin check - replace with proper Admin model
        # admin = Admin.query.filter_by(email=data['email']).first()
        
        # Temporary hardcoded admin for testing
        if data['email'] == 'admin@decipheracademy.com' and data['password'] == 'admin123':
            token = jwt.encode(
                {
                    'admin_id': 1,
                    'email': data['email'],
                    'exp': datetime.utcnow() + timedelta(hours=8)
                },
                JWT_SECRET_KEY,
                algorithm='HS256'
            )
            
            return jsonify({
                'token': token,
                'admin': {
                    'id': 1,
                    'email': data['email'],
                    'name': 'Admin User'
                }
            }), 200
        else:
            return jsonify({'error': 'Invalid credentials'}), 401
            
    except Exception as e:
        logger.error(f"Admin login error: {str(e)}")
        return jsonify({'error': 'Login failed'}), 500

# Get tutor application statistics
@app.route('/api/admin/tutor-statistics', methods=['GET'])
@admin_required
def get_tutor_statistics():
    try:
        # Get counts by status
        stats = db.session.query(
            Tutor.application_status,
            func.count(Tutor.id).label('count')
        ).group_by(Tutor.application_status).all()
        
        # Convert to dictionary
        status_counts = {status: count for status, count in stats}
        
        # Get total count
        total_count = db.session.query(func.count(Tutor.id)).scalar()
        
        # Get applications from last 30 days
        thirty_days_ago = datetime.utcnow() - timedelta(days=30)
        recent_count = db.session.query(func.count(Tutor.id)).filter(
            Tutor.created_at >= thirty_days_ago
        ).scalar()
        
        # Get applications from today
        today_start = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
        today_count = db.session.query(func.count(Tutor.id)).filter(
            Tutor.created_at >= today_start
        ).scalar()
        
        return jsonify({
            'total': total_count,
            'pending': status_counts.get('pending', 0),
            'approved': status_counts.get('approved', 0),
            'rejected': status_counts.get('rejected', 0),
            'under_review': status_counts.get('under_review', 0),
            'recent_30_days': recent_count,
            'today': today_count
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching tutor statistics: {str(e)}")
        return jsonify({'error': 'Failed to fetch statistics'}), 500

# Get detailed tutor application
@app.route('/api/admin/tutor-application/<int:tutor_id>', methods=['GET'])
@admin_required
def get_tutor_application_detail(tutor_id):
    try:
        tutor = Tutor.query.get(tutor_id)
        if not tutor:
            return jsonify({'error': 'Tutor not found'}), 404
        
        # Convert to detailed dictionary
        tutor_data = {
            'id': tutor.id,
            'first_name': tutor.first_name,
            'last_name': tutor.last_name,
            'email': tutor.email,
            'phone': tutor.phone,
            'date_of_birth': tutor.date_of_birth.isoformat() if tutor.date_of_birth else None,
            'country': tutor.country,
            'timezone': tutor.timezone,
            'subjects': tutor.subjects,
            'education_level': tutor.education_level,
            'teaching_experience': tutor.teaching_experience,
            'bio': tutor.bio,
            'schedule_preferences': tutor.schedule_preferences or [],
            'motivation': tutor.motivation,
            'application_status': tutor.application_status,
            'resume_filename': tutor.resume_filename,
            'email_verified': tutor.email_verified,
            'assessment_completed': tutor.assessment_completed,
            'assessment_score': tutor.assessment_score,
            'onboarding_completed': tutor.onboarding_completed,
            'created_at': tutor.created_at.isoformat(),
            'updated_at': tutor.updated_at.isoformat() if tutor.updated_at else None
        }
        
        return jsonify(tutor_data), 200
        
    except Exception as e:
        logger.error(f"Error fetching tutor application detail: {str(e)}")
        return jsonify({'error': 'Failed to fetch application details'}), 500

# Enhanced tutor applications endpoint with filtering
@app.route('/api/admin/tutor-applications', methods=['GET'])
@admin_required
def get_tutor_applications_enhanced():
    try:
        # Get query parameters
        status_filter = request.args.get('status', '')
        subject_filter = request.args.get('subject', '')
        date_filter = request.args.get('date', '')
        search_filter = request.args.get('search', '')
        page = int(request.args.get('page', 1))
        per_page = min(int(request.args.get('per_page', 20)), 100)  # Limit to max 100
        
        # Build query
        query = Tutor.query
        
        # Apply filters
        if status_filter:
            query = query.filter(Tutor.application_status == status_filter)
        
        if subject_filter:
            # Filter by subject (JSON array contains)
            query = query.filter(Tutor.subjects.contains([subject_filter]))
        
        if date_filter:
            try:
                filter_date = datetime.strptime(date_filter, '%Y-%m-%d')
                query = query.filter(func.date(Tutor.created_at) == filter_date.date())
            except ValueError:
                pass  # Invalid date format, ignore filter
        
        if search_filter:
            search_term = f"%{search_filter}%"
            query = query.filter(
                or_(
                    Tutor.first_name.ilike(search_term),
                    Tutor.last_name.ilike(search_term),
                    Tutor.email.ilike(search_term)
                )
            )
        
        # Order by creation date (newest first)
        query = query.order_by(Tutor.created_at.desc())
        
        # Paginate
        tutors = query.paginate(
            page=page,
            per_page=per_page,
            error_out=False
        )
        
        # Convert to list of dictionaries
        applications = []
        for tutor in tutors.items:
            applications.append({
                'id': tutor.id,
                'first_name': tutor.first_name,
                'last_name': tutor.last_name,
                'email': tutor.email,
                'phone': tutor.phone,
                'country': tutor.country,
                'subjects': tutor.subjects,
                'education_level': tutor.education_level,
                'teaching_experience': tutor.teaching_experience,
                'application_status': tutor.application_status,
                'email_verified': tutor.email_verified,
                'resume_filename': tutor.resume_filename,
                'created_at': tutor.created_at.isoformat(),
                'updated_at': tutor.updated_at.isoformat() if tutor.updated_at else None
            })
        
        return jsonify({
            'applications': applications,
            'total': tutors.total,
            'pages': tutors.pages,
            'current_page': page,
            'per_page': per_page,
            'has_next': tutors.has_next,
            'has_prev': tutors.has_prev
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching tutor applications: {str(e)}")
        return jsonify({'error': 'Failed to fetch applications'}), 500

# Bulk update tutor application statuses
@app.route('/api/admin/tutor-applications/bulk-update', methods=['PUT'])
@admin_required
def bulk_update_tutor_status():
    try:
        data = request.get_json()
        if not data or 'tutor_ids' not in data or 'status' not in data:
            return jsonify({'error': 'tutor_ids and status are required'}), 400
        
        tutor_ids = data['tutor_ids']
        new_status = data['status']
        
        # Validate status
        valid_statuses = ['pending', 'approved', 'rejected', 'under_review']
        if new_status not in valid_statuses:
            return jsonify({'error': 'Invalid status'}), 400
        
        # Validate tutor_ids
        if not isinstance(tutor_ids, list) or len(tutor_ids) == 0:
            return jsonify({'error': 'tutor_ids must be a non-empty list'}), 400
        
        # Update tutors
        updated_count = db.session.query(Tutor).filter(
            Tutor.id.in_(tutor_ids)
        ).update(
            {
                'application_status': new_status,
                'updated_at': datetime.utcnow()
            },
            synchronize_session=False
        )
        
        db.session.commit()
        
        # Send notifications to affected tutors
        try:
            tutors = Tutor.query.filter(Tutor.id.in_(tutor_ids)).all()
            for tutor in tutors:
                send_status_update_email(tutor, new_status)
        except Exception as email_error:
            logger.error(f"Failed to send bulk status update emails: {str(email_error)}")
        
        logger.info(f"Bulk updated {updated_count} tutor applications to status: {new_status}")
        
        return jsonify({
            'message': f'Successfully updated {updated_count} applications',
            'updated_count': updated_count,
            'status': new_status
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error in bulk update: {str(e)}")
        return jsonify({'error': 'Failed to update applications'}), 500

# Export tutor applications to CSV
@app.route('/api/admin/tutor-applications/export', methods=['GET'])
@admin_required
def export_tutor_applications():
    try:
        # Get all tutors with optional filtering
        status_filter = request.args.get('status', '')
        
        query = Tutor.query
        if status_filter:
            query = query.filter(Tutor.application_status == status_filter)
        
        tutors = query.order_by(Tutor.created_at.desc()).all()
        
        # Create CSV in memory
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Write header
        headers = [
            'ID', 'First Name', 'Last Name', 'Email', 'Phone', 'Country',
            'Date of Birth', 'Timezone', 'Education Level', 'Teaching Experience',
            'Subjects', 'Application Status', 'Email Verified', 'Resume Uploaded',
            'Assessment Completed', 'Assessment Score', 'Onboarding Completed',
            'Bio Preview', 'Applied Date', 'Last Updated'
        ]
        writer.writerow(headers)
        
        # Write data rows
        for tutor in tutors:
            row = [
                tutor.id,
                tutor.first_name,
                tutor.last_name,
                tutor.email,
                tutor.phone,
                tutor.country,
                tutor.date_of_birth.strftime('%Y-%m-%d') if tutor.date_of_birth else '',
                tutor.timezone,
                tutor.education_level,
                tutor.teaching_experience or '',
                ', '.join(tutor.subjects) if tutor.subjects else '',
                tutor.application_status,
                'Yes' if tutor.email_verified else 'No',
                'Yes' if tutor.resume_filename else 'No',
                'Yes' if tutor.assessment_completed else 'No',
                tutor.assessment_score or '',
                'Yes' if tutor.onboarding_completed else 'No',
                tutor.bio[:100] + '...' if len(tutor.bio) > 100 else tutor.bio,
                tutor.created_at.strftime('%Y-%m-%d %H:%M:%S'),
                tutor.updated_at.strftime('%Y-%m-%d %H:%M:%S') if tutor.updated_at else ''
            ]
            writer.writerow(row)
        
        # Prepare file for download
        output.seek(0)
        
        # Create a BytesIO object for the response
        csv_data = output.getvalue()
        output.close()
        
        # Create filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f'tutor_applications_{timestamp}.csv'
        
        # Return CSV file
        return app.response_class(
            csv_data,
            mimetype='text/csv',
            headers={'Content-Disposition': f'attachment; filename={filename}'}
        )
        
    except Exception as e:
        logger.error(f"Error exporting tutor applications: {str(e)}")
        return jsonify({'error': 'Failed to export data'}), 500

# Get tutor application analytics
@app.route('/api/admin/tutor-analytics', methods=['GET'])
@admin_required
def get_tutor_analytics():
    try:
        # Applications by month (last 12 months)
        twelve_months_ago = datetime.utcnow() - timedelta(days=365)
        monthly_apps = db.session.query(
            func.date_trunc('month', Tutor.created_at).label('month'),
            func.count(Tutor.id).label('count')
        ).filter(
            Tutor.created_at >= twelve_months_ago
        ).group_by(
            func.date_trunc('month', Tutor.created_at)
        ).order_by('month').all()
        
        # Applications by subject
        subject_counts = {}
        tutors = Tutor.query.all()
        for tutor in tutors:
            if tutor.subjects:
                for subject in tutor.subjects:
                    subject_counts[subject] = subject_counts.get(subject, 0) + 1
        
        # Applications by education level
        education_stats = db.session.query(
            Tutor.education_level,
            func.count(Tutor.id).label('count')
        ).group_by(Tutor.education_level).all()
        
        # Applications by country
        country_stats = db.session.query(
            Tutor.country,
            func.count(Tutor.id).label('count')
        ).group_by(Tutor.country).order_by(func.count(Tutor.id).desc()).limit(10).all()
        
        # Approval rate
        total_processed = db.session.query(func.count(Tutor.id)).filter(
            Tutor.application_status.in_(['approved', 'rejected'])
        ).scalar()
        
        approved_count = db.session.query(func.count(Tutor.id)).filter(
            Tutor.application_status == 'approved'
        ).scalar()
        
        approval_rate = (approved_count / total_processed * 100) if total_processed > 0 else 0
        
        return jsonify({
            'monthly_applications': [
                {
                    'month': month.strftime('%Y-%m'),
                    'count': count
                } for month, count in monthly_apps
            ],
            'subject_distribution': [
                {
                    'subject': subject,
                    'count': count
                } for subject, count in sorted(subject_counts.items(), key=lambda x: x[1], reverse=True)
            ],
            'education_distribution': [
                {
                    'level': level,
                    'count': count
                } for level, count in education_stats
            ],
            'country_distribution': [
                {
                    'country': country,
                    'count': count
                } for country, count in country_stats
            ],
            'approval_rate': round(approval_rate, 2),
            'total_processed': total_processed,
            'approved_count': approved_count
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching tutor analytics: {str(e)}")
        return jsonify({'error': 'Failed to fetch analytics'}), 500

# Send reminder emails to pending applications
@app.route('/api/admin/tutor-applications/send-reminders', methods=['POST'])
@admin_required
def send_application_reminders():
    try:
        data = request.get_json()
        days_old = data.get('days_old', 3)  # Default to applications older than 3 days
        
        cutoff_date = datetime.utcnow() - timedelta(days=days_old)
        
        # Find pending applications older than specified days
        pending_tutors = Tutor.query.filter(
            and_(
                Tutor.application_status == 'pending',
                Tutor.created_at <= cutoff_date,
                Tutor.email_verified == True  # Only send to verified emails
            )
        ).all()
        
        sent_count = 0
        failed_count = 0
        
        for tutor in pending_tutors:
            try:
                send_application_reminder_email(tutor)
                sent_count += 1
            except Exception as email_error:
                logger.error(f"Failed to send reminder to {tutor.email}: {str(email_error)}")
                failed_count += 1
        
        return jsonify({
            'message': f'Reminder emails processed',
            'sent': sent_count,
            'failed': failed_count,
            'total_pending': len(pending_tutors)
        }), 200
        
    except Exception as e:
        logger.error(f"Error sending reminder emails: {str(e)}")
        return jsonify({'error': 'Failed to send reminder emails'}), 500

# Get tutor application timeline/audit log
@app.route('/api/admin/tutor-application/<int:tutor_id>/timeline', methods=['GET'])
@admin_required
def get_tutor_application_timeline(tutor_id):
    """Get timeline of status changes and actions for a tutor application"""
    try:
        tutor = Tutor.query.get(tutor_id)
        if not tutor:
            return jsonify({'error': 'Tutor not found'}), 404
        
        # This would require an audit log table - for now return basic timeline
        timeline = [
            {
                'date': tutor.created_at.isoformat(),
                'action': 'Application Submitted',
                'status': 'pending',
                'description': 'Tutor submitted their application',
                'user': 'System'
            }
        ]
        
        if tutor.email_verified:
            timeline.append({
                'date': tutor.created_at.isoformat(),  # This should be actual verification date
                'action': 'Email Verified',
                'status': 'verified',
                'description': 'Email address verified',
                'user': 'System'
            })
        
        if tutor.application_status != 'pending':
            timeline.append({
                'date': tutor.updated_at.isoformat() if tutor.updated_at else tutor.created_at.isoformat(),
                'action': f'Status Changed to {tutor.application_status.title()}',
                'status': tutor.application_status,
                'description': f'Application status updated to {tutor.application_status}',
                'user': 'Admin'
            })
        
        if tutor.assessment_completed:
            timeline.append({
                'date': tutor.updated_at.isoformat() if tutor.updated_at else tutor.created_at.isoformat(),
                'action': 'Assessment Completed',
                'status': 'assessment_complete',
                'description': f'Subject assessment completed with score: {tutor.assessment_score}',
                'user': tutor.first_name + ' ' + tutor.last_name
            })
        
        if tutor.onboarding_completed:
            timeline.append({
                'date': tutor.updated_at.isoformat() if tutor.updated_at else tutor.created_at.isoformat(),
                'action': 'Onboarding Completed',
                'status': 'onboarding_complete',
                'description': 'Tutor completed onboarding process',
                'user': tutor.first_name + ' ' + tutor.last_name
            })
        
        # Sort timeline by date
        timeline.sort(key=lambda x: x['date'])
        
        return jsonify({
            'tutor_id': tutor_id,
            'tutor_name': f"{tutor.first_name} {tutor.last_name}",
            'timeline': timeline
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching application timeline: {str(e)}")
        return jsonify({'error': 'Failed to fetch timeline'}), 500

# Add notes to tutor application
@app.route('/api/admin/tutor-application/<int:tutor_id>/notes', methods=['POST'])
@admin_required
def add_tutor_note(tutor_id):
    """Add administrative notes to a tutor application"""
    try:
        data = request.get_json()
        if not data or 'note' not in data:
            return jsonify({'error': 'Note content is required'}), 400
        
        tutor = Tutor.query.get(tutor_id)
        if not tutor:
            return jsonify({'error': 'Tutor not found'}), 404
        
        # This would require a separate notes table - for now we'll simulate
        note_data = {
            'id': 1,  # Would be auto-generated
            'tutor_id': tutor_id,
            'admin_id': request.admin_id,
            'note': data['note'],
            'created_at': datetime.utcnow().isoformat(),
            'created_by': 'Admin User'  # Would fetch from admin table
        }
        
        # In a real implementation, save to notes table:
        # new_note = TutorNote(
        #     tutor_id=tutor_id,
        #     admin_id=request.admin_id,
        #     note=data['note'],
        #     created_at=datetime.utcnow()
        # )
        # db.session.add(new_note)
        # db.session.commit()
        
        logger.info(f"Note added to tutor {tutor_id} by admin {request.admin_id}")
        
        return jsonify({
            'message': 'Note added successfully',
            'note': note_data
        }), 201
        
    except Exception as e:
        logger.error(f"Error adding note: {str(e)}")
        return jsonify({'error': 'Failed to add note'}), 500

# Get dashboard summary
@app.route('/api/admin/dashboard-summary', methods=['GET'])
@admin_required
def get_dashboard_summary():
    """Get comprehensive dashboard summary for admin overview"""
    try:
        # Recent activity (last 7 days)
        week_ago = datetime.utcnow() - timedelta(days=7)
        
        recent_applications = db.session.query(func.count(Tutor.id)).filter(
            Tutor.created_at >= week_ago
        ).scalar()
        
        recent_approvals = db.session.query(func.count(Tutor.id)).filter(
            and_(
                Tutor.application_status == 'approved',
                Tutor.updated_at >= week_ago
            )
        ).scalar()
        
        # Pending actions
        pending_review = db.session.query(func.count(Tutor.id)).filter(
            Tutor.application_status == 'pending'
        ).scalar()
        
        under_review = db.session.query(func.count(Tutor.id)).filter(
            Tutor.application_status == 'under_review'
        ).scalar()
        
        # Subject demand (most applied for subjects)
        subject_demand = {}
        tutors = Tutor.query.filter(
            Tutor.created_at >= week_ago
        ).all()
        
        for tutor in tutors:
            if tutor.subjects:
                for subject in tutor.subjects:
                    subject_demand[subject] = subject_demand.get(subject, 0) + 1
        
        top_subjects = sorted(subject_demand.items(), key=lambda x: x[1], reverse=True)[:5]
        
        # Response time metrics (simulated)
        avg_response_time = 2.3  # days - would calculate from actual data
        
        return jsonify({
            'recent_activity': {
                'new_applications_7d': recent_applications,
                'approvals_7d': recent_approvals,
                'avg_response_time_days': avg_response_time
            },
            'pending_actions': {
                'pending_review': pending_review,
                'under_review': under_review,
                'total_requiring_action': pending_review + under_review
            },
            'subject_demand': {
                'top_subjects_7d': [
                    {'subject': subject, 'applications': count}
                    for subject, count in top_subjects
                ]
            },
            'performance_metrics': {
                'total_applications': db.session.query(func.count(Tutor.id)).scalar(),
                'approval_rate': 85.5,  # Would calculate from actual data
                'completion_rate': 78.2  # Would calculate from actual data
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching dashboard summary: {str(e)}")
        return jsonify({'error': 'Failed to fetch dashboard summary'}), 500

# Email template functions (implement these based on your email service)
def send_status_update_email(tutor, new_status):
    """Send email notification when application status changes"""
    try:
        # Email templates based on status
        templates = {
            'approved': {
                'subject': 'ðŸŽ‰ Congratulations! Your Decipher Academy Application is Approved',
                'body': f"""
                Dear {tutor.first_name},
                
                Great news! Your application to become a tutor with Decipher Academy has been approved.
                
                Next steps:
                1. Complete your subject assessment
                2. Attend the onboarding session
                3. Start teaching and earning!
                
                We'll be in touch with assessment details shortly.
                
                Welcome to the Decipher Academy team!
                """
            },
            'rejected': {
                'subject': 'Decipher Academy Application Update',
                'body': f"""
                Dear {tutor.first_name},
                
                Thank you for your interest in becoming a tutor with Decipher Academy.
                
                After careful review, we've decided not to move forward with your application at this time.
                This decision doesn't reflect on your abilities as an educator.
                
                You're welcome to reapply in the future as our needs evolve.
                
                Best regards,
                Decipher Academy Team
                """
            },
            'under_review': {
                'subject': 'Your Decipher Academy Application is Under Review',
                'body': f"""
                Dear {tutor.first_name},
                
                Thank you for your patience. Your application is currently under detailed review.
                
                We may contact you for additional information or clarification.
                
                We'll update you on the status within the next few days.
                
                Best regards,
                Decipher Academy Team
                """
            }
        }
        
        template = templates.get(new_status)
        if template:
            # Implement actual email sending here
            # send_email(tutor.email, template['subject'], template['body'])
            logger.info(f"Status update email sent to {tutor.email} for status: {new_status}")
            
    except Exception as e:
        logger.error(f"Failed to send status update email: {str(e)}")
        raise

def send_application_reminder_email(tutor):
    """Send reminder email for pending applications"""
    try:
        subject = "Decipher Academy - Application Update"
        body = f"""
        Dear {tutor.first_name},
        
        We wanted to follow up on your tutor application submitted on {tutor.created_at.strftime('%B %d, %Y')}.
        
        Your application is still under review. We appreciate your patience as we carefully 
        evaluate each application to maintain our high standards.
        
        If you have any questions or would like to provide additional information, 
        please don't hesitate to contact us.
        
        Best regards,
        Decipher Academy Team
        """
        
        # Implement actual email sending here
        # send_email(tutor.email, subject, body)
        logger.info(f"Reminder email sent to {tutor.email}")
        
    except Exception as e:
        logger.error(f"Failed to send reminder email: {str(e)}")
        raise

# Advanced search with autocomplete
@app.route('/api/admin/tutors/search-suggestions', methods=['GET'])
@admin_required
def get_search_suggestions():
    """Get search suggestions for tutor names and emails"""
    try:
        query = request.args.get('q', '').strip()
        if len(query) < 2:
            return jsonify({'suggestions': []}), 200
        
        # Search in names and emails
        search_term = f"%{query}%"
        suggestions = db.session.query(
            Tutor.first_name,
            Tutor.last_name,
            Tutor.email
        ).filter(
            or_(
                Tutor.first_name.ilike(search_term),
                Tutor.last_name.ilike(search_term),
                Tutor.email.ilike(search_term)
            )
        ).limit(10).all()
        
        # Format suggestions
        formatted_suggestions = []
        for first_name, last_name, email in suggestions:
            formatted_suggestions.extend([
                f"{first_name} {last_name}",
                email
            ])
        
        # Remove duplicates and limit
        unique_suggestions = list(set(formatted_suggestions))[:8]
        
        return jsonify({'suggestions': unique_suggestions}), 200
        
    except Exception as e:
        logger.error(f"Error fetching search suggestions: {str(e)}")
        return jsonify({'suggestions': []}), 200

# Batch operations for efficiency
@app.route('/api/admin/tutors/batch-export', methods=['POST'])
@admin_required
def batch_export_tutors():
    """Export specific tutors by IDs"""
    try:
        data = request.get_json()
        tutor_ids = data.get('tutor_ids', [])
        
        if not tutor_ids:
            return jsonify({'error': 'No tutor IDs provided'}), 400
        
        tutors = Tutor.query.filter(Tutor.id.in_(tutor_ids)).all()
        
        # Create CSV
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Headers
        headers = ['ID', 'Name', 'Email', 'Subjects', 'Status', 'Applied Date']
        writer.writerow(headers)
        
        # Data
        for tutor in tutors:
            writer.writerow([
                tutor.id,
                f"{tutor.first_name} {tutor.last_name}",
                tutor.email,
                ', '.join(tutor.subjects) if tutor.subjects else '',
                tutor.application_status,
                tutor.created_at.strftime('%Y-%m-%d')
            ])
        
        output.seek(0)
        csv_data = output.getvalue()
        output.close()
        
        return app.response_class(
            csv_data,
            mimetype='text/csv',
            headers={'Content-Disposition': 'attachment; filename=selected_tutors.csv'}
        )
        
    except Exception as e:
        logger.error(f"Error in batch export: {str(e)}")
        return jsonify({'error': 'Failed to export tutors'}), 500

# Endpoint for admin to review applications
@app.route('/api/admin/tutor-applications', methods=['GET'])
def get_tutor_applications():
    """Get all tutor applications for admin review - requires authentication"""
    try:
        # Add authentication check here
        # token = request.headers.get('Authorization')
        # if not verify_admin_token(token):
        #     return jsonify({'error': 'Unauthorized'}), 401
        
        status_filter = request.args.get('status', 'pending')
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 20))
        
        query = Tutor.query.filter_by(application_status=status_filter)
        tutors = query.paginate(
            page=page, 
            per_page=per_page, 
            error_out=False
        )
        
        return jsonify({
            'applications': [tutor.to_dict() for tutor in tutors.items],
            'total': tutors.total,
            'pages': tutors.pages,
            'current_page': page
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching tutor applications: {str(e)}")
        return jsonify({'error': 'Failed to fetch applications'}), 500

# Endpoint to update application status
@app.route('/api/admin/tutor-application/<int:tutor_id>/status', methods=['PUT'])
def update_tutor_application_status(tutor_id):
    """Update tutor application status - requires admin authentication"""
    try:
        # Add authentication check here
        
        data = request.get_json()
        if not data or 'status' not in data:
            return jsonify({'error': 'Status is required'}), 400
        
        valid_statuses = ['pending', 'approved', 'rejected', 'under_review']
        if data['status'] not in valid_statuses:
            return jsonify({'error': 'Invalid status'}), 400
        
        tutor = Tutor.query.get(tutor_id)
        if not tutor:
            return jsonify({'error': 'Tutor not found'}), 404
        
        tutor.application_status = data['status']
        tutor.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        # Send status update email to tutor
        try:
            send_status_update_email(tutor, data['status'])
        except Exception as email_error:
            logger.error(f"Failed to send status update email: {str(email_error)}")
        
        return jsonify({
            'message': 'Status updated successfully',
            'tutor_id': tutor_id,
            'new_status': data['status']
        }), 200
        
    except Exception as e:
        logger.error(f"Error updating application status: {str(e)}")
        return jsonify({'error': 'Failed to update status'}), 500

def send_status_update_email(tutor, new_status):
    """Send email notification when application status changes"""
    # Implement status update email logic
    pass

# Student Login Endpoint
@app.route('/api/student/login', methods=['POST'])
def student_login():
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400
            
        if 'email' not in data or 'password' not in data:
            return jsonify({'error': 'Email and password are required'}), 400
        
        try:
            student = Student.query.filter_by(email=data['email']).first()
        except Exception as db_error:
            logger.error(f"Database error during student login: {str(db_error)}")
            return jsonify({'error': 'Database error', 'details': str(db_error)}), 500
            
        if not student or not check_password_hash(student.password_hash, data['password']):
            return jsonify({'error': 'Invalid email or password'}), 401
        
        # Check if account is active
        if not student.is_active:
            return jsonify({'error': 'Account is deactivated. Please contact support.'}), 401
            
        # Update last login
        try:
            student.last_login = datetime.utcnow()
            db.session.commit()
        except Exception as commit_error:
            logger.error(f"Error updating student last login: {str(commit_error)}")
            db.session.rollback()
        
        # Generate JWT token using flask_jwt_extended
        try:
            token = create_access_token(
                identity=student.id,
                expires_delta=timedelta(days=7)
            )
        except Exception as token_error:
            logger.error(f"Error generating student token: {str(token_error)}")
            return jsonify({'error': 'Authentication error', 'details': str(token_error)}), 500
        
        return jsonify({
            'token': token,
            'user': {
                'id': student.id,
                'name': student.name,
                'email': student.email,
                'age': student.age,
                'grade_level': student.grade_level,
                'school_name': student.school_name,
                'total_points': student.total_points,
                'current_level': student.current_level,
                'preferred_service': student.preferred_service
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Student login error: {str(e)}")
        return jsonify({'error': 'Login failed', 'details': str(e)}), 500

@app.route('/api/student/auth', methods=['POST', 'OPTIONS'])
def student_auth():
    """Hybrid authentication endpoint - handles both login and auto-registration"""
    if request.method == 'OPTIONS':
        return '', 204

    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400

        identifier = data.get('identifier', '').strip()
        password = data.get('password', '')

        if not identifier or not password:
            return jsonify({'error': 'Email/username/phone and password are required'}), 400

        # Try to find student by email, username, or phone number
        student = None

        # Check if identifier is an email
        if '@' in identifier:
            student = Student.query.filter_by(email=identifier).first()
        else:
            # Try username or phone number
            student = Student.query.filter(
                (Student.username == identifier) | (Student.phone_number == identifier)
            ).first()

        # If student exists, verify password and return login response
        if student:
            # Check if password hash exists (for email auth users)
            if student.password_hash:
                if not check_password_hash(student.password_hash, password):
                    return jsonify({'error': 'Invalid credentials'}), 401
            else:
                # Google OAuth user trying to login with password - not allowed
                return jsonify({'error': 'This account uses Google Sign-In. Please use the Google button.'}), 401

            # Check if account is active
            if not student.is_active:
                return jsonify({'error': 'Account is deactivated. Please contact support.'}), 401

            # Update last login
            student.last_login = datetime.utcnow()

            # Update profile_complete status
            student.update_profile_complete_status()
            db.session.commit()

            # Generate JWT token using flask_jwt_extended
            token = create_access_token(
                identity=student.id,
                expires_delta=timedelta(days=7)
            )

            # Build user response
            user_data = {
                'id': student.id,
                'email': student.email,
                'profile_complete': student.profile_complete
            }

            # Add complete profile data if available
            if student.profile_complete:
                user_data.update({
                    'name': student.name,
                    'age': student.age,
                    'grade_level': student.grade_level,
                    'school_name': student.school_name,
                    'total_points': student.total_points,
                    'current_level': student.current_level
                })
            else:
                # Include missing fields for progressive onboarding
                user_data['missing_fields'] = student.get_missing_fields()

            return jsonify({
                'success': True,
                'token': token,
                'user': user_data
            }), 200

        # Student doesn't exist - auto-create account if identifier is email
        if '@' not in identifier:
            return jsonify({'error': 'Account not found. Please use your email to create an account.'}), 404

        # Validate email format
        email = identifier.lower()

        # Create new student account with minimal info
        new_student = Student(
            email=email,
            password_hash=generate_password_hash(password),
            is_active=True,
            auth_provider='email',
            email_verified=False,
            profile_complete=False,
            total_points=0,
            current_level=1
        )

        db.session.add(new_student)
        db.session.commit()

        # Generate JWT token using flask_jwt_extended
        token = create_access_token(
            identity=new_student.id,
            expires_delta=timedelta(days=7)
        )

        return jsonify({
            'success': True,
            'token': token,
            'user': {
                'id': new_student.id,
                'email': new_student.email,
                'profile_complete': False,
                'missing_fields': ['age', 'grade_level', 'school_name']
            },
            'message': 'Account created successfully'
        }), 201

    except Exception as e:
        db.session.rollback()
        logger.error(f"Student auth error: {str(e)}")
        return jsonify({'error': 'Authentication failed', 'details': str(e)}), 500

@app.route('/api/student/complete-profile', methods=['PATCH', 'OPTIONS'])
def complete_student_profile():
    """Complete student profile during progressive onboarding"""
    if request.method == 'OPTIONS':
        return '', 204

    try:
        # Verify authentication token
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401

        token = auth_header.split(' ')[1]

        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401

        # Get student from database
        student = Student.query.get(student_id)
        if not student:
            return jsonify({'error': 'Student not found'}), 404

        # Get profile data from request
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400

        # Validate and update age
        if 'age' in data:
            try:
                age = int(data['age'])
                if age < 5 or age > 18:
                    return jsonify({'error': 'Age must be between 5 and 18'}), 400
                student.age = age
            except (ValueError, TypeError):
                return jsonify({'error': 'Invalid age format'}), 400

        # Validate and update grade level
        if 'grade_level' in data:
            valid_grades = ['K', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']
            if data['grade_level'] not in valid_grades:
                return jsonify({'error': 'Invalid grade level'}), 400
            student.grade_level = data['grade_level']

        # Validate and update school name
        if 'school_name' in data:
            school_name = data['school_name'].strip()
            if len(school_name) < 2:
                return jsonify({'error': 'School name must be at least 2 characters'}), 400
            student.school_name = school_name

        # Update name if provided (for Google OAuth users)
        if 'name' in data and data['name']:
            student.name = data['name'].strip()

        # Update profile_complete status
        student.update_profile_complete_status()

        # Commit changes
        db.session.commit()

        # Return updated user data
        return jsonify({
            'success': True,
            'user': {
                'id': student.id,
                'name': student.name,
                'email': student.email,
                'age': student.age,
                'grade_level': student.grade_level,
                'school_name': student.school_name,
                'profile_complete': student.profile_complete,
                'total_points': student.total_points,
                'current_level': student.current_level
            }
        }), 200

    except Exception as e:
        db.session.rollback()
        logger.error(f"Complete profile error: {str(e)}")
        return jsonify({'error': 'Failed to update profile', 'details': str(e)}), 500

# Replace the student profile endpoint with this enhanced version
@app.route('/api/student/profile', methods=['GET'])
def get_student_profile():
    """Get student profile with fresh data"""
    try:
        logger.info("ðŸ“¥ Student profile request received")
        auth_header = request.headers.get('Authorization')

        if not auth_header:
            logger.warning("âŒ No Authorization header found")
            return jsonify({'error': 'No valid token provided'}), 401

        if not auth_header.startswith('Bearer '):
            logger.warning(f"âŒ Invalid Authorization header format: {auth_header[:20]}...")
            return jsonify({'error': 'No valid token provided'}), 401

        token = auth_header.split(' ')[1]
        logger.info(f"âœ… Token extracted (first 20 chars): {token[:20]}...")

        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            logger.info(f"âœ… Token decoded successfully. Payload keys: {list(payload.keys())}")
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')
            logger.info(f"ðŸ” Extracted student_id: {student_id} (from 'sub': {payload.get('sub')}, 'student_id': {payload.get('student_id')}, 'identity': {payload.get('identity')})")

            if not student_id:
                logger.warning(f"âŒ Invalid token: No student identifier. Full payload: {payload}")
                return jsonify({'error': 'Invalid token'}), 401

            logger.info(f"âœ… Student ID successfully extracted: {student_id}")
        except jwt.ExpiredSignatureError as e:
            logger.warning(f"âŒ Token expired: {str(e)}")
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError as e:
            logger.warning(f"âŒ Invalid token error: {str(e)}")
            return jsonify({'error': 'Invalid token'}), 401
            
        # Get student with fresh data from database
        logger.info(f"ðŸ” Querying database for student_id: {student_id}")
        student = Student.query.get(student_id)
        if not student:
            logger.warning(f"âŒ Student not found in database: {student_id}")
            return jsonify({'error': 'Student not found'}), 404

        logger.info(f"âœ… Student found: {student.email} (ID: {student.id})")

        # Get pending tasks count
        pending_tasks_count = StudentTask.query.filter_by(
            student_id=student_id,
            status='pending'
        ).count()
        logger.info(f"âœ… Pending tasks count: {pending_tasks_count}")

        # Get recent transactions for A-Card history
        recent_transactions = ACardTransaction.query.filter_by(
            student_id=student_id
        ).order_by(ACardTransaction.created_at.desc()).limit(5).all()
        logger.info(f"âœ… Recent transactions count: {len(recent_transactions)}")

        transactions_data = []
        for transaction in recent_transactions:
            transactions_data.append({
                'amount': float(transaction.amount),
                'description': transaction.description,
                'created_at': transaction.created_at.isoformat(),
                'balance_after': float(transaction.balance_after)
            })

        # Prepare fresh student data
        student_data = {
            'id': student.id,
            'name': student.name,
            'email': student.email,
            'age': getattr(student, 'age', 0),
            'grade_level': getattr(student, 'grade_level', 'N/A'),
            'school_name': getattr(student, 'school_name', 'N/A'),
            'total_points': getattr(student, 'total_points', 0),
            'current_level': getattr(student, 'current_level', 1),
            'acard_balance': float(getattr(student, 'acard_balance', 0) or 0),
            'pending_tasks_count': pending_tasks_count,
            'is_active': getattr(student, 'is_active', True),
            'created_at': student.created_at.isoformat() if hasattr(student, 'created_at') and student.created_at else None,
            'last_login': student.last_login.isoformat() if hasattr(student, 'last_login') and student.last_login else None,
            'recent_transactions': transactions_data
        }

        logger.info(f"âœ… Successfully prepared student profile data for {student.email}")
        return jsonify({
            'user': student_data,
            'fresh_data': True,
            'timestamp': datetime.utcnow().isoformat()
        }), 200

    except Exception as e:
        logger.error(f"âŒ Get student profile error: {str(e)}", exc_info=True)
        return jsonify({'error': 'Failed to fetch profile'}), 500

# Add endpoint for quick balance check
@app.route('/api/student/balance', methods=['GET'])
def get_student_balance():
    """Quick endpoint to get just the student's current balance"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401
            
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
            
        student = Student.query.get(student_id)
        if not student:
            return jsonify({'error': 'Student not found'}), 404
        
        return jsonify({
            'acard_balance': float(getattr(student, 'acard_balance', 0) or 0),
            'total_points': getattr(student, 'total_points', 0),
            'current_level': getattr(student, 'current_level', 1),
            'timestamp': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"Get student balance error: {str(e)}")
        return jsonify({'error': 'Failed to fetch balance'}), 500

@app.route('/api/student/scoreboard', methods=['GET'])
def get_student_scoreboard():
    """
    Get scoreboard of all registered quiz-mas students with their task completion scores
    This shows all students who registered via quiz-mas and their performance
    """
    try:
        # Get all active students
        students = Student.query.filter_by(is_active=True).all()

        scoreboard = []

        for student in students:
            # Get all tasks for this student
            tasks = StudentTask.query.filter_by(student_id=student.id).all()

            total_tasks = len(tasks)
            completed_tasks = [t for t in tasks if t.status == 'completed']
            completed_count = len(completed_tasks)

            # Calculate average score from completed tasks
            total_score = 0
            scored_tasks = 0

            for task in completed_tasks:
                try:
                    task_data = json.loads(task.task_data) if task.task_data else {}
                    completion_data = task_data.get('completion_data', {})

                    # Get score percentage
                    if 'score_percentage' in completion_data:
                        total_score += completion_data['score_percentage']
                        scored_tasks += 1
                    elif 'score' in completion_data and 'max_score' in completion_data:
                        score = completion_data['score']
                        max_score = completion_data['max_score']
                        if max_score > 0:
                            percentage = (score / max_score) * 100
                            total_score += percentage
                            scored_tasks += 1
                except:
                    continue

            average_score = round(total_score / scored_tasks, 1) if scored_tasks > 0 else 0
            overall_progress = round((completed_count / total_tasks * 100), 1) if total_tasks > 0 else 0

            scoreboard.append({
                'id': student.id,
                'name': student.name,
                'email': student.email,
                'grade_level': student.grade_level,
                'school_name': student.school_name,
                'total_points': student.total_points or 0,
                'current_level': student.current_level or 1,
                'acard_balance': float(student.acard_balance or 0),
                'tasks_completed': completed_count,
                'total_tasks': total_tasks,
                'average_score': average_score,
                'overall_progress': overall_progress
            })

        # Sort by total points (descending), then by average score
        scoreboard.sort(key=lambda x: (x['total_points'], x['average_score']), reverse=True)

        # Add rank to each student
        for idx, student_data in enumerate(scoreboard, 1):
            student_data['rank'] = idx

        logger.info(f"Scoreboard generated with {len(scoreboard)} students")

        return jsonify({
            'success': True,
            'scoreboard': scoreboard,
            'total_students': len(scoreboard)
        }), 200

    except Exception as e:
        logger.error(f"Error fetching student scoreboard: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({'error': 'Failed to load scoreboard'}), 500

# Student Google Login
@app.route('/api/student/google-login', methods=['POST'])
def student_google_login():
    try:
        data = request.get_json()
        if not data or 'credential' not in data:
            return jsonify({'error': 'No credential provided'}), 400

        # Verify Google token
        user_info = verify_google_token(data['credential'])
        if not user_info:
            return jsonify({'error': 'Invalid Google token'}), 400

        # Check if student exists
        student = Student.query.filter_by(email=user_info['email']).first()

        # Auto-create account if doesn't exist
        if not student:
            student = Student(
                name=user_info.get('name', ''),
                email=user_info['email'],
                password_hash=None,  # No password for Google OAuth users
                is_active=True,
                auth_provider='google',
                email_verified=True,  # Google accounts are pre-verified
                profile_complete=False,
                total_points=0,
                current_level=1
            )
            db.session.add(student)
            db.session.flush()  # Get the student ID before commit

        # Update last login
        student.last_login = datetime.utcnow()

        # Update profile_complete status
        student.update_profile_complete_status()
        db.session.commit()

        # Generate JWT token using flask_jwt_extended
        token = create_access_token(
            identity=student.id,
            expires_delta=timedelta(days=7)
        )

        # Build user response
        user_data = {
            'id': student.id,
            'email': student.email,
            'profile_complete': student.profile_complete
        }

        # Add complete profile data if available
        if student.profile_complete:
            user_data.update({
                'name': student.name,
                'age': student.age,
                'grade_level': student.grade_level,
                'school_name': student.school_name,
                'total_points': student.total_points,
                'current_level': student.current_level,
                'preferred_service': student.preferred_service
            })
        else:
            # Include name from Google and missing fields
            user_data['name'] = student.name
            user_data['missing_fields'] = student.get_missing_fields()

        return jsonify({
            'success': True,
            'token': token,
            'user': user_data
        }), 200

    except Exception as e:
        db.session.rollback()
        logger.error(f"Student Google login error: {str(e)}")
        return jsonify({'error': 'Google login failed', 'details': str(e)}), 500

# Student Forgot Password
@app.route('/api/student/forgot-password', methods=['POST'])
def student_forgot_password():
    try:
        data = request.get_json()
        if not data or 'email' not in data:
            return jsonify({'error': 'Email is required'}), 400
            
        email = data['email']
        student = Student.query.filter_by(email=email).first()
        
        # Always return success message for security
        if student:
            # Generate reset token
            reset_token, token_expiry = generate_verification_token()
            student.verification_token = reset_token
            student.verification_token_expires = token_expiry
            db.session.commit()
            
            # Send reset email (implement this function)
            send_student_password_reset_email(email, reset_token)
        
        return jsonify({
            'message': 'If your email is registered, you will receive a password reset link shortly.'
        }), 200
        
    except Exception as e:
        logger.error(f"Student forgot password error: {str(e)}")
        return jsonify({'error': 'Password reset request failed'}), 500

# Student Service Preference
@app.route('/api/student/set-service', methods=['POST'])  
def set_student_service():
    try:
        # Get token from Authorization header
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401
            
        token = auth_header.split(' ')[1]
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            # flask_jwt_extended uses 'sub' claim for identity, not 'student_id'

            student_id = payload.get('sub') or payload.get('student_id') or payload.get('identity')

            if not student_id:

                logger.warning(f"Invalid token: No student identifier. Keys: {list(payload.keys())}")

                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
            
        data = request.get_json()
        if not data or 'service' not in data:
            return jsonify({'error': 'Service preference is required'}), 400
            
        valid_services = ['gamification', 'storification', 'debate']
        if data['service'] not in valid_services:
            return jsonify({'error': 'Invalid service type'}), 400
            
        student = Student.query.get(student_id)
        if not student:
            return jsonify({'error': 'Student not found'}), 404
            
        student.preferred_service = data['service']
        db.session.commit()
        
        return jsonify({
            'message': 'Service preference updated successfully',
            'preferred_service': student.preferred_service
        }), 200
        
    except Exception as e:
        logger.error(f"Set student service error: {str(e)}")
        return jsonify({'error': 'Failed to update service preference'}), 500

# Helper function to send student password reset email
def send_student_password_reset_email(email, token):
    """Send password reset email to student"""
    try:
        reset_url = f"https://deciph.ai.decipheracad.online/student/reset-password?token={token}"
        
        msg = MailMessage(
            'Reset Your Student Account Password',
            sender=MAIL_USERNAME,
            recipients=[email]
        )
        
        msg.html = f"""
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #8B5CF6;">Reset Your Password</h2>
            <p>Hello!</p>
            <p>You requested to reset your password for your Deciph.AI student account.</p>
            <p>Click the button below to reset your password:</p>
            <p style="text-align: center; margin: 30px 0;">
                <a href="{reset_url}" 
                   style="background: linear-gradient(135deg, #8B5CF6, #6366F1); color: white; padding: 15px 30px; text-decoration: none; border-radius: 8px; display: inline-block;">
                   Reset My Password
                </a>
            </p>
            <p>If you didn't request this, you can safely ignore this email.</p>
            <p>This link will expire in 1 hour.</p>
            <p>Happy Learning!<br>The Deciph.AI Team</p>
        </div>
        """
        
        mail.send(msg)
        return True
    except Exception as e:
        logger.error(f"Error sending student password reset email: {str(e)}")
        return False

@app.route('/api/subscription/status', methods=['GET'])
@token_required
def get_subscription_status(current_user):
    """Get user's subscription status"""
    try:
        # Check trial period
        trial_remaining = None
        if current_user.trial_ends_at:
            trial_diff = current_user.trial_ends_at - datetime.utcnow()
            trial_remaining = max(0, trial_diff.days)
        
        # Check for active subscription
        subscription = Subscription.query.filter_by(
            user_id=current_user.id,
            status='active'
        ).first()
        
        is_active = (trial_remaining and trial_remaining > 0) or (subscription and subscription.ends_at > datetime.utcnow())
        
        return jsonify({
            'subscription_active': is_active,
            'trial_days_remaining': trial_remaining if trial_remaining and trial_remaining > 0 else None,
            'current_plan': subscription.plan_type if subscription else None,
            'subscription_ends': subscription.ends_at.isoformat() if subscription and subscription.ends_at else None
        })
    except Exception as e:
        logger.error(f"Error checking subscription status: {str(e)}")
        return jsonify({'error': 'Failed to check subscription status'}), 500

# Default routes for static files
@app.route('/')
def serve_index():
    return send_from_directory('.', 'index.html')

@app.route('/<path:filename>')
def serve_files(filename):
    # Never serve API routes as static files
    if filename.startswith('api/'):
        abort(404)

    # Check if file is an HTML file and exists in templates folder
    if filename.endswith('.html'):
        template_path = os.path.join(app.template_folder, filename)
        if os.path.exists(template_path):
            return send_from_directory(app.template_folder, filename)

    # Fall back to serving from current directory
    return send_from_directory('.', filename)

@app.route('/list-routes')
def list_routes():
    routes = []
    for rule in app.url_map.iter_rules():
        routes.append({
            'endpoint': rule.endpoint,
            'methods': list(rule.methods),
            'path': str(rule)
        })
    return jsonify(routes)
        

def is_subscription_valid(user_id):
    """Check if user has valid subscription or is within trial period"""
    user = User.query.get(user_id)
    if not user:
        return False
    
    # Check trial period
    if user.trial_ends_at and user.trial_ends_at > datetime.utcnow():
        return True
        
    # Check active subscription
    subscription = Subscription.query.filter_by(
        user_id=user_id,
        status='active'
    ).first()
    
    return bool(subscription and subscription.ends_at > datetime.utcnow())

# Add these routes to your app.py file

# Enhanced email sending function with attachments
def send_welcome_email_with_attachments(subscriber_email, subscriber_name, attachments_folder="job_bundle_resources"):
    """Send welcome email with job bundle attachments"""
    try:
        # Create message
        msg = MailMessage(
            subject="ðŸŽ‰ Welcome to Decipher Academy - Your Job Bundle Resources Are Here!",
            sender=app.config['MAIL_DEFAULT_SENDER'],
            recipients=[subscriber_email]
        )
        
        # Set HTML content
        msg.html = create_welcome_email_html(subscriber_name)
        
        # Plain text version for email clients that don't support HTML
        msg.body = f"""
        Welcome to Decipher Academy, {subscriber_name}!
        
        Thank you for subscribing to our Job Application Bundle. You now have access to our comprehensive collection of job application resources.
        
        Attached to this email, you'll find:
        - Email Templates for Job Applications
        - Resume Writing Guide  
        - LinkedIn Optimization Steps
        - Cover Letter Templates
        - Top Interview Questions & Answers
        
        We're excited to have you in our community and can't wait to see you succeed in your career journey!
        
        Best regards,
        The Decipher Academy Team
        
        ---
        Decipher Academy
        
        +234 916 081 2845
        decipheracad140@gmail.com
        """
        
        # Define the attachments with their display names
        attachment_files = [
            {
                'filename': 'email_templates.pdf',
                'display_name': 'Email Templates for Job Applications.pdf'
            },
            {
                'filename': 'interview_questions.pdf', 
                'display_name': 'Top Interview Questions & Answers.pdf'
            },
            {
                'filename': 'resume_guide.pdf',
                'display_name': 'Resume Writing Guide.pdf'
            },
            {
                'filename': 'linkedin_guide.pdf',
                'display_name': 'LinkedIn Optimization Guide.pdf'
            },
            {
                'filename': 'cover_letter_templates.pdf',
                'display_name': 'Cover Letter Templates.pdf'
            }
        ]
        
        # Attach each file if it exists
        attached_count = 0
        for attachment in attachment_files:
            file_path = os.path.join(attachments_folder, attachment['filename'])
            if os.path.exists(file_path):
                with app.open_resource(file_path) as fp:
                    msg.attach(
                        attachment['display_name'],
                        'application/pdf',
                        fp.read()
                    )
                    attached_count += 1
                    print(f"Attached: {attachment['display_name']}")
        
        # Send the email
        mail.send(msg)
        print(f"Welcome email sent successfully to {subscriber_email} with {attached_count} attachments")
        return True
        
    except Exception as e:
        print(f"Failed to send welcome email to {subscriber_email}: {str(e)}")
        return False

# Email template function (add this before the endpoint)
def create_welcome_email_html(subscriber_name):
    """Create a professional HTML email template for job bundle welcome"""
    return f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Welcome to Decipher Academy Job Bundle</title>
        <style>
            body {{
                font-family: 'Segoe UI', Arial, sans-serif;
                line-height: 1.6;
                color: #333;
                margin: 0;
                padding: 0;
                background-color: #f8fafc;
            }}
            .email-container {{
                max-width: 600px;
                margin: 0 auto;
                background-color: #ffffff;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            }}
            .header {{
                background: linear-gradient(135deg, #2563eb, #1e40af);
                padding: 30px;
                text-align: center;
            }}
            .logo {{
                color: white;
                font-size: 28px;
                font-weight: 700;
                margin-bottom: 10px;
            }}
            .tagline {{
                color: rgba(255, 255, 255, 0.9);
                font-size: 16px;
            }}
            .welcome-section {{
                padding: 40px 30px;
                text-align: center;
                background-color: #f8fafc;
            }}
            .welcome-title {{
                font-size: 32px;
                color: #1f2937;
                margin-bottom: 15px;
                font-weight: 600;
            }}
            .welcome-subtitle {{
                font-size: 18px;
                color: #6b7280;
                margin-bottom: 30px;
            }}
            .content-section {{
                padding: 30px;
            }}
            .bundle-grid {{
                display: grid;
                gap: 20px;
                margin: 30px 0;
            }}
            .bundle-item {{
                border: 1px solid #e5e7eb;
                border-radius: 12px;
                padding: 20px;
                background-color: #ffffff;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
                transition: transform 0.2s ease;
            }}
            .bundle-item:hover {{
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            }}
            .bundle-icon {{
                font-size: 24px;
                margin-bottom: 10px;
            }}
            .bundle-title {{
                font-size: 18px;
                font-weight: 600;
                color: #2563eb;
                margin-bottom: 8px;
            }}
            .bundle-description {{
                color: #6b7280;
                font-size: 14px;
            }}
            .community-section {{
                background-color: #f3f4f6;
                padding: 30px;
                margin: 30px 0;
                border-radius: 12px;
            }}
            .community-title {{
                font-size: 22px;
                color: #1f2937;
                margin-bottom: 15px;
                font-weight: 600;
            }}
            .community-description {{
                color: #6b7280;
                margin-bottom: 20px;
            }}
            .community-benefits {{
                list-style: none;
                padding: 0;
            }}
            .community-benefits li {{
                padding: 8px 0;
                position: relative;
                padding-left: 25px;
            }}
            .community-benefits li:before {{
                content: 'âœ“';
                position: absolute;
                left: 0;
                color: #10b981;
                font-weight: bold;
            }}
            .cta-section {{
                text-align: center;
                padding: 30px;
                background-color: #2563eb;
                color: white;
            }}
            .cta-title {{
                font-size: 24px;
                margin-bottom: 15px;
                font-weight: 600;
            }}
            .cta-description {{
                font-size: 16px;
                margin-bottom: 25px;
                opacity: 0.9;
            }}
            .btn {{
                display: inline-block;
                padding: 12px 30px;
                background-color: #ffffff;
                color: #2563eb;
                text-decoration: none;
                border-radius: 8px;
                font-weight: 600;
                transition: transform 0.2s ease;
            }}
            .btn:hover {{
                transform: translateY(-2px);
            }}
            .footer {{
                background-color: #1e293b;
                color: white;
                padding: 30px;
                text-align: center;
            }}
            .footer-logo {{
                font-size: 20px;
                font-weight: 600;
                margin-bottom: 15px;
            }}
            .footer-text {{
                color: #94a3b8;
                font-size: 14px;
                margin-bottom: 20px;
            }}
            .social-links {{
                margin-top: 20px;
            }}
            .social-links a {{
                color: #94a3b8;
                text-decoration: none;
                margin: 0 10px;
                font-size: 16px;
            }}
            @media (max-width: 600px) {{
                .email-container {{
                    margin: 0;
                }}
                .content-section, .welcome-section, .community-section, .cta-section {{
                    padding: 20px;
                }}
                .welcome-title {{
                    font-size: 24px;
                }}
            }}
        </style>
    </head>
    <body>
        <div class="email-container">
            <!-- Header -->
            <div class="header">
                <div class="logo">ðŸŽ“ Decipher Academy</div>
                <div class="tagline">Transforming careers through quality education</div>
            </div>
            
            <!-- Welcome Section -->
            <div class="welcome-section">
                <h1 class="welcome-title">Welcome, {subscriber_name}! ðŸŽ‰</h1>
                <p class="welcome-subtitle">Thank you for subscribing to our Job Application Bundle</p>
            </div>
            
            <!-- Content Section -->
            <div class="content-section">
                <p>Congratulations on taking this important step in your career journey! You now have access to our comprehensive collection of job application resources designed to help you stand out in today's competitive market.</p>
                
                <!-- Bundle Items Grid -->
                <div class="bundle-grid">
                    <div class="bundle-item">
                        <div class="bundle-icon">ðŸ“§</div>
                        <div class="bundle-title">Email Templates for Job Applications</div>
                        <div class="bundle-description">Professional email templates for every stage of your job search - from initial inquiries to follow-ups and thank-you notes.</div>
                    </div>
                    
                    <div class="bundle-item">
                        <div class="bundle-icon">ðŸ“</div>
                        <div class="bundle-title">Resume Writing Guide</div>
                        <div class="bundle-description">Comprehensive guide with ATS-friendly templates, industry-specific examples, and expert tips to create standout resumes.</div>
                    </div>
                    
                    <div class="bundle-item">
                        <div class="bundle-icon">ðŸ’¼</div>
                        <div class="bundle-title">LinkedIn Optimization Steps</div>
                        <div class="bundle-description">Step-by-step guide to creating an outstanding LinkedIn profile that attracts recruiters and showcases your professional brand.</div>
                    </div>
                    
                    <div class="bundle-item">
                        <div class="bundle-icon">ðŸ“„</div>
                        <div class="bundle-title">Cover Letter Templates</div>
                        <div class="bundle-description">Industry-specific cover letter templates and guides to help you craft compelling letters that get you noticed.</div>
                    </div>
                    
                    <div class="bundle-item">
                        <div class="bundle-icon">â“</div>
                        <div class="bundle-title">Top Interview Questions & Answers</div>
                        <div class="bundle-description">Comprehensive list of common interview questions with expert advice on how to answer them effectively.</div>
                    </div>
                </div>
                
                <!-- Community Section -->
                <div class="community-section">
                    <h2 class="community-title">Welcome to Our Community ðŸ¤</h2>
                    <p class="community-description">You're now part of a growing community of professionals committed to career excellence. Here's what you can expect:</p>
                    <ul class="community-benefits">
                        <li>Weekly career tips and job market insights</li>
                        <li>Access to exclusive webinars and workshops</li>
                        <li>Industry-specific resources and templates</li>
                        <li>Networking opportunities with like-minded professionals</li>
                        <li>Early access to new courses and materials</li>
                    </ul>
                </div>
                
                <p>All the resources mentioned above are attached to this email as PDF files. Download them, bookmark this email, and refer back whenever you need guidance in your job search.</p>
                
                <p><strong>Pro Tip:</strong> Start with the email templates - they're immediately actionable and can make a difference in your applications right away!</p>
            </div>
            
            <!-- CTA Section -->
            <div class="cta-section">
                <h2 class="cta-title">Ready to Take Your Career to the Next Level?</h2>
                <p class="cta-description">Explore our full range of professional development courses and resources</p>
                <a href="https://chat.whatsapp.com/KxXNJTuJNlWB2WAgxQpXMF?mode=ac_t" class="btn">Join our growing community</a>
            </div>
            <p><strong>Pro Tip:</strong> Start with the email templates - they're immediately actionable and can make a difference in your applications right away!</p>

<!-- VSL Section -->
<div class="vsl-section">
    <h2 class="vsl-title">Want to Know More About Us?</h2>
    <p class="vsl-description">Check out our short video to learn more about Decipher Academy and how we help professionals land their dream jobs.</p>
    <a href="https://www.canva.com/design/DAGnJORVWqw/hC79GReAdeADt7YHjloDCg/view?utm_content=DAGnJORVWqw&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=he2f1834b9f " 
       class="btn vsl-btn" 
       target="_blank" 
       style="display: inline-block; padding: 12px 24px; background-color: #6366F1; color: #fff; text-decoration: none; border-radius: 5px; margin-top: 10px;">
       Our letter to you
    </a>
</div>
            <!-- Footer -->
            <div class="footer">
                <div class="footer-logo">Decipher Academy</div>
                <p class="footer-text"> Lagos<br>+234 916 081 2845 | decipheracad140@gmail.com</p>
                <div class="social-links">
                    <a href="https://www.instagram.com/decipher_acad">Instagram</a>
                    <a href="#">LinkedIn</a>
                    <a href="#">Facebook</a>
                </div>
                <p class="footer-text" style="margin-top: 20px; font-size: 12px;">
                    Â© 2025 Decipher Academy. All rights reserved.<br>
                    You're receiving this because you subscribed to our job bundle. 
                    <a href="#" style="color: #94a3b8;">Unsubscribe</a>
                </p>
            </div>
        </div>
    </body>
    </html>
    """
# Optional: Add test endpoint for email sending
@app.route('/api/test-email', methods=['POST'])
def test_email():
    """Test endpoint to verify email sending functionality"""
    data = request.get_json()
    email = data.get('email', 'test@example.com')
    name = data.get('name', 'Test User')
    
    success = send_welcome_email_with_attachments(email, name)
    
    return jsonify({
        'success': success,
        'message': f'Test email {"sent successfully" if success else "failed to send"} to {email}'
    })

@app.route('/api/public/subscribe', methods=['POST'])
def public_subscribe():
    """Public endpoint for newsletter subscriptions with immediate email sending"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400
            
        # Validate required fields
        required_fields = ['name', 'email']
        missing_fields = [field for field in required_fields if field not in data]
        if missing_fields:
            return jsonify({'error': f'Missing required fields: {", ".join(missing_fields)}'}), 400
            
        # Extract data
        name = data['name'].strip()
        email = data['email'].strip().lower()
        
        # Basic email validation
        import re
        email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not re.match(email_regex, email):
            return jsonify({'error': 'Invalid email format'}), 400
        
        # Initialize variables
        subscription_created = False
        subscription = None
        email_sent = False
        
        # Try database operations with error handling
        try:
            # Check if email already exists
            existing_subscription = BlogSubscription.query.filter_by(
                email=email, 
                is_active=True
            ).first()
            
            if existing_subscription:
                # Update existing subscription
                existing_subscription.name = name
                
                # Update preferences if provided
                if 'preferences' in data:
                    existing_subscription.preferences_json = json.dumps(data['preferences'])
                    
                db.session.commit()
                subscription = existing_subscription
                print(f"Updated existing subscription for {email}")
            else:
                # Create new subscription
                subscription = BlogSubscription(
                    id=str(uuid.uuid4()),
                    user_id=None,  # No user ID for public subscriptions
                    name=name,
                    email=email,
                    subscription_date=datetime.utcnow(),
                    is_active=True,
                    source=data.get('source', 'job_bundle')
                )
                
                # Set preferences if provided
                if 'preferences' in data:
                    subscription.preferences_json = json.dumps(data['preferences'])
                    
                db.session.add(subscription)
                db.session.commit()
                subscription_created = True
                print(f"Created new subscription for {email}")
                
        except Exception as db_error:
            print(f"Database error: {str(db_error)}")
            db.session.rollback()
            
            # Even if database fails, we can still send the email
            # Create a temporary subscription object for email response
            subscription = type('obj', (object,), {
                'id': str(uuid.uuid4()),
                'user_id': None,
                'name': name,
                'email': email,
                'subscription_date': datetime.utcnow(),
                'is_active': True,
                'source': data.get('source', 'job_bundle'),
                'preferences_json': json.dumps(data.get('preferences', {})) if 'preferences' in data else None,
                'to_dict': lambda: {
                    'id': str(uuid.uuid4()),
                    'user_id': None,
                    'name': name,
                    'email': email,
                    'subscription_date': datetime.utcnow().isoformat(),
                    'is_active': True,
                    'preferences': data.get('preferences', {}),
                    'source': data.get('source', 'job_bundle')
                }
            })
            subscription_created = False  # Since database operation failed
        
        # Send welcome email with attachments (this should still work even if DB fails)
        try:
            email_sent = send_welcome_email_with_attachments(email, name)
            print(f"Email sending result: {email_sent}")
        except Exception as email_error:
            print(f"Email sending error: {str(email_error)}")
            email_sent = False
        
        # Prepare response
        response_data = {
            'message': 'Welcome email sent successfully!' if email_sent else 'Subscription processed',
            'subscription': subscription.to_dict() if hasattr(subscription, 'to_dict') else {
                'name': name,
                'email': email,
                'preferences': data.get('preferences', {})
            },
            'email_sent': email_sent,
            'subscription_created': subscription_created,
            'database_success': subscription_created or (subscription and hasattr(subscription, 'id'))
        }
        
        # Log the result
        print(f"Subscription processed for {email} - Email sent: {email_sent}, DB success: {response_data['database_success']}")
        
        # Return success if email was sent, even if database had issues
        if email_sent:
            return jsonify(response_data), 200
        else:
            return jsonify({
                'error': 'Failed to send welcome email',
                'details': 'Please try again or contact support',
                'subscription_data': response_data
            }), 500
        
    except Exception as e:
        import traceback
        error_traceback = traceback.format_exc()
        print(f"General subscription error: {str(e)}")
        print(error_traceback)
        
        # Try to rollback if session exists
        try:
            db.session.rollback()
        except:
            pass
        
        return jsonify({
            'error': 'Subscription failed', 
            'details': str(e),
            'message': 'Please check your email address and try again.'
        }), 500

@app.route('/api/public/subscription-status', methods=['GET'])
def check_public_subscription_status():
    """Check if an email is subscribed"""
    try:
        email = request.args.get('email')
        if not email:
            return jsonify({'error': 'Email parameter is required'}), 400
            
        # Check if email exists and subscription is active
        subscription = BlogSubscription.query.filter_by(
            email=email, 
            is_active=True
        ).first()
        
        if subscription:
            return jsonify({
                'is_subscribed': True,
                'subscription': subscription.to_dict()
            }), 200
        else:
            return jsonify({
                'is_subscribed': False
            }), 200
            
    except Exception as e:
        print(f"Subscription status check error: {str(e)}")
        return jsonify({'error': 'Failed to check subscription status', 'details': str(e)}), 500

@app.route('/api/public/verify-subscription', methods=['GET'])
def verify_subscription():
    """Verify if an email is subscribed in the database"""
    try:
        # Get email from query parameters
        email = request.args.get('email')
        if not email:
            return jsonify({'error': 'Email parameter is required'}), 400
            
        # Check if subscription exists and is active in the database
        subscription = BlogSubscription.query.filter_by(
            email=email, 
            is_active=True
        ).first()
        
        if subscription:
            return jsonify({
                'is_subscribed': True,
                'name': subscription.name,
                'email': subscription.email,
                'subscription_date': subscription.subscription_date.isoformat() if subscription.subscription_date else None
            }), 200
        else:
            return jsonify({
                'is_subscribed': False
            }), 200
            
    except Exception as e:
        print(f"Subscription verification error: {str(e)}")
        return jsonify({'error': 'Failed to verify subscription', 'details': str(e)}), 500
    
@app.route('/api/unsubscribe', methods=['POST'])
@token_required
def unsubscribe_from_blog(current_user):
    """Unsubscribe a user from the blog/newsletter"""
    try:
        # Find active subscription
        subscription = BlogSubscription.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not subscription:
            return jsonify({'error': 'No active subscription found'}), 404
            
        # Mark as inactive
        subscription.is_active = False
        db.session.commit()
        
        return jsonify({
            'message': 'Successfully unsubscribed',
            'unsubscribed_at': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"Unsubscription error: {str(e)}")
        db.session.rollback()
        return jsonify({'error': 'Unsubscription failed', 'details': str(e)}), 500

@app.route('/api/subscription-status', methods=['GET'])
@token_required
def check_subscription_status(current_user):
    """Check if a user is subscribed to the blog/newsletter"""
    try:
        # Find active subscription
        subscription = BlogSubscription.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if subscription:
            return jsonify({
                'is_subscribed': True,
                'subscription': subscription.to_dict()
            }), 200
        else:
            return jsonify({
                'is_subscribed': False
            }), 200
            
    except Exception as e:
        logger.error(f"Subscription status check error: {str(e)}")
        return jsonify({'error': 'Failed to check subscription status', 'details': str(e)}), 500

# Admin routes for managing subscriptions
@app.route('/api/admin/subscribers', methods=['GET'])
@token_required
def admin_get_subscribers(current_user):
    """Get all subscribers (admin only)"""
    try:
        # Check if user is admin (implement your admin check logic here)
        # This is just a placeholder - replace with your actual admin check
        if not hasattr(current_user, 'is_admin') or not current_user.is_admin:
            return jsonify({'error': 'Unauthorized access'}), 403
        
        # Get query parameters
        source = request.args.get('source', 'all')
        status = request.args.get('status', 'all')
        date_filter = request.args.get('date', 'all')
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 10, type=int)
        
        # Build query
        query = BlogSubscription.query
        
        # Apply filters
        if source != 'all':
            query = query.filter_by(source=source)
        
        if status == 'active':
            query = query.filter_by(is_active=True)
        elif status == 'inactive':
            query = query.filter_by(is_active=False)
        
        # Apply date filter
        if date_filter == 'today':
            today = datetime.utcnow().date()
            query = query.filter(func.date(BlogSubscription.subscription_date) == today)
        elif date_filter == 'week':
            week_ago = datetime.utcnow() - timedelta(days=7)
            query = query.filter(BlogSubscription.subscription_date >= week_ago)
        elif date_filter == 'month':
            month_ago = datetime.utcnow() - timedelta(days=30)
            query = query.filter(BlogSubscription.subscription_date >= month_ago)
        elif date_filter == 'year':
            year_ago = datetime.utcnow() - timedelta(days=365)
            query = query.filter(BlogSubscription.subscription_date >= year_ago)
        
        # Get total count (for pagination)
        total = query.count()
        
        # Order and paginate
        subscribers = query.order_by(BlogSubscription.subscription_date.desc()) \
                         .offset((page - 1) * per_page) \
                         .limit(per_page) \
                         .all()
        
        # Prepare response
        return jsonify({
            'subscribers': [subscriber.to_dict() for subscriber in subscribers],
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'pages': (total + per_page - 1) // per_page
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Admin subscribers error: {str(e)}")
        return jsonify({'error': 'Failed to fetch subscribers', 'details': str(e)}), 500

@app.route('/api/admin/subscribers/stats', methods=['GET'])
@token_required
def admin_get_subscription_stats(current_user):
    """Get subscription statistics (admin only)"""
    try:
        # Check if user is admin (implement your admin check logic here)
        # This is just a placeholder - replace with your actual admin check
        if not hasattr(current_user, 'is_admin') or not current_user.is_admin:
            return jsonify({'error': 'Unauthorized access'}), 403
        
        # Get total subscribers
        total_subscribers = BlogSubscription.query.filter_by(is_active=True).count()
        
        # Get this month's subscribers
        month_start = datetime.utcnow().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        this_month = BlogSubscription.query.filter(
            BlogSubscription.subscription_date >= month_start,
            BlogSubscription.is_active == True
        ).count()
        
        # Get last month's subscribers for comparison
        last_month_start = (month_start - timedelta(days=1)).replace(day=1)
        last_month = BlogSubscription.query.filter(
            BlogSubscription.subscription_date >= last_month_start,
            BlogSubscription.subscription_date < month_start,
            BlogSubscription.is_active == True
        ).count()
        
        # Calculate growth percentage
        month_growth = 0
        if last_month > 0:
            month_growth = round(((this_month - last_month) / last_month) * 100)
        
        # Get job bundle subscribers
        job_bundle = BlogSubscription.query.filter_by(
            source='job_bundle',
            is_active=True
        ).count()
        
        return jsonify({
            'total': total_subscribers,
            'this_month': this_month,
            'month_growth': month_growth,
            'job_bundle': job_bundle
        }), 200
        
    except Exception as e:
        logger.error(f"Admin subscription stats error: {str(e)}")
        return jsonify({'error': 'Failed to fetch subscription stats', 'details': str(e)}), 500


# Add these routes to your app.py file

# Add this to your /api/course-interest route in app.py
# Replace the existing route with this updated version:

@app.route('/api/course-interest', methods=['POST', 'OPTIONS'])
def submit_course_interest():
    """Handle course interest form submissions"""
    
    # Handle CORS preflight
    if request.method == 'OPTIONS':
        return '', 204
    
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        # Validate required fields
        required_fields = ['course_selected', 'cohort_date', 'full_name', 'email']
        missing_fields = [field for field in required_fields if not data.get(field)]
        
        if missing_fields:
            return jsonify({
                'error': 'Missing required fields',
                'missing_fields': missing_fields
            }), 400
        
        # Validate email format
        email = data.get('email', '').strip().lower()
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email):
            return jsonify({'error': 'Invalid email format'}), 400
        
        # Create new course interest lead
        lead = CourseInterestLead(
            id=str(uuid.uuid4()),  # Ensure UUID is generated
            course_selected=data.get('course_selected'),
            cohort_date=data.get('cohort_date'),
            full_name=data.get('full_name').strip(),
            email=email,
            career_goals=data.get('career_goals', '').strip(),
            source=data.get('source', 'landing_page'),
            utm_source=data.get('utm_source'),
            utm_medium=data.get('utm_medium'),
            utm_campaign=data.get('utm_campaign')
        )
        
        # Check if this email already submitted interest for the same course
        existing_lead = CourseInterestLead.query.filter_by(
            email=email,
            course_selected=data.get('course_selected')
        ).first()
        
        email_sent = False
        
        if existing_lead:
            # Update existing lead with new information
            existing_lead.cohort_date = data.get('cohort_date')
            existing_lead.full_name = data.get('full_name').strip()
            existing_lead.career_goals = data.get('career_goals', '').strip()
            existing_lead.created_at = datetime.utcnow()
            
            db.session.commit()
            
            # Send email if requested
            if data.get('trigger_email'):
                email_sent = send_course_interest_email(existing_lead)
            
            return jsonify({
                'message': 'Interest updated successfully',
                'lead_id': existing_lead.id,
                'is_update': True,
                'email_sent': email_sent
            }), 200
        
        # Save new lead to database
        db.session.add(lead)
        db.session.commit()
        
        logger.info(f"New course interest lead created: {lead.full_name} - {lead.course_selected}")
        
        # Send email if requested
        if data.get('trigger_email'):
            email_sent = send_course_interest_email(lead)
        
        return jsonify({
            'message': 'Course interest submitted successfully',
            'lead_id': lead.id,
            'email_sent': email_sent,
            'next_steps': {
                'whatsapp_url': 'https://wa.me/2349160812845',
                'job_bundle_url': 'https://decipheracad.netlify.app/job-bundle.html'
            }
        }), 201
        
    except Exception as e:
        logger.error(f"Course interest submission error: {str(e)}")
        db.session.rollback()
        return jsonify({
            'error': 'Failed to submit course interest',
            'details': str(e)
        }), 500
def send_lead_notification_email(lead, is_update=False):
    """Send notification email to admin about new lead"""
    try:
        subject = f"{'Updated' if is_update else 'New'} Course Interest: {lead.course_selected}"
        
        # Map course codes to readable names
        course_names = {
            'video-editing': 'Professional Video Editing',
            'social-media': 'Social Media Management',
            'web-development': 'Web Development',
            'digital-marketing': 'Digital Marketing',
            'virtual-assistance': 'Virtual Assistance'
        }
        
        course_name = course_names.get(lead.course_selected, lead.course_selected)
        
        # Map schedule codes to readable dates
        schedule_names = {
            'may-2025': 'May 26, 2025 (Next Cohort)',
            'august-2025': 'August 25, 2025 (Following Cohort)'
        }
        
        schedule_name = schedule_names.get(lead.cohort_date, lead.cohort_date)
        
        msg = MailMessage(
            subject=subject,
            sender=app.config['MAIL_DEFAULT_SENDER'],
            recipients=['decipheracad140@gmail.com']  # Admin email
        )
        
        msg.html = f"""
        <h2>{'Updated' if is_update else 'New'} Course Interest Lead</h2>
        
        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>Contact Information</h3>
            <p><strong>Name:</strong> {lead.full_name}</p>
            <p><strong>Email:</strong> {lead.email}</p>
            <p><strong>WhatsApp:</strong> <a href="https://wa.me/2349160812845">Contact via WhatsApp</a></p>
        </div>
        
        <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>Course Details</h3>
            <p><strong>Course:</strong> {course_name}</p>
            <p><strong>Preferred Start Date:</strong> {schedule_name}</p>
        </div>
        
        <div style="background: #f3e5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>Career Goals</h3>
            <p>{lead.career_goals if lead.career_goals else 'Not provided'}</p>
        </div>
        
        <div style="background: #fff3e0; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>Lead Information</h3>
            <p><strong>Lead ID:</strong> {lead.id}</p>
            <p><strong>Submitted:</strong> {lead.created_at.strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p><strong>Source:</strong> {lead.source}</p>
        </div>
        
        <div style="text-align: center; margin: 30px 0;">
            <a href="https://wa.me/2349160812845" 
               style="background: #25D366; color: white; padding: 12px 24px; 
                      text-decoration: none; border-radius: 8px; font-weight: bold;">
                Contact Lead via WhatsApp
            </a>
        </div>
        """
        
        mail.send(msg)
        logger.info(f"Notification email sent for lead: {lead.id}")
        
    except Exception as e:
        logger.error(f"Failed to send notification email: {str(e)}")
        raise

def send_welcome_email_to_prospect(lead):
    """Send welcome email to the prospect"""
    try:
        course_names = {
            'video-editing': 'Professional Video Editing',
            'social-media': 'Social Media Management', 
            'web-development': 'Web Development',
            'digital-marketing': 'Digital Marketing',
            'virtual-assistance': 'Virtual Assistance'
        }
        
        course_name = course_names.get(lead.course_selected, lead.course_selected)
        
        msg = MailMessage(
            subject=f"Thank you for your interest in {course_name}!",
            sender=app.config['MAIL_DEFAULT_SENDER'],
            recipients=[lead.email]
        )
        
        msg.html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Welcome to Decipher Academy</title>
        </head>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <h1 style="color: #2563eb;">ðŸŽ“ Decipher Academy</h1>
                    <h2 style="color: #1f2937;">Thank You for Your Interest!</h2>
                </div>
                
                <div style="background: #f8fafc; padding: 25px; border-radius: 10px; margin-bottom: 25px;">
                    <p>Dear {lead.full_name},</p>
                    
                    <p>Thank you for expressing interest in our <strong>{course_name}</strong> course! We're excited about the possibility of helping you achieve your career goals.</p>
                    
                    <p>Here's what happens next:</p>
                    <ul>
                        <li>âœ… Our customer representative will reach out to you within 24 hours</li>
                        <li>ðŸ“‹ We'll discuss your career goals and course expectations</li>
                        <li>ðŸŽ¯ We'll help you choose the perfect start date for your learning journey</li>
                        <li>ðŸ’° We'll explain our current special pricing and payment options</li>
                    </ul>
                </div>
                
                <div style="background: #e0f2fe; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                    <h3 style="color: #0277bd; margin-top: 0;">Course Summary</h3>
                    <p><strong>Course:</strong> {course_name}</p>
                    <p><strong>Your Preferred Start Date:</strong> {lead.cohort_date.replace('-', ' ').title()}</p>
                    <p><strong>Special Price:</strong> Only $19 (Regular Price $200+)</p>
                </div>
                
                <div style="text-align: center; margin: 30px 0;">
                    <p style="margin-bottom: 20px;"><strong>Want to get started immediately?</strong></p>
                    <a href="https://wa.me/2349160812845" 
                       style="background: #25D366; color: white; padding: 15px 30px; 
                              text-decoration: none; border-radius: 8px; font-weight: bold; 
                              display: inline-block; margin: 10px;">
                        ðŸ’¬ Chat with Us on WhatsApp
                    </a>
                </div>
                
                <div style="background: #fff3e0; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                    <h3 style="color: #f57c00; margin-top: 0;">ðŸŽ Free Bonus Resource</h3>
                    <p>While you're here, don't forget to download our free Job Application Bundle with templates and guides to help you in your career journey!</p>
                    <a href="https://deciphersacad.online/job-bundle.html" 
                       style="background: #f59e0b; color: white; padding: 10px 20px; 
                              text-decoration: none; border-radius: 6px; display: inline-block;">
                        Download Free Bundle
                    </a>
                </div>
                
                <div style="border-top: 1px solid #e5e7eb; padding-top: 20px; text-align: center; color: #6b7280;">
                    <p>Best regards,<br>
                    <strong>The Decipher Academy Team</strong></p>
                    <p>ðŸ“§ decipheracad140@gmail.com<br>
                    ðŸ“± +234 916 081 2845</p>
                </div>
            </div>
        </body>
        </html>
        """
        
        mail.send(msg)
        logger.info(f"Welcome email sent to prospect: {lead.email}")
        
    except Exception as e:
        logger.error(f"Failed to send welcome email to prospect: {str(e)}")
        raise

# Add this function to your app.py file

def send_course_interest_email(lead):
    """Send immediate email response when user completes step 3"""
    try:
        course_names = {
            'video-editing': 'Professional Video Editing',
            'social-media': 'Social Media Management',
            'web-development': 'Web Development', 
            'digital-marketing': 'Digital Marketing',
            'virtual-assistance': 'Virtual Assistance'
        }
        
        course_name = course_names.get(lead.course_selected, lead.course_selected)
        
        # Format the cohort date
        if lead.cohort_date in ['may-2025', 'august-2025']:
            schedule_names = {
                'may-2025': 'May 26, 2025',
                'august-2025': 'August 25, 2025'
            }
            start_date = schedule_names.get(lead.cohort_date)
        else:
            # Custom date
            start_date = lead.cohort_date
        
        msg = MailMessage(
            subject=f"Thank you for your interest in {course_name}!",
            sender=app.config['MAIL_DEFAULT_SENDER'],
            recipients=[lead.email]
        )
        
        msg.html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Course Interest Confirmation</title>
        </head>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="text-align: center; margin-bottom: 30px;">
                <h1 style="color: #2563eb;">ðŸŽ“ Decipher Academy</h1>
                <h2 style="color: #1f2937;">We Received Your Course Interest!</h2>
            </div>
            
            <div style="background: #f8fafc; padding: 25px; border-radius: 10px; margin-bottom: 25px;">
                <p>Dear {lead.full_name},</p>
                
                <p>Thank you for your interest in our <strong>{course_name}</strong> course! We're excited to help you achieve your career goals.</p>
                
                <h3 style="color: #2563eb;">Your Registration Details:</h3>
                <ul style="background: white; padding: 15px; border-radius: 8px;">
                    <li><strong>Course:</strong> {course_name}</li>
                    <li><strong>Preferred Start Date:</strong> {start_date}</li>
                    <li><strong>Special Price:</strong> Only $19 (Save over $180!)</li>
                </ul>
            </div>
            
            <div style="background: #e0f2fe; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                <h3 style="color: #0277bd; margin-top: 0;">â° Next Steps:</h3>
                <p>âœ… Complete the final step of your registration<br>
                âœ… Our team will contact you within 24 hours<br>
                âœ… Secure your spot with our limited-time pricing</p>
            </div>
            
            <div style="text-align: center; margin: 30px 0;">
                <p><strong>Ready to secure your spot?</strong></p>
                <a href="https://wa.me/2349160812845" 
                   style="background: #25D366; color: white; padding: 15px 30px; 
                          text-decoration: none; border-radius: 8px; font-weight: bold; 
                          display: inline-block;">
                    ðŸ’¬ Complete Registration on WhatsApp
                </a>
            </div>
            
            <div style="border-top: 1px solid #e5e7eb; padding-top: 20px; text-align: center; color: #6b7280;">
                <p>Best regards,<br>
                <strong>The Decipher Academy Team</strong></p>
                <p>ðŸ“§ decipheracad140@gmail.com | ðŸ“± +234 916 081 2845</p>
            </div>
        </body>
        </html>
        """
        
        mail.send(msg)
        logger.info(f"Course interest email sent to: {lead.email}")
        return True
        
    except Exception as e:
        logger.error(f"Failed to send course interest email: {str(e)}")
        return False




@app.route('/api/course-interest/leads', methods=['GET'])
@token_required  
def get_course_interest_leads(current_user):
    """Get course interest leads (admin only)"""
    try:
        # Check if user is admin (implement your admin check logic)
        if not hasattr(current_user, 'is_admin') or not current_user.is_admin:
            return jsonify({'error': 'Unauthorized access'}), 403
        
        # Get query parameters
        status = request.args.get('status', 'all')
        course = request.args.get('course', 'all')
        date_filter = request.args.get('date', 'all')
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        
        # Build query
        query = CourseInterestLead.query
        
        # Apply filters
        if status != 'all':
            query = query.filter_by(status=status)
        
        if course != 'all':
            query = query.filter_by(course_selected=course)
        
        # Apply date filter
        if date_filter == 'today':
            today = datetime.utcnow().date()
            query = query.filter(func.date(CourseInterestLead.created_at) == today)
        elif date_filter == 'week':
            week_ago = datetime.utcnow() - timedelta(days=7)
            query = query.filter(CourseInterestLead.created_at >= week_ago)
        elif date_filter == 'month':
            month_ago = datetime.utcnow() - timedelta(days=30)
            query = query.filter(CourseInterestLead.created_at >= month_ago)
        
        # Get total count
        total = query.count()
        
        # Order and paginate
        leads = query.order_by(CourseInterestLead.created_at.desc()) \
                     .offset((page - 1) * per_page) \
                     .limit(per_page) \
                     .all()
        
        return jsonify({
            'leads': [lead.to_dict() for lead in leads],
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'pages': (total + per_page - 1) // per_page
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching course interest leads: {str(e)}")
        return jsonify({'error': 'Failed to fetch leads', 'details': str(e)}), 500

@app.route('/api/course-interest/stats', methods=['GET'])
@token_required
def get_course_interest_stats(current_user):
    """Get course interest statistics (admin only)"""
    try:
        # Check if user is admin
        if not hasattr(current_user, 'is_admin') or not current_user.is_admin:
            return jsonify({'error': 'Unauthorized access'}), 403
        
        # Total leads
        total_leads = CourseInterestLead.query.count()
        
        # This month's leads
        month_start = datetime.utcnow().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        this_month = CourseInterestLead.query.filter(
            CourseInterestLead.created_at >= month_start
        ).count()
        
        # Course popularity
        course_stats = db.session.query(
            CourseInterestLead.course_selected,
            func.count(CourseInterestLead.id).label('count')
        ).group_by(CourseInterestLead.course_selected).all()
        
        # Cohort preferences
        cohort_stats = db.session.query(
            CourseInterestLead.cohort_date,
            func.count(CourseInterestLead.id).label('count')
        ).group_by(CourseInterestLead.cohort_date).all()
        
        return jsonify({
            'total_leads': total_leads,
            'this_month': this_month,
            'course_popularity': [{'course': stat[0], 'count': stat[1]} for stat in course_stats],
            'cohort_preferences': [{'cohort': stat[0], 'count': stat[1]} for stat in cohort_stats]
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching course interest stats: {str(e)}")
        return jsonify({'error': 'Failed to fetch stats', 'details': str(e)}), 500

# Add this route to serve the registration form
@app.route('/course-registration.html')
def serve_course_registration():
    return send_from_directory('.', 'course-registration.html')

# Database migration to create the table
def create_course_interest_table():
    """Verify the course_interest_leads table exists (use migrations to create)"""
    try:
        with app.app_context():
            from sqlalchemy import text
            db.session.execute(text("SELECT 1")).fetchone()
            logger.info("âœ… Course interest table verification complete - use migrations to create tables")
    except Exception as e:
        logger.error(f"âŒ Error verifying table: {str(e)}")

# Call this when setting up your database
if __name__ == "__main__":
    create_course_interest_table()

@app.route('/api/webinar-registration', methods=['POST', 'OPTIONS'])
def submit_webinar_registration():
    """Handle webinar registration form submissions"""
    
    # Handle CORS preflight
    if request.method == 'OPTIONS':
        return '', 204
    
    try:
        # Check database connection first
        
        
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        # Validate required fields
        required_fields = ['parent_type', 'parent_name', 'email', 'kids_ages', 'webinar_date', 'webinar_time']
        missing_fields = [field for field in required_fields if not data.get(field)]
        
        if missing_fields:
            return jsonify({
                'error': 'Missing required fields',
                'missing_fields': missing_fields
            }), 400
        
        # Validate email format
        email = data.get('email', '').strip().lower()
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email):
            return jsonify({'error': 'Invalid email format'}), 400
        
        # Check if this email is already registered for this webinar
        existing_registration = WebinarRegistration.query.filter_by(
            email=email,
            webinar_date=data.get('webinar_date')
        ).first()
        
        email_sent = False
        
        if existing_registration:
            # Update existing registration with new information
            existing_registration.parent_type = data.get('parent_type')
            existing_registration.parent_name = data.get('parent_name', '').strip()
            existing_registration.phone_number = data.get('phone_number', '').strip()
            existing_registration.kids_ages = data.get('kids_ages', '').strip()
            existing_registration.challenges = data.get('challenges', '').strip()
            existing_registration.expectations = data.get('expectations', '').strip()
            existing_registration.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            # Send confirmation email if requested
            if data.get('trigger_email'):
                email_sent = send_webinar_confirmation_email(existing_registration)
                send_webinar_notification_email(existing_registration, is_update=True)
            
            return jsonify({
                'message': 'Registration updated successfully',
                'registration_id': existing_registration.id,
                'is_update': True,
                'email_sent': email_sent
            }), 200
        
        # Create new webinar registration
        registration = WebinarRegistration(
            parent_type=data.get('parent_type'),
            parent_name=data.get('parent_name', '').strip(),
            email=email,
            phone_number=data.get('phone_number', '').strip(),
            kids_ages=data.get('kids_ages', '').strip(),
            challenges=data.get('challenges', '').strip(),
            expectations=data.get('expectations', '').strip(),
            webinar_date=data.get('webinar_date'),
            webinar_time=data.get('webinar_time')
        )
        
        # Save to database
        db.session.add(registration)
        db.session.commit()
        
        logger.info(f"New webinar registration: {registration.parent_name} - {registration.email}")
        
        # Send emails if requested
        if data.get('trigger_email'):
            email_sent = send_webinar_confirmation_email(registration)
            send_webinar_notification_email(registration)
        
        return jsonify({
            'message': 'Webinar registration successful',
            'registration_id': registration.id,
            'email_sent': email_sent,
            'next_steps': {
                'calendar_link': generate_calendar_link(registration),
                'whatsapp_group': 'https://chat.whatsapp.com/KxXNJTuJNlWB2WAgxQpXMF?mode=ac_t'
            }
        }), 201
        
    except Exception as e:
        logger.error(f"Webinar registration error: {str(e)}")
        db.session.rollback()
        return jsonify({
            'error': 'Failed to submit registration',
            'details': str(e)
        }), 500

def send_webinar_confirmation_email(registration):
    """Send confirmation email to registrant"""
    try:
        parent_type_display = {
            'working-parent': 'Working Parent',
            'stay-at-home': 'Stay-at-Home Parent',
            'educator': 'Educator/Guardian'
        }
        
        parent_type_text = parent_type_display.get(registration.parent_type, registration.parent_type)
        
        msg = MailMessage(
            subject="ðŸŽ‰ You're Registered! Summer Productivity Webinar",
            sender=app.config['MAIL_DEFAULT_SENDER'],
            recipients=[registration.email]
        )
        
        msg.html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Webinar Registration Confirmed</title>
        </head>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="text-align: center; margin-bottom: 30px;">
                <h1 style="color: #667eea;">ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Decipher Academy</h1>
                <h2 style="color: #1f2937;">You're All Set for Our Webinar!</h2>
            </div>
            
            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 25px; border-radius: 15px; margin-bottom: 25px; text-align: center;">
                <h3 style="color: #0277bd; margin: 0 0 15px 0;">ðŸŽ¯ How to Keep Your Kids Productive and Smart This Summer</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin-top: 20px;">
                    <div style="background: white; padding: 10px; border-radius: 8px;">
                        <strong>ðŸ“… Date</strong><br>August 9th, 2025
                    </div>
                    <div style="background: white; padding: 10px; border-radius: 8px;">
                        <strong>â° Time</strong><br>6:00-8:00 PM GMT+1
                    </div>
                    <div style="background: white; padding: 10px; border-radius: 8px;">
                        <strong>ðŸ’» Platform</strong><br>Zoom (Online)
                    </div>
                    <div style="background: white; padding: 10px; border-radius: 8px;">
                        <strong>ðŸŽ¯ Cost</strong><br>100% FREE
                    </div>
                </div>
            </div>
            
            <div style="background: #f8fafc; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                <h3 style="color: #1f2937; margin-top: 0;">ðŸ“‹ Your Registration Details:</h3>
                <p><strong>Name:</strong> {registration.parent_name}</p>
                <p><strong>Parent Type:</strong> {parent_type_text}</p>
                <p><strong>Children's Ages:</strong> {registration.kids_ages}</p>
                <p><strong>Registration ID:</strong> {registration.id}</p>
            </div>
            
            <div style="background: #fff3e0; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                <h3 style="color: #f57c00; margin-top: 0;">ðŸŽ What You'll Get:</h3>
                <ul style="margin: 0; padding-left: 20px;">
                    <li>âœ… Zoom link sent 24 hours before the webinar</li>
                    <li>âœ… Free Summer Activity Guide (downloading now)</li>
                    <li>âœ… Actionable strategies you can implement immediately</li>
                    <li>âœ… Q&A session with our child development experts</li>
                    <li>âœ… Access to our exclusive parent community</li>
                    <li>âœ… Recording available for 7 days after the event</li>
                </ul>
            </div>
            
            <div style="text-align: center; margin: 30px 0;">
                <a href="https://calendar.google.com/calendar/render?action=TEMPLATE&text=Summer%20Productivity%20Webinar&dates=20250808T170000Z/20250808T190000Z&details=How%20to%20Keep%20Your%20Kids%20Productive%20and%20Smart%20This%20Summer" 
                   style="background: #667eea; color: white; padding: 15px 30px; 
                          text-decoration: none; border-radius: 8px; font-weight: bold; 
                          display: inline-block; margin: 10px;">
                    ðŸ“… Add to Calendar
                </a>
                <br>
                <a href="https://chat.whatsapp.com/KxXNJTuJNlWB2WAgxQpXMF?mode=ac_t" 
                   style="background: #25D366; color: white; padding: 15px 30px; 
                          text-decoration: none; border-radius: 8px; font-weight: bold; 
                          display: inline-block; margin: 10px;">
                    ðŸ’¬ Join Parent Community
                </a>
            </div>
            
            {f'''
            <div style="background: #f3e5f5; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                <h3 style="color: #7b1fa2; margin-top: 0;">ðŸŽ¯ We'll Address Your Specific Challenges:</h3>
                <p><em>"{registration.challenges}"</em></p>
            </div>
            ''' if registration.challenges else ''}
            
            <div style="border-top: 1px solid #e5e7eb; padding-top: 20px; text-align: center; color: #6b7280;">
                <p>Questions? Reply to this email or contact us:</p>
                <p>ðŸ“§ decipheracad140@gmail.com<br>
                ðŸ“± +234 916 081 2845</p>
                <p style="margin-top: 20px;"><strong>See you on August 9th!</strong><br>
                <em>The Decipher Academy Team</em></p>
            </div>
        </body>
        </html>
        """
        
        mail.send(msg)
        logger.info(f"Webinar confirmation email sent to: {registration.email}")
        return True
        
    except Exception as e:
        logger.error(f"Failed to send webinar confirmation email: {str(e)}")
        return False

def send_webinar_notification_email(registration, is_update=False):
    """Send notification email to admin about new registration"""
    try:
        subject = f"{'Updated' if is_update else 'New'} Webinar Registration: {registration.parent_name}"
        
        parent_type_display = {
            'working-parent': 'Working Parent',
            'stay-at-home': 'Stay-at-Home Parent',
            'educator': 'Educator/Guardian'
        }
        
        parent_type_text = parent_type_display.get(registration.parent_type, registration.parent_type)
        
        msg = MailMessage(
            subject=subject,
            sender=app.config['MAIL_DEFAULT_SENDER'],
            recipients=['decipheracad140@gmail.com']
        )
        
        msg.html = f"""
        <h2>{'Updated' if is_update else 'New'} Webinar Registration</h2>
        
        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>Registrant Information</h3>
            <p><strong>Name:</strong> {registration.parent_name}</p>
            <p><strong>Email:</strong> {registration.email}</p>
            <p><strong>Phone:</strong> {registration.phone_number or 'Not provided'}</p>
            <p><strong>Parent Type:</strong> {parent_type_text}</p>
        </div>
        
        <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>Family Details</h3>
            <p><strong>Children's Ages:</strong> {registration.kids_ages}</p>
        </div>
        
        <div style="background: #f3e5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>Challenges</h3>
            <p>{registration.challenges if registration.challenges else 'Not provided'}</p>
        </div>
        
        <div style="background: #e8f5e8; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>Expectations</h3>
            <p>{registration.expectations if registration.expectations else 'Not provided'}</p>
        </div>
        
        <div style="background: #fff3e0; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>Registration Information</h3>
            <p><strong>Registration ID:</strong> {registration.id}</p>
            <p><strong>Webinar Date:</strong> {registration.webinar_date}</p>
            <p><strong>Webinar Time:</strong> {registration.webinar_time}</p>
            <p><strong>Registered:</strong> {registration.created_at.strftime('%Y-%m-%d %H:%M:%S')}</p>
        </div>
        """
        
        mail.send(msg)
        logger.info(f"Webinar notification email sent for registration: {registration.id}")
        
    except Exception as e:
        logger.error(f"Failed to send webinar notification email: {str(e)}")

def generate_calendar_link(registration):
    """Generate Google Calendar link for the webinar"""
    event_title = "How to Keep Your Kids Productive and Smart This Summer"
    event_description = "Free webinar for parents and guardians. Learn effective strategies to keep your children engaged, productive, and learning during the summer break."
    event_location = "Online via Zoom (link will be provided)"
    start_date = "20250808T170000Z"  # 6:00 PM GMT+1 = 5:00 PM UTC
    end_date = "20250808T190000Z"    # 8:00 PM GMT+1 = 7:00 PM UTC
    
    calendar_url = f"https://calendar.google.com/calendar/render?action=TEMPLATE&text={quote(event_title)}&dates={start_date}/{end_date}&details={quote(event_description)}&location={quote(event_location)}"
    
    return calendar_url

# Admin routes for managing webinar registrations
@app.route('/api/webinar-registration/list', methods=['GET'])
@token_required
def get_webinar_registrations(current_user):
    """Get webinar registrations (admin only)"""
    try:
        # Check if user is admin
        if not hasattr(current_user, 'is_admin') or not current_user.is_admin:
            return jsonify({'error': 'Unauthorized access'}), 403
        
        # Get query parameters
        webinar_date = request.args.get('webinar_date', '2025-08-08')
        parent_type = request.args.get('parent_type', 'all')
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        
        # Build query
        query = WebinarRegistration.query.filter_by(webinar_date=webinar_date)
        
        if parent_type != 'all':
            query = query.filter_by(parent_type=parent_type)
        
        # Get total count
        total = query.count()
        
        # Order and paginate
        registrations = query.order_by(WebinarRegistration.created_at.desc()) \
                             .offset((page - 1) * per_page) \
                             .limit(per_page) \
                             .all()
        
        return jsonify({
            'registrations': [reg.to_dict() for reg in registrations],
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'pages': (total + per_page - 1) // per_page
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching webinar registrations: {str(e)}")
        return jsonify({'error': 'Failed to fetch registrations', 'details': str(e)}), 500

@app.route('/api/webinar-registration/stats', methods=['GET'])
@token_required
def get_webinar_stats(current_user):
    """Get webinar registration statistics (admin only)"""
    try:
        # Check if user is admin
        if not hasattr(current_user, 'is_admin') or not current_user.is_admin:
            return jsonify({'error': 'Unauthorized access'}), 403
        
        webinar_date = request.args.get('webinar_date', '2025-08-08')
        
        # Total registrations for this webinar
        total_registrations = WebinarRegistration.query.filter_by(webinar_date=webinar_date).count()
        
        # Parent type breakdown
        parent_type_stats = db.session.query(
            WebinarRegistration.parent_type,
            func.count(WebinarRegistration.id).label('count')
        ).filter_by(webinar_date=webinar_date).group_by(WebinarRegistration.parent_type).all()
        
        # Registration trend (last 7 days)
        seven_days_ago = datetime.utcnow() - timedelta(days=7)
        recent_registrations = WebinarRegistration.query.filter(
            WebinarRegistration.webinar_date == webinar_date,
            WebinarRegistration.created_at >= seven_days_ago
        ).count()
        
        return jsonify({
            'total_registrations': total_registrations,
            'recent_registrations': recent_registrations,
            'parent_type_breakdown': [{'type': stat[0], 'count': stat[1]} for stat in parent_type_stats],
            'webinar_date': webinar_date
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching webinar stats: {str(e)}")
        return jsonify({'error': 'Failed to fetch stats', 'details': str(e)}), 500

# Database initialization
def create_tables():
    """Verify database connectivity (use migrations to create tables)"""
    with app.app_context():
        try:
            from sqlalchemy import text
            db.session.execute(text("SELECT 1")).fetchone()
            logger.info("âœ… Database connectivity verified - use migrations to create tables")
            return True
        except Exception as e:
            logger.error(f"âŒ Error verifying database connectivity: {str(e)}")
            return False

# Application factory pattern
def create_app():
    """Application factory"""
    # Create tables on startup
    create_tables()
    return app

if __name__ == '__main__':
    # Create tables before running
    create_tables()
    
    # Run the application
    app.run(
        host='0.0.0.0',
        port=int(os.environ.get('PORT', 5000)),
        debug=os.environ.get('FLASK_ENV') == 'development'
    )

@app.route('/api/webinar-feedback', methods=['POST', 'OPTIONS'])
def submit_webinar_feedback():
    """Handle webinar feedback form submissions"""
    
    # Handle CORS preflight
    if request.method == 'OPTIONS':
        return '', 204
    
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        # Validate required fields
        required_fields = ['full_name', 'email', 'location', 'category', 'experience', 'improvements']
        missing_fields = [field for field in required_fields if not data.get(field)]
        
        if missing_fields:
            return jsonify({
                'error': 'Missing required fields',
                'missing_fields': missing_fields
            }), 400
        
        # Validate email format
        email = data.get('email', '').strip().lower()
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email):
            return jsonify({'error': 'Invalid email format'}), 400
        
        # Validate category
        valid_categories = ['parent', 'tutor', 'guardian', 'educator']
        if data.get('category') not in valid_categories:
            return jsonify({'error': 'Invalid category'}), 400
        
        # Validate sessions attended
        sessions_attended = data.get('sessions_attended', [])
        valid_sessions = ['morning', 'evening']
        if not sessions_attended or not all(session in valid_sessions for session in sessions_attended):
            return jsonify({'error': 'Invalid sessions attended'}), 400
        
        # Validate rating (optional)
        rating = data.get('rating', 0)
        if rating and (not isinstance(rating, int) or rating < 1 or rating > 5):
            return jsonify({'error': 'Invalid rating. Must be between 1 and 5'}), 400
        
        # Check if this person already submitted feedback for this webinar
        webinar_date = data.get('webinar_date', '2025-08-09')
        existing_feedback = WebinarFeedback.query.filter_by(
            email=email,
            webinar_date=webinar_date
        ).first()
        
        email_sent = False
        
        if existing_feedback:
            # Update existing feedback
            existing_feedback.full_name = data.get('full_name', '').strip()
            existing_feedback.location = data.get('location', '').strip()
            existing_feedback.category = data.get('category')
            existing_feedback.sessions_attended = json.dumps(sessions_attended)
            existing_feedback.rating = rating
            existing_feedback.experience = data.get('experience', '').strip()
            existing_feedback.improvements = data.get('improvements', '').strip()
            existing_feedback.submitted_at = datetime.utcnow()
            
            db.session.commit()
            
            # Send confirmation email
            email_sent = send_feedback_confirmation_email(existing_feedback)
            send_feedback_notification_email(existing_feedback, is_update=True)
            
            return jsonify({
                'message': 'Feedback updated successfully',
                'feedback_id': existing_feedback.id,
                'is_update': True,
                'email_sent': email_sent
            }), 200
        
        # Create new feedback entry
        feedback = WebinarFeedback(
            full_name=data.get('full_name', '').strip(),
            email=email,
            location=data.get('location', '').strip(),
            category=data.get('category'),
            sessions_attended=json.dumps(sessions_attended),
            rating=rating,
            experience=data.get('experience', '').strip(),
            improvements=data.get('improvements', '').strip(),
            webinar_date=webinar_date
        )
        
        # Save to database
        db.session.add(feedback)
        db.session.commit()
        
        logger.info(f"New webinar feedback: {feedback.full_name} - {feedback.email} - Rating: {feedback.rating}")
        
        # Send confirmation and notification emails
        email_sent = send_feedback_confirmation_email(feedback)
        send_feedback_notification_email(feedback)
        
        return jsonify({
            'message': 'Feedback submitted successfully',
            'feedback_id': feedback.id,
            'email_sent': email_sent,
            'thank_you': 'Thank you for helping us improve our webinars!'
        }), 201
        
    except Exception as e:
        logger.error(f"Webinar feedback submission error: {str(e)}")
        db.session.rollback()
        return jsonify({
            'error': 'Failed to submit feedback',
            'details': str(e)
        }), 500

def send_feedback_confirmation_email(feedback):
    """Send confirmation email to feedback submitter"""
    try:
        category_display = {
            'parent': 'Parent',
            'tutor': 'Tutor',
            'guardian': 'Guardian',
            'educator': 'Educator'
        }
        
        category_text = category_display.get(feedback.category, feedback.category)
        sessions_list = json.loads(feedback.sessions_attended) if feedback.sessions_attended else []
        sessions_text = ', '.join([s.title() for s in sessions_list])
        
        rating_text = 'â­' * feedback.rating if feedback.rating else 'Not rated'
        
        msg = MailMessage(
            subject="ðŸ™ Thank You for Your Feedback!",
            sender=app.config['MAIL_DEFAULT_SENDER'],
            recipients=[feedback.email]
        )
        
        msg.html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Feedback Received - Thank You!</title>
        </head>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="text-align: center; margin-bottom: 30px;">
                <h1 style="color: #10B981;">ðŸ’¬ Decipher Academy</h1>
                <h2 style="color: #1f2937;">Thank You for Your Valuable Feedback!</h2>
            </div>
            
            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 25px; border-radius: 15px; margin-bottom: 25px; text-align: center;">
                <h3 style="color: #0277bd; margin: 0 0 15px 0;">ðŸŽ¯ Your Feedback Has Been Received</h3>
                <p style="color: #374151; margin: 0;">We truly appreciate you taking the time to share your experience with us.</p>
            </div>
            
            <div style="background: #f8fafc; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                <h3 style="color: #1f2937; margin-top: 0;">ðŸ“‹ Feedback Summary:</h3>
                <p><strong>Name:</strong> {feedback.full_name}</p>
                <p><strong>Category:</strong> {category_text}</p>
                <p><strong>Location:</strong> {feedback.location}</p>
                <p><strong>Sessions Attended:</strong> {sessions_text}</p>
                <p><strong>Rating:</strong> {rating_text}</p>
                <p><strong>Submitted:</strong> {feedback.submitted_at.strftime('%Y-%m-%d at %H:%M')}</p>
            </div>
            
            <div style="background: #fff3e0; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                <h3 style="color: #f57c00; margin-top: 0;">ðŸš€ What Happens Next:</h3>
                <ul style="margin: 0; padding-left: 20px; color: #374151;">
                    <li>âœ… Your feedback will be reviewed by our team within 24 hours</li>
                    <li>âœ… We'll use your suggestions to improve future webinars</li>
                    <li>âœ… You'll be notified about upcoming educational events</li>
                    <li>âœ… Your insights help us serve our community better</li>
                </ul>
            </div>
            
            <div style="background: #f3e5f5; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                <h3 style="color: #7b1fa2; margin-top: 0;">ðŸ’¡ Your Experience:</h3>
                <p style="font-style: italic; color: #4b5563;">"{feedback.experience[:200]}{'...' if len(feedback.experience) > 200 else ''}"</p>
            </div>
            
            <div style="text-align: center; margin: 30px 0;">
                <a href="https://chat.whatsapp.com/KxXNJTuJNlWB2WAgxQpXMF?mode=ac_t" 
                   style="background: #25D366; color: white; padding: 15px 30px; 
                          text-decoration: none; border-radius: 8px; font-weight: bold; 
                          display: inline-block; margin: 10px;">
                    ðŸ’¬ Join Our Community
                </a>
                <br>
                <a href="mailto:decipheracad140@gmail.com" 
                   style="background: #10B981; color: white; padding: 15px 30px; 
                          text-decoration: none; border-radius: 8px; font-weight: bold; 
                          display: inline-block; margin: 10px;">
                    ðŸ“§ Contact Us
                </a>
            </div>
            
            <div style="border-top: 1px solid #e5e7eb; padding-top: 20px; text-align: center; color: #6b7280;">
                <p>Your feedback helps us create better learning experiences for everyone!</p>
                <p>ðŸ“§ decipheracad140@gmail.com<br>
                ðŸ“± +234 916 081 2845</p>
                <p style="margin-top: 20px;"><strong>Thank you for being part of our community!</strong><br>
                <em>The Decipher Academy Team</em></p>
            </div>
        </body>
        </html>
        """
        
        mail.send(msg)
        logger.info(f"Feedback confirmation email sent to: {feedback.email}")
        return True
        
    except Exception as e:
        logger.error(f"Failed to send feedback confirmation email: {str(e)}")
        return False

def send_feedback_notification_email(feedback, is_update=False):
    """Send notification email to admin about new feedback"""
    try:
        subject = f"{'Updated' if is_update else 'New'} Webinar Feedback: {feedback.full_name}"
        
        category_display = {
            'parent': 'Parent',
            'tutor': 'Tutor', 
            'guardian': 'Guardian',
            'educator': 'Educator'
        }
        
        category_text = category_display.get(feedback.category, feedback.category)
        sessions_list = json.loads(feedback.sessions_attended) if feedback.sessions_attended else []
        sessions_text = ', '.join([s.title() for s in sessions_list])
        
        rating_text = 'â­' * feedback.rating if feedback.rating else 'Not rated'
        
        msg = MailMessage(
            subject=subject,
            sender=app.config['MAIL_DEFAULT_SENDER'],
            recipients=['decipheracad140@gmail.com']
        )
        
        msg.html = f"""
        <h2>{'Updated' if is_update else 'New'} Webinar Feedback Received</h2>
        
        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>Participant Information</h3>
            <p><strong>Name:</strong> {feedback.full_name}</p>
            <p><strong>Email:</strong> {feedback.email}</p>
            <p><strong>Location:</strong> {feedback.location}</p>
            <p><strong>Category:</strong> {category_text}</p>
            <p><strong>Sessions Attended:</strong> {sessions_text}</p>
            <p><strong>Overall Rating:</strong> {rating_text}</p>
        </div>
        
        <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>ðŸ“ Experience Shared</h3>
            <p style="font-style: italic; line-height: 1.6;">{feedback.experience}</p>
        </div>
        
        <div style="background: #f3e5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>ðŸ’¡ Suggestions for Improvement</h3>
            <p style="font-style: italic; line-height: 1.6;">{feedback.improvements}</p>
        </div>
        
        <div style="background: #fff3e0; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>ðŸ“Š Feedback Details</h3>
            <p><strong>Feedback ID:</strong> {feedback.id}</p>
            <p><strong>Webinar Date:</strong> {feedback.webinar_date}</p>
            <p><strong>Submitted:</strong> {feedback.submitted_at.strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p><strong>Status:</strong> {'Updated' if is_update else 'New'}</p>
        </div>
        
        <div style="background: #f0f9ff; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>ðŸŽ¯ Action Items</h3>
            <ul>
                <li>Review feedback for actionable improvements</li>
                <li>Consider incorporating suggestions into future webinars</li>
                <li>Follow up if participant needs additional support</li>
                <li>Update feedback metrics and analytics</li>
            </ul>
        </div>
        """
        
        mail.send(msg)
        logger.info(f"Feedback notification email sent for feedback ID: {feedback.id}")
        
    except Exception as e:
        logger.error(f"Failed to send feedback notification email: {str(e)}")

# Admin routes for managing feedback
@app.route('/api/webinar-feedback/list', methods=['GET'])
@token_required
def get_webinar_feedback(current_user):
    """Get webinar feedback (admin only)"""
    try:
        # Check if user is admin
        if not hasattr(current_user, 'is_admin') or not current_user.is_admin:
            return jsonify({'error': 'Unauthorized access'}), 403
        
        # Get query parameters
        webinar_date = request.args.get('webinar_date', '2025-08-09')
        category = request.args.get('category', 'all')
        rating_filter = request.args.get('rating', 'all')
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        
        # Build query
        query = WebinarFeedback.query.filter_by(webinar_date=webinar_date)
        
        if category != 'all':
            query = query.filter_by(category=category)
        
        if rating_filter != 'all':
            query = query.filter_by(rating=int(rating_filter))
        
        # Get total count
        total = query.count()
        
        # Order and paginate
        feedback_list = query.order_by(WebinarFeedback.submitted_at.desc()) \
                            .offset((page - 1) * per_page) \
                            .limit(per_page) \
                            .all()
        
        return jsonify({
            'feedback': [feedback.to_dict() for feedback in feedback_list],
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'pages': (total + per_page - 1) // per_page
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching webinar feedback: {str(e)}")
        return jsonify({'error': 'Failed to fetch feedback', 'details': str(e)}), 500

@app.route('/api/webinar-feedback/stats', methods=['GET'])
@token_required
def get_feedback_stats(current_user):
    """Get webinar feedback statistics (admin only)"""
    try:
        # Check if user is admin
        if not hasattr(current_user, 'is_admin') or not current_user.is_admin:
            return jsonify({'error': 'Unauthorized access'}), 403
        
        webinar_date = request.args.get('webinar_date', '2025-08-09')
        
        # Total feedback count
        total_feedback = WebinarFeedback.query.filter_by(webinar_date=webinar_date).count()
        
        # Average rating
        avg_rating = db.session.query(func.avg(WebinarFeedback.rating)) \
                              .filter(WebinarFeedback.webinar_date == webinar_date,
                                     WebinarFeedback.rating.isnot(None)) \
                              .scalar()
        
        # Rating breakdown
        rating_stats = db.session.query(
            WebinarFeedback.rating,
            func.count(WebinarFeedback.id).label('count')
        ).filter_by(webinar_date=webinar_date) \
         .filter(WebinarFeedback.rating.isnot(None)) \
         .group_by(WebinarFeedback.rating) \
         .all()
        
        # Category breakdown
        category_stats = db.session.query(
            WebinarFeedback.category,
            func.count(WebinarFeedback.id).label('count')
        ).filter_by(webinar_date=webinar_date) \
         .group_by(WebinarFeedback.category) \
         .all()
        
        # Session attendance breakdown
        session_stats = {}
        all_feedback = WebinarFeedback.query.filter_by(webinar_date=webinar_date).all()
        for feedback in all_feedback:
            sessions = json.loads(feedback.sessions_attended) if feedback.sessions_attended else []
            for session in sessions:
                session_stats[session] = session_stats.get(session, 0) + 1
        
        return jsonify({
            'total_feedback': total_feedback,
            'average_rating': round(avg_rating, 2) if avg_rating else 0,
            'rating_breakdown': [{'rating': stat[0], 'count': stat[1]} for stat in rating_stats],
            'category_breakdown': [{'category': stat[0], 'count': stat[1]} for stat in category_stats],
            'session_breakdown': [{'session': k, 'count': v} for k, v in session_stats.items()],
            'webinar_date': webinar_date
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching feedback stats: {str(e)}")
        return jsonify({'error': 'Failed to fetch stats', 'details': str(e)}), 500

# Initialize feedback tables
def create_feedback_tables():
    """Verify feedback database tables exist (use migrations to create)"""
    with app.app_context():
        try:
            from sqlalchemy import text
            db.session.execute(text("SELECT 1")).fetchone()
            logger.info("âœ… Feedback tables verification complete - use migrations to create tables")
            return True
        except Exception as e:
            logger.error(f"âŒ Error verifying feedback database tables: {str(e)}")
            return False
        
# 1. Enhanced Endpoint to Update Flashcard
@app.route('/api/update-quiz', methods=['POST'])
@token_required
def update_quiz(current_user):
    """API endpoint to update a quiz with edited questions and answers."""
    try:
        data = request.get_json()
        logger.debug(f"Received quiz update request: {data}")
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        # Check for required fields
        required_fields = ['flashcard_set_id', 'quiz_data']
        missing_fields = [field for field in required_fields if field not in data]
        if missing_fields:
            return jsonify({'error': f'Missing required fields: {", ".join(missing_fields)}'}), 400
        
        # Get the flashcard set
        flashcard_set = FlashcardSet.query.get(data['flashcard_set_id'])
        if not flashcard_set:
            return jsonify({'error': 'Flashcard set not found'}), 404
            
        # Check ownership
        if flashcard_set.user_id != current_user.id:
            return jsonify({'error': 'You do not have permission to update quizzes for this flashcard set'}), 403
        
        # Clean and validate quiz data
        quiz_data = data['quiz_data']
        if not isinstance(quiz_data, dict) or 'questions' not in quiz_data:
            return jsonify({'error': 'Invalid quiz data format'}), 400
        
        # Get quiz ID from quiz data or generate a new one
        quiz_id = quiz_data.get('id', f"flashcard-quiz-{data['flashcard_set_id']}")
        
        # Check if quiz already exists in database
        quiz = Quiz.query.filter_by(id=quiz_id).first()
        
        # If quiz doesn't exist, create a new one
        if not quiz:
            quiz = Quiz(
                id=quiz_id,
                flashcard_set_id=data['flashcard_set_id'],
                title=quiz_data.get('title', 'Flashcard Quiz'),
                topic=quiz_data.get('topic', flashcard_set.title),
                grade_level=quiz_data.get('grade_level', 'all'),
                time_limit=quiz_data.get('time_limit', 30),
                quiz_data=quiz_data,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            db.session.add(quiz)
            logger.info(f"Created new quiz {quiz.id} for flashcard set {flashcard_set.id}")
        else:
            # Update existing quiz
            quiz.title = quiz_data.get('title', quiz.title)
            quiz.topic = quiz_data.get('topic', quiz.topic)
            quiz.grade_level = quiz_data.get('grade_level', quiz.grade_level)
            quiz.time_limit = quiz_data.get('time_limit', quiz.time_limit)
            quiz.quiz_data = quiz_data
            quiz.updated_at = datetime.utcnow()
            logger.info(f"Updated quiz {quiz.id} for flashcard set {flashcard_set.id}")
        
        # Commit changes to database
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Quiz updated successfully',
            'quiz_id': quiz.id,
            'quiz_data': quiz.quiz_data
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error updating quiz: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/user/last-quiz', methods=['GET'])
@token_required
def get_last_quiz(current_user):
    """Get the user's most recently generated quiz"""
    try:
        # Query for the most recent quiz created by this user
        last_quiz = Quiz.query.filter_by(user_id=current_user.id)\
            .order_by(Quiz.created_at.desc())\
            .first()
        
        if not last_quiz:
            return jsonify({'error': 'No quizzes found for this user'}), 404
        
        # Prepare the response data structure
        questions = []
        if last_quiz.questions_json:
            try:
                questions = json.loads(last_quiz.questions_json)
            except:
                logger.error(f"Error parsing questions_json for quiz {last_quiz.id}")
        
        # Format the response to match the structure expected by the front-end
        response_data = {
            'quiz_id': last_quiz.id,
            'quiz_data': {
                'title': last_quiz.title,
                'topic': last_quiz.topic,
                'grade_level': last_quiz.grade_level,
                'time_limit': last_quiz.time_limit,
                'mode': last_quiz.mode,
                'questions': questions,
                'created_at': last_quiz.created_at.isoformat() if last_quiz.created_at else None
            }
        }
        
        return jsonify(response_data), 200
        
    except Exception as e:
        logger.error(f"Error retrieving last quiz: {str(e)}")
        return jsonify({'error': 'Failed to retrieve your last quiz'}), 500
        
@app.route('/api/direct-update-quiz/<quiz_id>', methods=['POST'])
@token_required
def direct_update_quiz(current_user, quiz_id):
    """API endpoint to update a quiz with edited questions and answers."""
    try:
        data = request.get_json()
        logger.debug(f"Received quiz update request for {quiz_id}: {data}")
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        # Find the quiz
        quiz = Quiz.query.get(quiz_id)
        if not quiz:
            return jsonify({'error': 'Quiz not found'}), 404
            
        # Check ownership if necessary
        if quiz.user_id and quiz.user_id != current_user.id:
            return jsonify({'error': 'You do not have permission to update this quiz'}), 403
        
        # Clean and validate quiz data
        if not isinstance(data, dict) or 'questions' not in data:
            return jsonify({'error': 'Invalid quiz data format - questions array required'}), 400
        
        # Update quiz data - THIS IS THE FIX: using questions_json instead of quiz_data
        quiz.title = data.get('title', quiz.title)
        quiz.topic = data.get('topic', quiz.topic)
        quiz.grade_level = data.get('grade_level', quiz.grade_level)
        quiz.time_limit = data.get('time_limit', quiz.time_limit)
        quiz.mode = data.get('mode', quiz.mode)
        
        # Store the questions directly in questions_json field
        quiz.questions_json = json.dumps(data['questions'])
        
        # Update timestamp
        quiz.updated_at = datetime.utcnow()
        logger.info(f"Updated quiz {quiz.id}")
        
        # Commit changes to database
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Quiz updated successfully',
            'quiz_id': quiz.id,
            'questions': json.loads(quiz.questions_json)
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error updating quiz: {str(e)}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/identify-learning-gaps', methods=['POST'])
def identify_learning_gaps():
    """
    Analyze quiz submissions to identify learning gaps and provide recommendations for teachers.
    This endpoint examines patterns of incorrect answers to determine conceptual misunderstandings.
    """
    try:
        data = request.get_json()

        if not data:
            return jsonify({'error': 'No data provided'}), 400

        # Validate required fields
        if 'quiz_submissions' not in data or not isinstance(data['quiz_submissions'], list):
            return jsonify({'error': 'Missing or invalid quiz submissions data'}), 400
            
        if 'quiz_data' not in data or not isinstance(data['quiz_data'], dict):
            return jsonify({'error': 'Missing or invalid quiz data'}), 400

        submissions = data['quiz_submissions']
        quiz_data = data['quiz_data']
        
        # Extract topic and grade level from quiz data
        topic = quiz_data.get('topic', 'this subject')
        grade_level = quiz_data.get('grade_level', 'students')
        
        # Collect all questions from the quiz
        questions = quiz_data.get('questions', [])
        if not questions:
            return jsonify({'error': 'No questions found in quiz data'}), 400
            
        # Analyze incorrect answers across all submissions
        incorrect_patterns = []
        
        for question_idx, question in enumerate(questions):
            # Skip questions without options (like paragraph questions)
            if not question.get('options') or question.get('type') == 'paragraph':
                continue
                
            incorrect_count = 0
            total_attempts = 0
            common_wrong_answers = {}
            
            # Analyze each submission for this question
            for submission in submissions:
                answers = submission.get('answers', {})
                
                # Convert string keys to integers if needed
                answer_keys = list(answers.keys())
                for key in answer_keys:
                    if isinstance(key, str) and key.isdigit():
                        answers[int(key)] = answers.pop(key)
                
                # Check if this question was answered
                if question_idx in answers:
                    answer_data = answers[question_idx]
                    total_attempts += 1
                    
                    # If answer was incorrect, track the wrong option chosen
                    if not answer_data.get('isCorrect', False):
                        incorrect_count += 1
                        
                        selected_option = answer_data.get('selectedOption')
                        if selected_option is not None and isinstance(selected_option, int):
                            # Get the text of the wrong answer if available
                            if (question.get('options') and 
                                0 <= selected_option < len(question['options'])):
                                wrong_answer_text = question['options'][selected_option].get('text', 'Unknown')
                                
                                if wrong_answer_text in common_wrong_answers:
                                    common_wrong_answers[wrong_answer_text] += 1
                                else:
                                    common_wrong_answers[wrong_answer_text] = 1
            
            # Only consider questions with significant error rates (30%+ incorrect)
            if total_attempts > 0 and incorrect_count / total_attempts >= 0.3:
                # Find the most common wrong answer(s)
                sorted_wrong_answers = sorted(
                    common_wrong_answers.items(), 
                    key=lambda x: x[1], 
                    reverse=True
                )
                
                # Get correct answer
                correct_option = next(
                    (opt.get('text', 'Unknown') for opt in question.get('options', []) 
                     if opt.get('isCorrect', False)), 
                    'Unknown'
                )
                
                incorrect_patterns.append({
                    'questionIndex': question_idx,
                    'questionText': question.get('text', 'Unknown question'),
                    'errorRate': incorrect_count / total_attempts,
                    'mostCommonWrongAnswers': sorted_wrong_answers[:2],  # Top 2 wrong answers
                    'correctAnswer': correct_option,
                    'totalAttempts': total_attempts
                })
        
        # Sort by error rate (highest first)
        incorrect_patterns.sort(key=lambda x: x['errorRate'], reverse=True)
        
        # If we found patterns, generate learning gap analysis
        if incorrect_patterns:
            # Build prompt for Claude to analyze learning gaps
            prompt = f"""Analyze these patterns of incorrect answers from {grade_level} learning about {topic}.

I'll provide you with questions that students frequently answered incorrectly, along with:
1. The question text
2. The correct answer
3. The most common wrong answers students chose
4. The error rate (percentage of students who got it wrong)

Based on this data, identify specific learning gaps or misconceptions that explain these patterns of errors. For each learning gap you identify:
1. Give the learning gap a concise, specific title
2. Provide a brief description of the misconception or knowledge gap
3. Classify the severity as "high", "medium", or "low" based on error rate and conceptual importance
4. Suggest a specific teaching strategy or recommendation to address this gap

Here are the incorrect answer patterns:
"""

            # Add each pattern to the prompt
            for i, pattern in enumerate(incorrect_patterns[:5]):  # Limit to top 5 patterns
                wrong_answers_text = "; ".join([
                    f"'{ans[0]}' (chosen by {ans[1]} students)" 
                    for ans in pattern['mostCommonWrongAnswers']
                ])
                
                prompt += f"""
Pattern {i+1}:
Question: {pattern['questionText']}
Correct Answer: {pattern['correctAnswer']}
Most Common Wrong Answers: {wrong_answers_text}
Error Rate: {pattern['errorRate'] * 100:.1f}% ({int(pattern['errorRate'] * pattern['totalAttempts'])} out of {pattern['totalAttempts']} students)
"""

            prompt += """
Format your response as a JSON object with this exact structure:
```json
{
  "learningGaps": [
    {
      "id": 1,
      "title": "Specific title of the learning gap",
      "severity": "high|medium|low",
      "description": "Description of the misconception or knowledge gap",
      "suggestion": "Specific recommendation for teachers to address this gap"
    }
  ]
}
```
Identify 2-4 distinct learning gaps based on these patterns. Each gap should represent a fundamental misconception or knowledge deficit that might explain multiple wrong answers.

Just return the learning gaps analysis in the JSON format above, with no additional text before or after.
"""

            # Call Claude API
            try:
                app.logger.info("Sending learning gap analysis request to Claude")
                response = anthropic_client.messages.create(
                    model="claude-3-haiku-20240307",
                    max_tokens=4000,
                    temperature=0.7,
                    messages=[
                        {"role": "user", "content": prompt}
                    ]
                )

                content = response.content[0].text
                app.logger.info(f"Received learning gap analysis from Claude ({len(content)} characters)")

            except Exception as claude_error:
                app.logger.error(f"Claude API error during learning gap analysis: {str(claude_error)}")
                return jsonify({'error': 'Failed to generate learning gap analysis'}), 500

            # Extract and parse the JSON content
            try:
                # Try to extract JSON from markdown code block
                json_start = content.find("```json")
                if json_start != -1:
                    json_start += 7
                    json_end = content.find("```", json_start)
                    json_content = content[json_start:json_end].strip() if json_end != -1 else content[json_start:]
                else:
                    # If no code block, try to find JSON object directly
                    json_start = content.find('{')
                    json_end = content.rfind('}') + 1
                    json_content = content[json_start:json_end] if json_end > json_start else content

                learning_gaps_data = json.loads(json_content)

                if 'learningGaps' not in learning_gaps_data or not isinstance(learning_gaps_data['learningGaps'], list):
                    app.logger.error("Invalid response format: 'learningGaps' key missing or not a list")
                    # Provide a fallback response
                    return jsonify({
                        'learningGaps': [
                            {
                                'id': 1,
                                'title': f"Difficulty with {topic} concepts",
                                'severity': "medium",
                                'description': f"Students show a pattern of misunderstanding key concepts in {topic}.",
                                'suggestion': f"Review foundational concepts in {topic} with additional practice exercises."
                            }
                        ]
                    }), 200
                
                # Add the raw patterns data for reference (optional)
                learning_gaps_data['incorrectPatterns'] = incorrect_patterns
                
                return jsonify(learning_gaps_data), 200

            except (json.JSONDecodeError, Exception) as parsing_error:
                app.logger.error(f"Error parsing learning gaps response: {str(parsing_error)}")
                # Provide a fallback response
                return jsonify({
                    'learningGaps': [
                        {
                            'id': 1,
                            'title': f"Difficulty with {topic} concepts",
                            'severity': "medium",
                            'description': f"Students show patterns of misunderstanding key concepts in {topic}.",
                            'suggestion': f"Review foundational concepts in {topic} with additional practice exercises."
                        }
                    ]
                }), 200
        else:
            # No significant patterns found
            return jsonify({
                'learningGaps': [
                    {
                        'id': 1,
                        'title': "No significant learning gaps identified",
                        'severity': "low",
                        'description': "Students performed well across most concepts, with no clear pattern of misunderstandings.",
                        'suggestion': "Continue with the current teaching approach, which appears to be effective."
                    }
                ]
            }), 200

    except Exception as e:
        app.logger.error(f"Error identifying learning gaps: {str(e)}")
        return jsonify({'error': str(e)}), 500
    
# Improved flashcard set getter with better error handling
@app.route('/api/regenerate-quiz', methods=['POST'])
@token_required
def regenerate_quiz(current_user):
    """API endpoint to regenerate an entire quiz for a flashcard set."""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400
            
        # Extract required fields
        flashcard_set_id = data.get('flashcard_set_id')
        
        if not flashcard_set_id:
            return jsonify({'error': 'Flashcard set ID is required'}), 400
            
        # Get flashcard set
        flashcard_set = FlashcardSet.query.get(flashcard_set_id)
        if not flashcard_set:
            return jsonify({'error': 'Flashcard set not found'}), 404
            
        # Check if the user has access to this flashcard set
        if flashcard_set.user_id != current_user.id:
            # For public sets, we still allow quiz generation but not saving
            is_public_access = True
        else:
            is_public_access = False
            
        # Get flashcards to generate quiz from
        flashcards = Flashcard.query.filter_by(flashcard_set_id=flashcard_set_id).all()
        if not flashcards:
            return jsonify({'error': 'No flashcards found in set'}), 404
            
        # Format flashcards for the quiz generator
        api_flashcards = [{
            'id': card.id,
            'front': card.front,
            'back': card.back,
            'type': card.type
        } for card in flashcards]
        
        # Find existing quiz or create a new quiz ID
        quiz = None
        try:
            quiz = Quiz.query.filter_by(
                user_id=current_user.id,
                title=f"Flashcard Quiz: {flashcard_set.title}"
            ).first()
            
            if not quiz and not is_public_access:
                # Create a new quiz if none exists and user owns the flashcard set
                quiz = Quiz(
                    id=str(uuid.uuid4()),
                    user_id=current_user.id,
                    title=f"Flashcard Quiz: {flashcard_set.title}",
                    topic=flashcard_set.topic,
                    grade_level=flashcard_set.grade_level,
                    time_limit=30,  # Default
                    mode='list',    # Default
                    questions_json='[]'
                )
                db.session.add(quiz)
                db.session.commit()
        except Exception as db_error:
            app.logger.error(f"Database error finding/creating quiz: {str(db_error)}")
            # Continue without quiz object, just generate the content
        
        # Get quiz options from the request or use defaults
        quiz_options = data.get('quiz_options', {})
        question_count = quiz_options.get('questionCount', min(10, len(api_flashcards)))
        time_limit = quiz_options.get('timeLimit', 30)
        question_type = quiz_options.get('questionType', 'multiple_choice')
        quiz_mode = quiz_options.get('quizMode', 'list')
        
        # Build an enhanced quiz prompt
        try:
            # Import the build_quiz_prompt function (make sure this is defined in your app)
            from helpers import build_quiz_prompt
            quiz_prompt = build_quiz_prompt(
                flashcard_set.topic,
                flashcard_set.grade_level,
                question_count,
                question_type,
                api_flashcards
            )
        except ImportError:
            # Fallback if the enhanced prompt builder isn't available
            app.logger.warning("Enhanced build_quiz_prompt not found, using fallback prompt")
            quiz_prompt = f"""Create {question_count} engaging quiz questions about {flashcard_set.topic} for {flashcard_set.grade_level} students.
            
Based on these flashcards:
{chr(10).join([f"- {card['front']}: {card['back']}" for card in api_flashcards[:5]])}
...and {len(api_flashcards)-5} more cards.

Generate diverse, thought-provoking questions that test deeper understanding, not just recall.
Include "why", "how", "compare", "analyze" type questions, not just "what is" questions.

Format your response as JSON with this structure:
```json
{{
  "questions": [
    {{
      "id": "1",
      "text": "Question text goes here?",
      "type": "{question_type}",
      "options": [
        {{"text": "Option A text", "isCorrect": false}},
        {{"text": "Option B text", "isCorrect": true}},
        {{"text": "Option C text", "isCorrect": false}},
        {{"text": "Option D text", "isCorrect": false}}
      ]
    }}
  ]
}}
```
"""

        # Call Claude API for quiz generation
        try:
            app.logger.info(f"Calling Claude API to generate quiz for flashcard set: {flashcard_set_id}")
            
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=4000,
                temperature=0.7,
                messages=[
                    {"role": "user", "content": quiz_prompt}
                ]
            )
            
            content = response.content[0].text
            app.logger.info(f"Received quiz response from Claude ({len(content)} characters)")
            
        except Exception as claude_error:
            app.logger.error(f"Claude API error: {str(claude_error)}")
            return jsonify({'error': 'Failed to generate quiz. Please try again.'}), 500
        
        # Parse the quiz content
        try:
            from helpers import parse_quiz_response
            quiz_questions = parse_quiz_response(content)
        except ImportError:
            # Fallback parser if the enhanced one isn't available
            app.logger.warning("Enhanced parse_quiz_response not found, using fallback parser")
            try:
                # Try to find JSON content between ```json and ``` markers
                json_start = content.find("```json")
                if json_start != -1:
                    json_start += 7  # Skip the ```json marker
                    json_end = content.find("```", json_start)
                    if json_end != -1:
                        json_content = content[json_start:json_end].strip()
                        parsed_data = json.loads(json_content)
                    else:
                        # Try parsing as a complete JSON if no ending marker
                        parsed_data = json.loads(content)
                else:
                    # Try parsing as a complete JSON if no markers
                    parsed_data = json.loads(content)
                    
                # Extract questions
                if 'questions' in parsed_data and isinstance(parsed_data['questions'], list):
                    quiz_questions = parsed_data['questions']
                else:
                    # Return empty list if no questions found
                    quiz_questions = []
                    
            except json.JSONDecodeError:
                # Try to extract JSON using curly braces
                try:
                    json_start = content.find('{')
                    json_end = content.rfind('}') + 1
                    if json_start >= 0 and json_end > json_start:
                        json_content = content[json_start:json_end]
                        parsed_data = json.loads(json_content)
                        
                        if 'questions' in parsed_data and isinstance(parsed_data['questions'], list):
                            quiz_questions = parsed_data['questions']
                        else:
                            quiz_questions = []
                    else:
                        quiz_questions = []
                except:
                    quiz_questions = []
        
        if not quiz_questions or len(quiz_questions) == 0:
            app.logger.error(f"Failed to parse questions from Claude response: {content[:500]}")
            return jsonify({'error': 'Failed to parse generated quiz questions'}), 500
        
        # Ensure all questions have unique IDs
        for i, question in enumerate(quiz_questions):
            if 'id' not in question or not question['id']:
                question['id'] = f"q{i+1}"
                
            # Ensure options have isCorrect property
            if 'options' in question:
                has_correct = False
                for option in question['options']:
                    if option.get('isCorrect'):
                        has_correct = True
                        break
                        
                # If no correct option, mark the first one as correct
                if not has_correct and len(question['options']) > 0:
                    question['options'][0]['isCorrect'] = True
        
        # Update quiz in database if the quiz object exists and user has permission
        if quiz and not is_public_access:
            try:
                quiz.questions_json = json.dumps(quiz_questions)
                quiz.time_limit = time_limit
                quiz.mode = quiz_mode
                quiz.updated_at = datetime.utcnow()
                db.session.commit()
                app.logger.info(f"Updated quiz in database with ID: {quiz.id}")
            except Exception as db_error:
                app.logger.error(f"Database error updating quiz: {str(db_error)}")
                # Continue without failing - we'll still return the generated questions
        
        # Create the response data
        quiz_data = {
            'id': quiz.id if quiz else f"flashcard-quiz-{flashcard_set_id}",
            'title': f"Flashcard Quiz: {flashcard_set.title}",
            'topic': flashcard_set.topic,
            'grade_level': flashcard_set.grade_level,
            'time_limit': time_limit,
            'mode': quiz_mode,
            'questions': quiz_questions,
            'flashcard_set_id': flashcard_set_id
        }
        
        return jsonify({
            'success': True,
            'quiz_data': quiz_data,
            'quiz_id': quiz.id if quiz else None,
            'is_saved': not is_public_access and quiz is not None
        }), 200
        
    except Exception as e:
        app.logger.error(f"Error regenerating quiz: {str(e)}")
        import traceback
        app.logger.error(traceback.format_exc())
        return jsonify({'error': str(e)}), 500
    
@app.route('/api/generate-explanations', methods=['POST'])
def generate_explanations():
    """Generate AI explanations for incorrect quiz answers."""
    try:
        data = request.get_json()

        if not data:
            return jsonify({'error': 'No data provided'}), 400

        if 'incorrectAnswers' not in data or not isinstance(data['incorrectAnswers'], list):
            return jsonify({'error': 'Invalid incorrect answers data'}), 400

        topic = data.get('topic', 'this topic')
        incorrect_answers = data['incorrectAnswers']

        if len(incorrect_answers) == 0:
            return jsonify({'explanations': []}), 200

        # Build prompt for Claude
        prompt = f"""Generate educational explanations for the following incorrect quiz answers on {topic}.

For each incorrect answer, I'll provide:
1. The question text
2. The user's incorrect answer
3. The correct answer

For select-all-that-apply questions, I'll provide multiple selected options and multiple correct options.

Please give a detailed, educational explanation for each question that:
- Explains why the correct answer is right
- Explains why the user's answer is wrong
- For select-all questions, explain both incorrect selections and missed correct selections
- Provides additional context or information to help understand the concept
- Is written in a supportive, educational tone
- Is concise (50-100 words per explanation)

Here are the incorrect answers:
"""

        for i, item in enumerate(incorrect_answers):
            prompt += f"""
Question {i+1}: {item['question']}
"""
            # Different handling based on question type
            if item.get('questionType') == 'select_all':
                prompt += f"User's Selections: {', '.join(item['userAnswers']) if isinstance(item.get('userAnswers'), list) else item.get('userAnswer', 'None')}\n"
                prompt += f"Correct Selections: {', '.join(item['correctAnswers']) if isinstance(item.get('correctAnswers'), list) else item.get('correctAnswer', 'None')}\n"
            else:
                prompt += f"User's Answer: {item['userAnswer']}\n"
                prompt += f"Correct Answer: {item['correctAnswer']}\n"

        prompt += """
Format your response as a JSON object with this exact structure:
```json
{
  "explanations": [
    {
      "questionIndex": 0,
      "question": "Question text",
      "userAnswer": "User's incorrect answer",
      "correctAnswer": "The correct answer",
      "explanation": "Your detailed explanation here"
    }
  ]
}
```
Just return the explanations in the JSON format above, with no additional text before or after.
"""

        # Call Claude API - using anthropic directly like the other endpoints
        try:
            # This is the fix: using anthropic directly instead of client
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=4000,
                temperature=0.7,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )

            content = response.content[0].text
            app.logger.info(f"Received explanation response from Claude ({len(content)} characters)")

        except Exception as claude_error:
            app.logger.error(f"Claude API error: {str(claude_error)}")
            return jsonify({'error': 'Failed to generate explanations'}), 500

        # Try to extract and parse the JSON content
        try:
            json_start = content.find("```json")
            if json_start != -1:
                json_start += 7
                json_end = content.find("```", json_start)
                json_content = content[json_start:json_end].strip() if json_end != -1 else content[json_start:]
            else:
                json_content = content

            explanation_data = json.loads(json_content)

            if 'explanations' not in explanation_data or not isinstance(explanation_data['explanations'], list):
                app.logger.error("Invalid response format: 'explanations' key missing or not a list")
                return jsonify({'error': 'Invalid response format from AI'}), 500

            return jsonify(explanation_data), 200

        except json.JSONDecodeError as e:
            app.logger.error(f"JSON parsing error: {str(e)}")

            try:
                json_start = content.find('{')
                json_end = content.rfind('}') + 1
                json_content = content[json_start:json_end]
                explanation_data = json.loads(json_content)

                if 'explanations' in explanation_data and isinstance(explanation_data['explanations'], list):
                    return jsonify(explanation_data), 200
                else:
                    return jsonify({'error': 'Invalid response format from AI'}), 500
            except Exception as final_error:
                app.logger.error(f"Final JSON parse failure: {str(final_error)}")
                return jsonify({'error': 'Failed to parse AI response'}), 500

    except Exception as e:
        app.logger.error(f"Error generating explanations: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/evaluate-paragraph', methods=['POST'])
# @token_required  - removed for testing
def evaluate_paragraph():  # Remove the current_user parameter
    try:
        data = request.get_json()
        logger.debug(f"Received paragraph evaluation request: {data}")
        
        # Required fields
        if not all(key in data for key in ['question_text', 'student_answer']):
            return jsonify({'error': 'Missing required fields'}), 400
        
        # Optional fields
        grade_level = data.get('grade_level', 'high school')
        topic = data.get('topic', 'general knowledge')
        reference_answer = data.get('reference_answer')
        rubric = data.get('rubric')
        
        # Build prompt for Claude
        prompt = f"""Evaluate the following student's paragraph answer for an educational quiz question.

Question: {data['question_text']}
Student's Answer: {data['student_answer']}
"""

        if reference_answer:
            prompt += f"\nReference Answer: {reference_answer}\n"
        if rubric:
            prompt += f"\nRubric: {rubric}\n"
        
        prompt += f"""
Topic: {topic}
Grade Level: {grade_level}

Please evaluate the student's answer on a scale of 0-100% with 70% being a passing grade.

Your evaluation should include:
1. A score (0-100)
2. An analysis of the strengths of the answer
3. Areas for improvement
4. A supportive, encouraging explanation for the student
5. Additional knowledge or context the student should learn about this topic

Format your response as a JSON object with this structure:
```json
{{
  "score": 85,
  "explanation": "Your detailed feedback for the student here...",
  "strengths": ["Point 1", "Point 2"],
  "improvements": ["Area 1", "Area 2"],
  "additional_knowledge": "Additional context or information about the topic..."
}}
"""

        # Call Claude API
        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=2000,
                temperature=0.7,
                messages=[{"role": "user", "content": prompt}]
            )
            content = response.content[0].text
            logger.info(f"Received paragraph evaluation from Claude: {len(content)} characters")
        except Exception as claude_error:
            logger.error(f"Claude API error during paragraph evaluation: {str(claude_error)}")
            return jsonify({'error': 'Failed to evaluate paragraph answer'}), 500

        # Parse Claude's response
        try:
            json_start = content.find('{')
            json_end = content.rfind('}') + 1

            if json_start >= 0 and json_end > json_start:
                json_content = content[json_start:json_end]
                result = json.loads(json_content)

                # Ensure required keys exist
                result.setdefault('score', 0)
                result.setdefault('explanation', "Sorry, we couldn't provide detailed feedback for this answer.")
                result.setdefault('strengths', [])
                result.setdefault('improvements', [])
                result.setdefault('additional_knowledge', '')

                return jsonify(result), 200
            else:
                raise ValueError("No valid JSON found in Claude response")

        except Exception as parse_error:
            logger.error(f"Error parsing paragraph evaluation response: {str(parse_error)}")
            return jsonify({
                'score': 0,
                'explanation': "We encountered an error while evaluating your answer. Please try again.",
                'strengths': [],
                'improvements': ["Unable to evaluate answer"],
                'additional_knowledge': '',
                'error': str(parse_error)
            }), 500

    except Exception as e:
        logger.error(f"Paragraph evaluation error: {str(e)}")
        return jsonify({'error': str(e)}), 500


# Enhanced Flask routes for paragraph answer evaluation

@app.route('/api/evaluate-paragraph-batch', methods=['POST'])
def evaluate_paragraph_batch():
    """Evaluate multiple paragraph answers and return scores."""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
            
        if 'paragraphs' not in data or not isinstance(data['paragraphs'], list):
            return jsonify({'error': 'Invalid paragraphs data'}), 400
            
        story_context = data.get('story_context', '')
        paragraphs = data['paragraphs']
        
        if len(paragraphs) == 0:
            return jsonify({'results': []}), 200
            
        # Build comprehensive prompt for batch evaluation
        prompt = f"""You are an educational AI assistant evaluating student paragraph responses to questions about a story. 

STORY CONTEXT:
{story_context}

Your task is to evaluate each student response and provide:
1. A score from 0-100 (where 70+ is passing)
2. Brief constructive feedback
3. Specific areas of strength
4. Suggestions for improvement

Scoring Guidelines:
- 90-100: Exceptional understanding, detailed analysis, excellent writing
- 80-89: Good understanding, solid analysis, clear writing
- 70-79: Adequate understanding, basic analysis, acceptable writing
- 60-69: Partial understanding, limited analysis, needs improvement
- 50-59: Minimal understanding, weak analysis, significant improvement needed
- Below 50: Little to no understanding, major misconceptions

For each response, consider:
- Accuracy of content understanding
- Depth of analysis and critical thinking
- Use of specific examples from the story
- Writing clarity and organization
- Appropriate length and detail

Here are the paragraph responses to evaluate:

"""

        # Add each paragraph to the prompt
        for i, paragraph in enumerate(paragraphs):
            prompt += f"""
QUESTION {i+1}: {paragraph['question']}
EXPECTED THEMES/CONCEPTS: {paragraph.get('expected_themes', 'Not specified')}
MINIMUM WORD COUNT: {paragraph.get('min_words', 30)} words

STUDENT RESPONSE:
"{paragraph['answer']}"

WORD COUNT: {len(paragraph['answer'].split())} words

---
"""

        prompt += """
Please evaluate each response and return ONLY a JSON object with this exact structure:

{
  "evaluations": [
    {
      "question_index": 0,
      "score": 85,
      "feedback": "Great analysis showing understanding of genetic diversity. You effectively connected the story's themes to real-world concepts.",
      "strengths": ["Clear understanding of main themes", "Good use of story examples", "Well-organized response"],
      "improvements": ["Could expand on the scientific concepts", "Consider adding more specific details"],
      "meets_length": true,
      "word_count": 45
    }
  ]
}

Ensure scores are integers between 0-100, and feedback is encouraging yet constructive.
"""

        # Call Claude API
        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=4000,
                temperature=0.3,  # Lower temperature for more consistent scoring
                messages=[{"role": "user", "content": prompt}]
            )
            
            content = response.content[0].text
            app.logger.info(f"Received paragraph evaluation response ({len(content)} characters)")
            
        except Exception as claude_error:
            app.logger.error(f"Claude API error: {str(claude_error)}")
            return jsonify({'error': 'Failed to evaluate paragraphs'}), 500
            
        # Parse Claude's response
        try:
            # Extract JSON from response
            json_start = content.find('{')
            json_end = content.rfind('}') + 1
            
            if json_start >= 0 and json_end > json_start:
                json_content = content[json_start:json_end]
                evaluation_data = json.loads(json_content)
                
                # Validate response structure
                if 'evaluations' not in evaluation_data:
                    raise ValueError("Missing 'evaluations' key in response")
                    
                # Ensure all required fields are present and add defaults if missing
                for eval_item in evaluation_data['evaluations']:
                    eval_item.setdefault('score', 0)
                    eval_item.setdefault('feedback', 'Unable to provide detailed feedback.')
                    eval_item.setdefault('strengths', [])
                    eval_item.setdefault('improvements', [])
                    eval_item.setdefault('meets_length', False)
                    eval_item.setdefault('word_count', 0)
                    
                    # Ensure score is within valid range
                    eval_item['score'] = max(0, min(100, int(eval_item['score'])))
                
                return jsonify(evaluation_data), 200
                
            else:
                raise ValueError("No valid JSON found in response")
                
        except Exception as parse_error:
            app.logger.error(f"Error parsing evaluation response: {str(parse_error)}")
            
            # Return fallback scores
            fallback_results = {
                'evaluations': [
                    {
                        'question_index': i,
                        'score': 60,  # Default passing score
                        'feedback': 'We encountered an issue evaluating your response. Please review your answer and try again.',
                        'strengths': ['Response submitted'],
                        'improvements': ['Unable to evaluate specific areas'],
                        'meets_length': len(p['answer'].split()) >= p.get('min_words', 30),
                        'word_count': len(p['answer'].split())
                    }
                    for i, p in enumerate(paragraphs)
                ]
            }
            return jsonify(fallback_results), 200
            
    except Exception as e:
        app.logger.error(f"Paragraph batch evaluation error: {str(e)}")
        return jsonify({'error': str(e)}), 500

UPLOAD_FOLDER = 'static/uploads'
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

def get_db_connection():
    """Create and return database connection"""
    try:
        connection = mysql.connector.connect(**DB_CONFIG)
        return connection
    except Error as e:
        logger.error(f"Database connection error: {e}")
        return None

def allowed_file(filename):
    """Check if uploaded file is allowed"""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def optimize_image(image_data, max_width=800, max_height=600, quality=85):
    """Optimize uploaded image for web"""
    try:
        image = Image.open(io.BytesIO(image_data))
        
        # Convert to RGB if necessary
        if image.mode in ('RGBA', 'P'):
            image = image.convert('RGB')
        
        # Resize if needed
        if image.width > max_width or image.height > max_height:
            image.thumbnail((max_width, max_height), Image.Resampling.LANCZOS)
        
        # Save optimized image
        output = io.BytesIO()
        image.save(output, format='JPEG', quality=quality, optimize=True)
        return output.getvalue()
    except Exception as e:
        logger.error(f"Image optimization error: {e}")
        return image_data

@app.route('/')
def admin_panel():
    """Serve the admin panel"""
    # In a real application, you'd serve the HTML file
    # For now, redirect to admin panel
    return redirect('/admin')

@app.route('/story-admin')
def storyadmin():
    """Admin panel route"""
    # Return the HTML content from the artifact
    # In production, this would be served as a static file
    return render_template_string("""
    <!DOCTYPE html>
    <html>
    <head>
        <title>Story Builder Admin</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body>
        <h1>Story Builder Admin Panel</h1>
        <p>The admin panel would be served here with the full HTML from the artifact.</p>
        <p>Access the API endpoints:</p>
        <ul>
            <li>GET /api/stories - List all stories</li>
            <li>POST /api/stories - Create new story</li>
            <li>GET /api/stories/{id} - Get specific story</li>
            <li>PUT /api/stories/{id} - Update story</li>
            <li>DELETE /api/stories/{id} - Delete story</li>
        </ul>
    </body>
    </html>
    """)

# ================================
# STORY MANAGEMENT ENDPOINTS
# ================================

@app.route('/api/stories', methods=['GET'])
def get_stories():
    """Get all stories with overview data"""
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = connection.cursor(dictionary=True)
        
        # Use the story_overview view for aggregated data
        cursor.execute("""
            SELECT id, title, subtitle, status, created_at, published_at, 
                   view_count, chapter_count, question_count, 
                   total_attempts, completed_attempts, average_score
            FROM story_overview 
            ORDER BY created_at DESC
        """)
        
        stories = cursor.fetchall()
        
        # Convert datetime objects to strings
        for story in stories:
            for key, value in story.items():
                if isinstance(value, datetime):
                    story[key] = value.isoformat()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'stories': stories,
            'total': len(stories)
        })
        
    except Error as e:
        logger.error(f"Error fetching stories: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/stories', methods=['POST'])
def create_story():
    """Create a new story"""
    try:
        data = request.get_json()
        
        # Validation
        required_fields = ['title', 'chapters', 'questions']
        for field in required_fields:
            if field not in data:
                return jsonify({'error': f'Missing required field: {field}'}), 400
        
        if len(data['chapters']) != 3:
            return jsonify({'error': 'Exactly 3 chapters are required'}), 400
        
        connection = get_db_connection()
        if not connection:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = connection.cursor()
        
        try:
            # Start transaction
            connection.start_transaction()
            
            # Generate URL slug
            url_slug = data['title'].lower().replace(' ', '-').replace('!', '').replace('?', '')
            url_slug = ''.join(c for c in url_slug if c.isalnum() or c == '-')
            
            # Insert story
            story_query = """
                INSERT INTO stories (title, subtitle, description, status, url_slug,
                                   background_type, primary_color, secondary_color, animated_elements)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            
            bg_settings = data.get('backgroundSettings', {})
            story_values = (
                data['title'],
                data.get('subtitle', ''),
                data.get('description', ''),
                data.get('status', 'draft'),
                url_slug,
                bg_settings.get('type', 'gradient'),
                bg_settings.get('primaryColor', '#87CEEB'),
                bg_settings.get('secondaryColor', '#B0E0E6'),
                bg_settings.get('animatedElements', 'all')
            )
            
            cursor.execute(story_query, story_values)
            story_id = cursor.lastrowid
            
            # Insert chapters
            for i, chapter in enumerate(data['chapters'], 1):
                chapter_query = """
                    INSERT INTO chapters (story_id, chapter_number, title, content, image_url)
                    VALUES (%s, %s, %s, %s, %s)
                """
                chapter_values = (
                    story_id,
                    i,
                    chapter['title'],
                    chapter['content'],
                    chapter.get('image')
                )
                cursor.execute(chapter_query, chapter_values)
            
            # Insert questions
            for i, question in enumerate(data['questions'], 1):
                question_query = """
                    INSERT INTO questions (story_id, question_number, question_text, 
                                         question_type, answer_station_id, explanation, 
                                         guidelines, min_words)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """
                question_values = (
                    story_id,
                    i,
                    question['question'],
                    question['type'],
                    question.get('answerStationId'),
                    question.get('explanation'),
                    question.get('guidelines'),
                    question.get('minWords', 30)
                )
                cursor.execute(question_query, question_values)
                question_id = cursor.lastrowid
                
                # Insert multiple choice options if applicable
                if question['type'] == 'multiple-choice' and 'options' in question:
                    for j, option in enumerate(question['options']):
                        option_query = """
                            INSERT INTO question_options (question_id, option_letter, option_text, is_correct)
                            VALUES (%s, %s, %s, %s)
                        """
                        option_values = (
                            question_id,
                            chr(65 + j),
                            option,
                            j == question.get('correct', 0)
                        )
                        cursor.execute(option_query, option_values)
            
            connection.commit()
            
            cursor.close()
            connection.close()
            
            return jsonify({
                'success': True,
                'message': 'Story updated successfully'
            })
            
        except Exception as e:
            connection.rollback()
            raise e
            
    except Error as e:
        logger.error(f"Error updating story: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/stories/<int:story_id>', methods=['DELETE'])
def delete_story(story_id):
    """Delete a story and all related data"""
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = connection.cursor()
        
        # Check if story exists
        cursor.execute("SELECT id FROM stories WHERE id = %s", (story_id,))
        if not cursor.fetchone():
            return jsonify({'error': 'Story not found'}), 404
        
        # Delete story (CASCADE will handle related data)
        cursor.execute("DELETE FROM stories WHERE id = %s", (story_id,))
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'message': 'Story deleted successfully'
        })
        
    except Error as e:
        logger.error(f"Error deleting story: {e}")
        return jsonify({'error': str(e)}), 500

# ================================
# FILE UPLOAD ENDPOINTS
# ================================

@app.route('/api/upload-image', methods=['POST'])
def upload_image():
    """Handle image uploads for chapters"""
    try:
        if 'image' not in request.files:
            return jsonify({'error': 'No image file provided'}), 400
        
        file = request.files['image']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400
        
        if not allowed_file(file.filename):
            return jsonify({'error': 'Invalid file type'}), 400
        
        # Generate unique filename
        filename = str(uuid.uuid4()) + '.jpg'
        filepath = os.path.join(UPLOAD_FOLDER, filename)
        
        # Optimize and save image
        image_data = file.read()
        optimized_data = optimize_image(image_data)
        
        with open(filepath, 'wb') as f:
            f.write(optimized_data)
        
        # Return the URL for the uploaded image
        image_url = f'/static/uploads/{filename}'
        
        return jsonify({
            'success': True,
            'image_url': image_url,
            'filename': filename
        })
        
    except Exception as e:
        logger.error(f"Error uploading image: {e}")
        return jsonify({'error': str(e)}), 500

# ================================
# STORY VIEWING ENDPOINTS
# ================================

@app.route('/story/<string:url_slug>')
def view_story(url_slug):
    """Serve the interactive story to readers"""
    try:
        connection = get_db_connection()
        if not connection:
            return "Database connection failed", 500
        
        cursor = connection.cursor(dictionary=True)
        
        # Get story by URL slug
        cursor.execute("SELECT * FROM stories WHERE url_slug = %s AND status = 'published'", (url_slug,))
        story = cursor.fetchone()
        
        if not story:
            return "Story not found", 404
        
        # Get chapters
        cursor.execute("""
            SELECT * FROM chapters 
            WHERE story_id = %s 
            ORDER BY chapter_number
        """, (story['id'],))
        chapters = cursor.fetchall()
        
        # Get questions with options
        cursor.execute("""
            SELECT q.*, 
                   GROUP_CONCAT(
                       CONCAT(qo.option_letter, ':', qo.option_text, ':', qo.is_correct) 
                       ORDER BY qo.option_letter SEPARATOR '|'
                   ) as options_data
            FROM questions q
            LEFT JOIN question_options qo ON q.id = qo.question_id
            WHERE q.story_id = %s 
            GROUP BY q.id
            ORDER BY q.question_number
        """, (story['id'],))
        questions = cursor.fetchall()
        
        # Process questions for JavaScript
        processed_questions = []
        for q in questions:
            question_data = {
                'id': q['id'],
                'question': q['question_text'],
                'type': q['question_type'],
                'answerStationId': q['answer_station_id'],
                'explanation': q['explanation'],
                'guidelines': q['guidelines'],
                'minWords': q['min_words']
            }
            
            if q['question_type'] == 'multiple-choice' and q['options_data']:
                options = []
                correct_index = 0
                
                for i, option_str in enumerate(q['options_data'].split('|')):
                    letter, text, is_correct = option_str.split(':', 2)
                    options.append(text)
                    if is_correct == '1':
                        correct_index = i
                
                question_data['options'] = options
                question_data['correct'] = correct_index
            
            processed_questions.append(question_data)
        
        cursor.close()
        connection.close()
        
        # Generate the story HTML (using template from original code)
        story_html = generate_story_html(story, chapters, processed_questions)
        
        return story_html
        
    except Error as e:
        logger.error(f"Error serving story: {e}")
        return "Error loading story", 500

def generate_story_html(story, chapters, questions):
    """Generate the complete story HTML"""
    
    # Background CSS based on settings
    background_css = generate_background_css(story)
    
    chapters_html = ""
    for i, chapter in enumerate(chapters, 1):
        image_html = ""
        if chapter['image_url']:
            image_html = f'''
                <div class="chapter-image-frame chapter{i}-frame">
                    <img class="chapter-image loaded" src="{chapter['image_url']}" alt="Chapter {i} illustration">
                </div>
            '''
        
        chapters_html += f'''
            <div class="chapter visible" id="chapter{i}">
                <div class="chapter-number">Chapter {i}</div>
                <div class="chapter-title">{chapter['title']}</div>
                {image_html}
                <div class="story-text">{chapter['content']}</div>
            </div>
        '''
    
    # Convert questions to JavaScript
    questions_js = json.dumps(questions)
    
    return f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{story['title']}</title>
    <style>
        /* Include the complete CSS from your original template */
        @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Playfair+Display:wght@400;700&display=swap');
        
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}

        body {{
            font-family: 'Crimson Text', serif;
            background: {background_css};
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }}

        /* All your existing CSS styles here */
        .story-container {{
            position: relative;
            z-index: 10;
            max-width: 900px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            overflow: hidden;
        }}

        .story-header {{
            background: linear-gradient(135deg, #6B73FF 0%, #000DFF 100%);
            color: white;
            text-align: center;
            padding: 30px;
            position: relative;
        }}

        .story-title {{
            font-family: 'Playfair Display', serif;
            font-size: 3em;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }}

        .story-subtitle {{
            font-size: 1.4em;
            opacity: 0.9;
            font-style: italic;
        }}

        .story-content {{
            height: 70vh;
            overflow-y: auto;
            padding: 40px;
            position: relative;
            font-size: 1.4em;
            transition: font-size 0.3s ease;
        }}

        .chapter {{
            margin-bottom: 50px;
            opacity: 1;
            transform: translateY(0);
        }}

        .chapter-number {{
            font-family: 'Playfair Display', serif;
            font-size: 2em;
            color: #6B73FF;
            font-weight: 700;
            margin-bottom: 15px;
            text-align: center;
        }}

        .chapter-title {{
            font-family: 'Playfair Display', serif;
            font-size: 2.2em;
            color: #333;
            font-weight: 700;
            margin-bottom: 25px;
            text-align: center;
            border-bottom: 2px solid #6B73FF;
            padding-bottom: 10px;
        }}

        .story-text {{
            font-size: 1.4em;
            line-height: 1.8;
            color: #444;
            text-align: justify;
            margin-bottom: 20px;
            white-space: pre-wrap;
        }}

        .chapter-image-frame {{
            width: 100%;
            height: 300px;
            margin: 30px 0;
            border-radius: 20px;
            padding: 15px;
            background: linear-gradient(45deg, #f8f9ff, #e8f0ff);
            border: 3px solid #6B73FF;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }}

        .chapter-image {{
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 15px;
        }}

        .quiz-section {{
            background: linear-gradient(45deg, #f8f9ff, #e8f0ff);
            border-radius: 20px;
            padding: 30px;
            margin: 40px 0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 3px solid #6B73FF;
            display: none;
        }}

        .quiz-section.active {{
            display: block;
        }}

        .quiz-header {{
            text-align: center;
            margin-bottom: 30px;
        }}

        .quiz-title {{
            font-family: 'Playfair Display', serif;
            font-size: 2.5em;
            color: #6B73FF;
            margin-bottom: 10px;
        }}

        .question-text {{
            font-size: 1.6em;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
        }}

        .answer-options {{
            display: grid;
            gap: 15px;
            margin-bottom: 30px;
        }}

        .answer-option {{
            background: linear-gradient(45deg, #f8f9ff, #e8f0ff);
            border: 2px solid #e0e0e0;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.3em;
            display: flex;
            align-items: center;
        }}

        .answer-option:hover {{
            border-color: #6B73FF;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }}

        .answer-option.selected {{
            background: linear-gradient(45deg, #6B73FF, #000DFF);
            color: white;
            border-color: #6B73FF;
        }}

        .answer-option.correct {{
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            border-color: #28a745;
        }}

        .answer-option.incorrect {{
            background: linear-gradient(45deg, #dc3545, #e74c3c);
            color: white;
            border-color: #dc3545;
        }}

        .option-letter {{
            background: rgba(255, 255, 255, 0.2);
            color: #6B73FF;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            font-size: 1.2em;
        }}

        .answer-option.selected .option-letter,
        .answer-option.correct .option-letter,
        .answer-option.incorrect .option-letter {{
            background: rgba(255, 255, 255, 0.3);
            color: white;
        }}

        .paragraph-question {{
            background: linear-gradient(45deg, #fff9e6, #fef5d3);
            border: 3px solid #f39c12;
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            display: none;
        }}

        .paragraph-textarea {{
            width: 100%;
            min-height: 150px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 15px;
            font-family: 'Crimson Text', serif;
            font-size: 1.2em;
            line-height: 1.6;
            resize: vertical;
            background: rgba(255, 255, 255, 0.9);
            transition: all 0.3s ease;
        }}

        .paragraph-textarea:focus {{
            outline: none;
            border-color: #f39c12;
            box-shadow: 0 0 0 3px rgba(243, 156, 18, 0.1);
            background: white;
        }}

        .quiz-btn {{
            background: linear-gradient(135deg, #6B73FF, #000DFF);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 10px;
        }}

        .quiz-btn:hover {{
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }}

        .quiz-btn:disabled {{
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }}

        .quiz-results {{
            display: none;
            text-align: center;
            padding: 30px;
            background: linear-gradient(45deg, #f8f9ff, #e8f0ff);
            border-radius: 20px;
            margin-top: 20px;
        }}

        .quiz-results.active {{
            display: block;
        }}

        .results-score {{
            font-size: 3em;
            color: #6B73FF;
            font-weight: bold;
            margin-bottom: 20px;
        }}

        .results-message {{
            font-size: 1.4em;
            color: #333;
            margin-bottom: 20px;
        }}

        /* Responsive design */
        @media (max-width: 768px) {{
            .story-container {{
                margin: 10px;
                border-radius: 15px;
            }}
            
            .story-content {{
                padding: 20px;
                height: 60vh;
                font-size: 1.2em;
            }}
            
            .story-title {{
                font-size: 2.2em;
            }}
            
            .story-text {{
                font-size: 1.2em;
            }}
            
            .chapter-title {{
                font-size: 1.8em;
            }}
            
            .question-text {{
                font-size: 1.3em;
            }}
            
            .answer-option {{
                font-size: 1.1em;
                padding: 15px;
            }}
            
            .chapter-image-frame {{
                height: 200px;
                margin: 20px 0;
            }}
        }}
    </style>
</head>
<body>
    <div class="story-container">
        <div class="story-header">
            <h1 class="story-title">{story['title']}</h1>
            <p class="story-subtitle">{story.get('subtitle', '')}</p>
        </div>

        <div class="story-content" id="storyContent">
            {chapters_html}

            <!-- Quiz Section -->
            <div class="quiz-section" id="quizSection">
                <div class="quiz-header">
                    <h2 class="quiz-title">ðŸ“ Story Quiz</h2>
                    <p style="font-size: 1.2em; color: #666;">Test your understanding of the story!</p>
                </div>

                <div class="question-container" id="questionContainer">
                    <!-- Questions will be loaded by JavaScript -->
                </div>

                <div class="quiz-results" id="quizResults">
                    <div class="results-score" id="resultsScore"></div>
                    <div class="results-message" id="resultsMessage"></div>
                    <button class="quiz-btn" onclick="restartQuiz()">ðŸ”„ Try Again</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Quiz questions data from backend
        const quizQuestions = {questions_js};
        
        // Quiz state
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let paragraphAnswers = [];
        let quizScore = 0;

        // Initialize story
        document.addEventListener('DOMContentLoaded', function() {{
            // Auto-show quiz after a delay
            setTimeout(() => {{
                showQuiz();
            }}, 3000);
        }});

        function showQuiz() {{
            document.getElementById('quizSection').classList.add('active');
            document.getElementById('quizSection').scrollIntoView({{ 
                behavior: 'smooth', 
                block: 'start' 
            }});
            loadQuestion();
        }}

        function loadQuestion() {{
            const question = quizQuestions[currentQuestionIndex];
            const container = document.getElementById('questionContainer');
            
            if (question.type === 'multiple-choice') {{
                container.innerHTML = `
                    <div style="margin-bottom: 30px;">
                        <div class="question-text">Question ${{currentQuestionIndex + 1}}: ${{question.question}}</div>
                        <div class="answer-options">
                            ${{question.options.map((option, index) => `
                                <div class="answer-option" onclick="selectAnswer(${{index}})" data-index="${{index}}">
                                    <div class="option-letter">${{String.fromCharCode(65 + index)}}</div>
                                    <div>${{option}}</div>
                                </div>
                            `).join('')}}
                        </div>
                        <button class="quiz-btn" onclick="nextQuestion()" id="nextBtn" disabled>
                            ${{currentQuestionIndex < quizQuestions.length - 1 ? 'Next Question' : 'Finish Quiz'}}
                        </button>
                    </div>
                `;
            }} else {{
                container.innerHTML = `
                    <div style="margin-bottom: 30px;">
                        <div class="paragraph-question" style="display: block;">
                            <div class="question-text">Question ${{currentQuestionIndex + 1}}: ${{question.question}}</div>
                            <textarea class="paragraph-textarea" id="paragraphAnswer" 
                                      placeholder="${{question.placeholder || 'Type your thoughtful response here...'}}"
                                      style="width: 100%; min-height: 150px; margin: 20px 0;"></textarea>
                            <div style="text-align: right; color: #666; margin-bottom: 20px;">
                                Minimum ${{question.minWords}} words
                            </div>
                            <button class="quiz-btn" onclick="saveParagraphAndNext()">Save Answer & Continue</button>
                        </div>
                    </div>
                `;
            }}
        }}

        function selectAnswer(index) {{
            const options = document.querySelectorAll('.answer-option');
            options.forEach(opt => opt.classList.remove('selected'));
            options[index].classList.add('selected');
            
            userAnswers[currentQuestionIndex] = index;
            document.getElementById('nextBtn').disabled = false;
            
            // Show correct/incorrect after selection
            setTimeout(() => {{
                const question = quizQuestions[currentQuestionIndex];
                options.forEach((option, i) => {{
                    if (i === question.correct) {{
                        option.classList.add('correct');
                    }} else if (i === index && i !== question.correct) {{
                        option.classList.add('incorrect');
                    }}
                }});
                
                // Show explanation if available
                if (question.explanation) {{
                    const explanation = document.createElement('div');
                    explanation.style.cssText = `
                        background: #f8f9ff;
                        border: 2px solid #6B73FF;
                        border-radius: 10px;
                        padding: 15px;
                        margin-top: 20px;
                        font-size: 1.1em;
                        color: #333;
                    `;
                    explanation.innerHTML = `<strong>Explanation:</strong> ${{question.explanation}}`;
                    document.getElementById('questionContainer').appendChild(explanation);
                }}
            }}, 500);
        }}

        function saveParagraphAndNext() {{
            const answer = document.getElementById('paragraphAnswer').value.trim();
            if (answer.length === 0) {{
                alert('Please write a response before continuing.');
                return;
            }}
            
            const question = quizQuestions[currentQuestionIndex];
            const words = answer.split(/\\s+/).filter(word => word.length > 0);
            if (words.length < question.minWords) {{
                alert(`Please write at least ${{question.minWords}} words. Current count: ${{words.length}}`);
                return;
            }}
            
            paragraphAnswers[currentQuestionIndex] = answer;
            
            // Call AI evaluation API
            evaluateParagraphAnswer(answer, question);
            
            nextQuestion();
        }}

        function evaluateParagraphAnswer(answer, question) {{
            // Call the AI evaluation endpoint
            fetch('/api/evaluate-single-paragraph', {{
                method: 'POST',
                headers: {{
                    'Content-Type': 'application/json',
                }},
                body: JSON.stringify({{
                    question: question.question,
                    answer: answer,
                    expected_themes: question.guidelines || '',
                    min_words: question.minWords || 30
                }})
            }})
            .then(response => response.json())
            .then(data => {{
                console.log('AI Evaluation:', data);
                // Store evaluation for later display
            }})
            .catch(error => {{
                console.error('Evaluation error:', error);
            }});
        }}

        function nextQuestion() {{
            currentQuestionIndex++;
            if (currentQuestionIndex < quizQuestions.length) {{
                loadQuestion();
            }} else {{
                showResults();
            }}
        }}

        function showResults() {{
            let score = 0;
            let totalMC = 0;
            
            userAnswers.forEach((answer, index) => {{
                if (quizQuestions[index].type === 'multiple-choice') {{
                    totalMC++;
                    if (answer === quizQuestions[index].correct) score++;
                }}
            }});
            
            const percentage = totalMC > 0 ? Math.round((score / totalMC) * 100) : 0;
            
            document.getElementById('questionContainer').style.display = 'none';
            document.getElementById('quizResults').classList.add('active');
            
            document.getElementById('resultsScore').textContent = `${{score}}/${{totalMC}} (${{percentage}}%)`;
            
            let message = '';
            if (percentage >= 80) {{
                message = 'ðŸŒŸ Excellent! You truly understand the story!';
            }} else if (percentage >= 60) {{
                message = 'ðŸ‘ Good job! You grasped the main concepts.';
            }} else {{
                message = 'ðŸ“š Consider reading the story again to catch more details.';
            }}
            
            document.getElementById('resultsMessage').textContent = message;
        }}

        function restartQuiz() {{
            currentQuestionIndex = 0;
            userAnswers = [];
            paragraphAnswers = [];
            quizScore = 0;
            
            document.getElementById('quizResults').classList.remove('active');
            document.getElementById('questionContainer').style.display = 'block';
            loadQuestion();
        }}
    </script>
</body>
</html>'''

def generate_background_css(story):
    """Generate background CSS based on story settings"""
    bg_type = story.get('background_type', 'gradient')
    primary = story.get('primary_color', '#87CEEB')
    secondary = story.get('secondary_color', '#B0E0E6')
    
    if bg_type == 'solid':
        return primary
    elif bg_type == 'sky':
        return 'linear-gradient(135deg, #87CEEB 0%, #98D8E8 30%, #87CEEB 70%, #B0E0E6 100%)'
    elif bg_type == 'nature':
        return 'linear-gradient(135deg, #8BC34A 0%, #CDDC39 30%, #8BC34A 70%, #AED581 100%)'
    else:  # gradient
        return f'linear-gradient(135deg, {primary} 0%, {secondary} 100%)'

@app.route('/api/evaluate-single-paragraph', methods=['POST'])
def evaluate_single_paragraph():
    """Evaluate a single paragraph answer in real-time with enhanced AI"""
    try:
        data = request.get_json()
        
        if not all(key in data for key in ['question', 'answer']):
            return jsonify({'error': 'Missing required fields'}), 400
            
        question = data['question']
        answer = data['answer']
        story_context = data.get('story_context', '')
        expected_themes = data.get('expected_themes', '')
        min_words = data.get('min_words', 30)
        
        word_count = len(answer.split())
        
        # Quick validation
        if word_count < min_words:
            return jsonify({
                'score': max(0, min(40, word_count * 2)),
                'feedback': f'Your response needs to be longer. Please aim for at least {min_words} words to fully express your ideas.',
                'strengths': ['Response started'],
                'improvements': [f'Expand your answer to meet the {min_words} word minimum', 'Add more specific details and examples'],
                'meets_length': False,
                'word_count': word_count
            }), 200
        
        # Enhanced AI evaluation prompt
        prompt = f"""Evaluate this student's paragraph response to a story-based question with detailed, constructive feedback.

STORY CONTEXT: {story_context}

QUESTION: {question}
EXPECTED THEMES: {expected_themes}
MINIMUM WORDS: {min_words}

STUDENT RESPONSE ({word_count} words):
"{answer}"

Provide a comprehensive evaluation considering:
1. Understanding of story themes and concepts (40%)
2. Use of specific examples from the text (25%)
3. Depth of analysis and critical thinking (20%)
4. Writing clarity and organization (15%)

Scoring Guidelines:
- 90-100: Exceptional understanding with insightful analysis
- 80-89: Strong understanding with good examples
- 70-79: Good understanding with adequate support
- 60-69: Basic understanding with minimal support
- 50-59: Limited understanding, needs improvement
- Below 50: Insufficient understanding

Return ONLY this JSON structure:
{{
  "score": 85,
  "feedback": "Your detailed, encouraging feedback here...",
  "strengths": ["Specific strength 1", "Specific strength 2"],
  "improvements": ["Specific improvement 1", "Specific improvement 2"],
  "meets_length": true,
  "word_count": {word_count},
  "evaluation_details": {{
    "theme_understanding": 80,
    "examples_usage": 85,
    "critical_thinking": 90,
    "writing_clarity": 85
  }}
}}"""

        try:
            start_time = datetime.now()
            
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=2000,
                temperature=0.3,
                messages=[{"role": "user", "content": prompt}]
            )
            
            processing_time = (datetime.now() - start_time).total_seconds() * 1000
            content = response.content[0].text
            
            # Parse JSON response
            json_start = content.find('{')
            json_end = content.rfind('}') + 1
            
            if json_start >= 0 and json_end > json_start:
                json_content = content[json_start:json_end]
                result = json.loads(json_content)
                
                # Validate and set defaults
                result.setdefault('score', 70)
                result.setdefault('feedback', 'Good effort on your response.')
                result.setdefault('strengths', ['Response provided'])
                result.setdefault('improvements', ['Continue developing your ideas'])
                result['meets_length'] = word_count >= min_words
                result['word_count'] = word_count
                result['score'] = max(0, min(100, int(result['score'])))
                
                # Log the evaluation for analytics
                log_ai_evaluation(data, result, processing_time, True)
                
                return jsonify(result), 200
            else:
                raise ValueError("Invalid JSON response from AI")
                
        except Exception as api_error:
            logger.error(f"Single paragraph evaluation error: {str(api_error)}")
            
            # Log the failed evaluation
            log_ai_evaluation(data, {}, 0, False, str(api_error))
            
        # Fallback response when AI fails
        return jsonify({
            'score': 70,
            'feedback': 'Your response shows effort. Consider adding more specific details and examples from the story.',
            'strengths': ['Response completed', 'Meets length requirement'],
            'improvements': ['Add more specific examples', 'Expand on key concepts'],
            'meets_length': word_count >= min_words,
            'word_count': word_count,
            'evaluation_details': {
                'theme_understanding': 70,
                'examples_usage': 65,
                'critical_thinking': 70,
                'writing_clarity': 75
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Single paragraph evaluation error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/evaluate-inputfield-paragraph', methods=['POST'])
def evaluate_inputfield_paragraph():
    """Evaluate input field answers with contextual understanding and spelling tolerance"""
    try:
        data = request.get_json()
        
        if not all(key in data for key in ['question', 'student_answer', 'expected_answer']):
            return jsonify({'error': 'Missing required fields'}), 400
            
        question = data['question']
        student_answer = data['student_answer'].strip()
        expected_answer = data['expected_answer'].strip()
        context = data.get('context', '')
        
        # Handle empty answers
        if not student_answer:
            return jsonify({
                'score': 0,
                'accuracy': 0,
                'feedback': 'No answer provided. Please provide your answer to receive feedback.',
                'status': 'incorrect',
                'is_spelling_error': False,
                'contextually_related': False
            }), 200
        
        # Enhanced evaluation prompt
        prompt = f"""Evaluate this student's answer for contextual accuracy and understanding with nuanced feedback.

QUESTION: {question}
EXPECTED ANSWER: {expected_answer}
STUDENT ANSWER: {student_answer}
CONTEXT: {context}

Evaluation Criteria:
1. EXACT MATCH: Identical or very similar answers = 95-100% accuracy
2. SPELLING ERROR: Misspelled version of expected answer = 65-80% accuracy
3. CONTEXTUALLY RELATED: Synonymous or related concepts = 75-90% accuracy
4. PARTIALLY CORRECT: Shows some understanding but incomplete = 45-65% accuracy
5. CONCEPTUALLY CLOSE: Wrong answer but in correct domain = 25-45% accuracy
6. COMPLETELY INCORRECT: Unrelated or completely wrong = 0-25% accuracy

Examples for context:
- Expected: "tree", Student: "three" â†’ Spelling error (70% accuracy)
- Expected: "tree", Student: "plant" â†’ Contextually related (80% accuracy)
- Expected: "tree", Student: "forest" â†’ Contextually related (75% accuracy)
- Expected: "cat", Student: "feline" â†’ Contextually related (85% accuracy)
- Expected: "photosynthesis", Student: "fotosynthesis" â†’ Spelling error (75% accuracy)
- Expected: "democracy", Student: "government" â†’ Partially correct (60% accuracy)

Return ONLY this JSON structure:
{{
  "score": 75,
  "accuracy": 75,
  "feedback": "Constructive, encouraging feedback explaining the evaluation...",
  "status": "correct",
  "is_spelling_error": false,
  "contextually_related": true,
  "expected_vs_student": "Expected: tree, You wrote: plant - These are related concepts!",
  "suggestion": "Your answer shows understanding of the concept..."
}}

Status determination:
- "correct" for 70%+ accuracy
- "partial" for 45-69% accuracy  
- "incorrect" for below 45% accuracy"""

        try:
            start_time = datetime.now()
            
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=1000,
                temperature=0.2,
                messages=[{"role": "user", "content": prompt}]
            )
            
            processing_time = (datetime.now() - start_time).total_seconds() * 1000
            content = response.content[0].text
            
            # Parse JSON response
            json_start = content.find('{')
            json_end = content.rfind('}') + 1
            
            if json_start >= 0 and json_end > json_start:
                json_content = content[json_start:json_end]
                result = json.loads(json_content)
                
                # Validate and normalize
                result['score'] = max(0, min(100, int(result.get('score', 0))))
                result['accuracy'] = max(0, min(100, int(result.get('accuracy', 0))))
                
                # Ensure status matches accuracy
                if result['accuracy'] >= 70:
                    result['status'] = 'correct'
                elif result['accuracy'] >= 45:
                    result['status'] = 'partial'
                else:
                    result['status'] = 'incorrect'
                
                # Add comparison text if not present
                if 'expected_vs_student' not in result:
                    result['expected_vs_student'] = f"Expected: {expected_answer}, You wrote: {student_answer}"
                
                # Log successful evaluation
                log_ai_evaluation(data, result, processing_time, True)
                
                return jsonify(result), 200
            else:
                raise ValueError("Invalid JSON response from AI")
                
        except Exception as api_error:
            logger.error(f"AI evaluation error: {str(api_error)}")
            log_ai_evaluation(data, {}, 0, False, str(api_error))
            
        # Fallback evaluation using basic string comparison
        return fallback_evaluation(student_answer, expected_answer, question)
        
    except Exception as e:
        logger.error(f"Input field evaluation error: {str(e)}")
        return jsonify({'error': str(e)}), 500

def fallback_evaluation(student_answer, expected_answer, question):
    """Fallback evaluation when AI is unavailable using fuzzy matching"""
    try:
        from fuzzywuzzy import fuzz
    except ImportError:
        # Simple fallback without fuzzywuzzy
        similarity = 100 if student_answer.lower() == expected_answer.lower() else 0
    else:
        # Clean answers for comparison
        student_clean = student_answer.lower().strip()
        expected_clean = expected_answer.lower().strip()
        
        # Calculate similarity using multiple methods
        ratio = fuzz.ratio(student_clean, expected_clean)
        partial = fuzz.partial_ratio(student_clean, expected_clean)
        token_sort = fuzz.token_sort_ratio(student_clean, expected_clean)
        
        # Use the highest similarity score
        similarity = max(ratio, partial, token_sort)
    
    if similarity >= 90:
        # Very close match
        score = accuracy = 95
        status = 'correct'
        feedback = "Excellent! Your answer is correct."
        is_spelling = similarity < 100
    elif similarity >= 70:
        # Good match or minor spelling error
        score = accuracy = 75
        status = 'correct'
        feedback = "Good answer! Your response shows understanding."
        is_spelling = True
    elif similarity >= 45:
        # Partial match
        score = accuracy = 60
        status = 'partial'
        feedback = "Your answer shows some understanding, but could be more accurate."
        is_spelling = False
    else:
        # Poor match
        score = accuracy = 20
        status = 'incorrect'
        feedback = "This answer doesn't match what was expected. Please review the question."
        is_spelling = False
    
    return jsonify({
        'score': score,
        'accuracy': accuracy,
        'feedback': feedback,
        'status': status,
        'is_spelling_error': is_spelling,
        'contextually_related': similarity >= 45,
        'expected_vs_student': f"Expected: {expected_answer}, You wrote: {student_answer}",
        'suggestion': "Try to think about the key concepts from the story."
    }), 200

def log_ai_evaluation(request_data, response_data, processing_time, success, error_message=None):
    """Log AI evaluation for analytics and debugging"""
    try:
        connection = get_db_connection()
        if not connection:
            return
        
        cursor = connection.cursor()
        
        # Insert log entry
        log_query = """
            INSERT INTO ai_evaluation_logs 
            (question_id, evaluation_type, request_payload, response_payload, 
             processing_time_ms, ai_model_used, success, error_message)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        log_values = (
            request_data.get('question_id'),  # May be None for standalone evaluations
            'single-paragraph',  # Could be dynamic based on endpoint
            json.dumps(request_data),
            json.dumps(response_data),
            int(processing_time),
            'claude-3-haiku-20240307',
            success,
            error_message
        )
        
        cursor.execute(log_query, log_values)
        connection.commit()
        
        cursor.close()
        connection.close()
        
    except Exception as e:
        logger.error(f"Error logging AI evaluation: {str(e)}")

@app.route('/api/analytics/stories', methods=['GET'])
def get_stories_analytics():
    """Get analytics data for all stories"""
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = connection.cursor(dictionary=True)
        
        # Get overall statistics
        cursor.execute("""
            SELECT 
                COUNT(*) as total_stories,
                COUNT(CASE WHEN status = 'published' THEN 1 END) as published_stories,
                COUNT(CASE WHEN status = 'draft' THEN 1 END) as draft_stories,
                SUM(view_count) as total_views,
                AVG(completion_rate) as avg_completion_rate
            FROM stories
        """)
        overall_stats = cursor.fetchone()
        
        # Get top performing stories
        cursor.execute("""
            SELECT id, title, view_count, completion_rate, average_score
            FROM story_overview
            WHERE status = 'published'
            ORDER BY view_count DESC
            LIMIT 10
        """)
        top_stories = cursor.fetchall()
        
        # Get recent activity
        cursor.execute("""
            SELECT DATE(created_at) as date, COUNT(*) as stories_created
            FROM stories
            WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
            GROUP BY DATE(created_at)
            ORDER BY date DESC
        """)
        recent_activity = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'overall_stats': overall_stats,
            'top_stories': top_stories,
            'recent_activity': recent_activity
        })
        
    except Error as e:
        logger.error(f"Error fetching analytics: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/analytics/story/<int:story_id>', methods=['GET'])
def get_story_analytics(story_id):
    """Get detailed analytics for a specific story"""
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = connection.cursor(dictionary=True)
        
        # Get story performance
        cursor.execute("""
            SELECT * FROM story_overview WHERE id = %s
        """, (story_id,))
        story_performance = cursor.fetchone()
        
        if not story_performance:
            return jsonify({'error': 'Story not found'}), 404
        
        # Get question performance
        cursor.execute("""
            SELECT * FROM question_performance WHERE story_id = %s
        """, (story_id,))
        question_performance = cursor.fetchall()
        
        # Get recent attempts
        cursor.execute("""
            SELECT sa.*, 
                   COUNT(ua.id) as answers_submitted,
                   AVG(ua.ai_score) as avg_score
            FROM story_attempts sa
            LEFT JOIN user_answers ua ON sa.id = ua.attempt_id
            WHERE sa.story_id = %s
            GROUP BY sa.id
            ORDER BY sa.started_at DESC
            LIMIT 20
        """, (story_id,))
        recent_attempts = cursor.fetchall()
        
        # Get AI evaluation statistics
        cursor.execute("""
            SELECT 
                evaluation_type,
                COUNT(*) as total_evaluations,
                AVG(processing_time_ms) as avg_processing_time,
                COUNT(CASE WHEN success = 1 THEN 1 END) as successful_evaluations,
                SUM(tokens_used) as total_tokens,
                SUM(api_cost_cents) as total_cost_cents
            FROM ai_evaluation_logs ael
            JOIN user_answers ua ON ael.answer_id = ua.id
            JOIN questions q ON ua.question_id = q.id
            WHERE q.story_id = %s
            GROUP BY evaluation_type
        """, (story_id,))
        ai_stats = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        # Convert datetime objects to strings
        for item in [story_performance] + question_performance + recent_attempts + ai_stats:
            if item:
                for key, value in item.items():
                    if isinstance(value, datetime):
                        item[key] = value.isoformat()
        
        return jsonify({
            'success': True,
            'story_performance': story_performance,
            'question_performance': question_performance,
            'recent_attempts': recent_attempts,
            'ai_statistics': ai_stats
        })
        
    except Error as e:
        logger.error(f"Error fetching story analytics: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/story/<int:story_id>/start-attempt', methods=['POST'])
def start_story_attempt(story_id):
    """Record when a user starts reading a story"""
    try:
        data = request.get_json() or {}
        
        connection = get_db_connection()
        if not connection:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = connection.cursor()
        
        # Create new attempt
        attempt_query = """
            INSERT INTO story_attempts (story_id, user_id, user_email, user_name, device_type, user_agent, ip_address)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """
        
        attempt_values = (
            story_id,
            data.get('user_id', str(uuid.uuid4())),  # Generate session ID if not provided
            data.get('user_email'),
            data.get('user_name'),
            data.get('device_type', 'desktop'),
            request.headers.get('User-Agent', ''),
            request.remote_addr
        )
        
        cursor.execute(attempt_query, attempt_values)
        attempt_id = cursor.lastrowid
        
        connection.commit()
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'attempt_id': attempt_id
        }), 201
        
    except Error as e:
        logger.error(f"Error starting story attempt: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/attempt/<int:attempt_id>/submit-answer', methods=['POST'])
def submit_answer(attempt_id):
    """Submit an answer to a quiz question"""
    try:
        data = request.get_json()
        
        if not all(key in data for key in ['question_id', 'answer']):
            return jsonify({'error': 'Missing required fields'}), 400
        
        connection = get_db_connection()
        if not connection:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = connection.cursor()
        
        # Get question details
        cursor.execute("SELECT * FROM questions WHERE id = %s", (data['question_id'],))
        question = cursor.fetchone()
        
        if not question:
            return jsonify({'error': 'Question not found'}), 404
        
        # Insert user answer
        answer_query = """
            INSERT INTO user_answers (attempt_id, question_id, answer_text, selected_option_id, time_spent)
            VALUES (%s, %s, %s, %s, %s)
        """
        
        answer_values = (
            attempt_id,
            data['question_id'],
            data['answer'] if isinstance(data['answer'], str) else None,
            data['answer'] if isinstance(data['answer'], int) else None,
            data.get('time_spent', 0)
        )
        
        cursor.execute(answer_query, answer_values)
        answer_id = cursor.lastrowid
        
        connection.commit()
        cursor.close()
        connection.close()
        
        # If it's a paragraph question, evaluate with AI
        if question[3] == 'paragraph':  # question_type is at index 3
            evaluate_and_store_answer(answer_id, data['answer'], question)
        
        return jsonify({
            'success': True,
            'answer_id': answer_id
        }), 201
        
    except Error as e:
        logger.error(f"Error submitting answer: {e}")
        return jsonify({'error': str(e)}), 500

def evaluate_and_store_answer(answer_id, answer_text, question):
    """Evaluate a paragraph answer and store the results"""
    try:
        # Call the evaluation function
        evaluation_data = {
            'question': question[2],  # question_text
            'answer': answer_text,
            'expected_themes': question[7] or '',  # guidelines
            'min_words': question[8] or 30  # min_words
        }
        
        # This would call the same evaluation logic as the API endpoint
        # For now, we'll store a placeholder evaluation
        connection = get_db_connection()
        if not connection:
            return
        
        cursor = connection.cursor()
        
        # Update the answer with AI evaluation results
        update_query = """
            UPDATE user_answers 
            SET ai_score = %s, ai_feedback = %s, ai_strengths = %s, ai_improvements = %s, meets_requirements = %s
            WHERE id = %s
        """
        
        # Placeholder evaluation - in reality, this would call the AI
        update_values = (
            75.0,  # ai_score
            "Good effort on your response. Consider adding more specific examples.",  # ai_feedback
            json.dumps(["Shows understanding", "Well-written"]),  # ai_strengths
            json.dumps(["Add more examples", "Expand on key points"]),  # ai_improvements
            len(answer_text.split()) >= (question[8] or 30),  # meets_requirements
            answer_id
        )
        
        cursor.execute(update_query, update_values)
        connection.commit()
        
        cursor.close()
        connection.close()
        
    except Exception as e:
        logger.error(f"Error evaluating answer: {e}")

@app.route('/api/attempt/<int:attempt_id>/complete', methods=['POST'])
def complete_story_attempt(attempt_id):
    """Mark a story attempt as completed"""
    try:
        data = request.get_json() or {}
        
        connection = get_db_connection()
        if not connection:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = connection.cursor()
        
        # Update attempt as completed
        update_query = """
            UPDATE story_attempts 
            SET completed_at = CURRENT_TIMESTAMP, 
                total_time_spent = %s,
                last_chapter_reached = %s
            WHERE id = %s
        """
        
        update_values = (
            data.get('total_time_spent', 0),
            data.get('last_chapter_reached', 3),
            attempt_id
        )
        
        cursor.execute(update_query, update_values)
        connection.commit()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'message': 'Story attempt completed'
        })
        
    except Error as e:
        logger.error(f"Error completing story attempt: {e}")
        return jsonify({'error': str(e)}), 500

# ================================
# ERROR HANDLERS
# ================================

@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Endpoint not found'}), 404

@app.errorhandler(405)
def method_not_allowed(error):
    """Handle 405 Method Not Allowed errors properly with CORS headers"""
    logger.error(f"405 Error: {error} - Allowed methods: {error.valid_methods if hasattr(error, 'valid_methods') else 'unknown'}")
    response = jsonify({
        'error': 'Method not allowed',
        'message': str(error),
        'allowed_methods': list(error.valid_methods) if hasattr(error, 'valid_methods') else []
    })
    response.headers.add('Access-Control-Allow-Origin', '*')
    response.headers.add('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
    response.headers.add('Access-Control-Allow-Headers', 'Content-Type, Authorization')
    return response, 405

@app.errorhandler(500)
def internal_error(error):
    return jsonify({'error': 'Internal server error'}), 500

@app.errorhandler(413)
def too_large(error):
    return jsonify({'error': 'File too large'}), 413

# ================================
# MAIN APPLICATION
# ================================


@app.route('/api/stories/<int:story_id>', methods=['GET'])
def get_story(story_id):
    """Get a specific story with all details"""
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = connection.cursor(dictionary=True)
        
        # Get story details
        cursor.execute("SELECT * FROM stories WHERE id = %s", (story_id,))
        story = cursor.fetchone()
        
        if not story:
            return jsonify({'error': 'Story not found'}), 404
        
        # Get chapters
        cursor.execute("""
            SELECT * FROM chapters 
            WHERE story_id = %s 
            ORDER BY chapter_number
        """, (story_id,))
        chapters = cursor.fetchall()
        
        # Get questions
        cursor.execute("""
            SELECT * FROM questions 
            WHERE story_id = %s 
            ORDER BY question_number
        """, (story_id,))
        questions = cursor.fetchall()
        
        # Get options for multiple choice questions
        for question in questions:
            if question['question_type'] == 'multiple-choice':
                cursor.execute("""
                    SELECT * FROM question_options 
                    WHERE question_id = %s 
                    ORDER BY option_letter
                """, (question['id'],))
                question['options'] = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        # Convert datetime objects to strings
        for item in [story] + chapters + questions:
            for key, value in item.items():
                if isinstance(value, datetime):
                    item[key] = value.isoformat()
        
        story['chapters'] = chapters
        story['questions'] = questions
        
        return jsonify({
            'success': True,
            'story': story
        })
        
    except Error as e:
        logger.error(f"Error fetching story: {e}")
        return jsonify({'error': str(e)}), 500


# Helper function for building answer format instructions
def _build_answer_format_instructions(answer_format, num_questions=5):
    """Build prompt instructions and JSON schema for different answer formats."""
    if answer_format == 'multiple_choice':
        return {
            'instruction': 'ALL questions must be Multiple Choice with exactly 4 options (A, B, C, D). One option must be the correct answer.',
            'json_fields': '''      "answer_format": "multiple_choice",
      "options": ["A) first option", "B) second option", "C) third option", "D) fourth option"],
      "expected_answer": "A) first option"''',
            'note': 'The expected_answer must exactly match one of the options.'
        }
    elif answer_format == 'true_false':
        return {
            'instruction': 'ALL questions must be True or False statements. The student will select either True or False.',
            'json_fields': '''      "answer_format": "true_false",
      "options": ["True", "False"],
      "expected_answer": "True"''',
            'note': 'The expected_answer must be exactly "True" or "False". Frame each question as a statement that is either true or false.'
        }
    elif answer_format == 'mixed':
        mc_count = max(1, num_questions // 3)
        tf_count = max(1, num_questions // 3)
        input_count = num_questions - mc_count - tf_count
        return {
            'instruction': f'Use a MIX of answer formats: approximately {mc_count} Multiple Choice (with 4 options A-D), {tf_count} True/False, and {input_count} Input (free-text). Set "answer_format" on each question accordingly.',
            'json_fields': '''      "answer_format": "multiple_choice OR true_false OR input",
      "options": ["A) ...", "B) ...", "C) ...", "D) ..."],
      "expected_answer": "the correct answer"''',
            'note': 'For multiple_choice: include 4 options A-D. For true_false: options are ["True","False"]. For input: omit "options" field or set it to null.'
        }
    else:  # 'input' - default
        return {
            'instruction': 'ALL questions use free-text input. The student types their answer.',
            'json_fields': '''      "answer_format": "input",
      "expected_answer": "the correct specific answer"''',
            'note': 'Do not include an "options" field for input questions.'
        }


# Enhanced question generation endpoint
@app.route('/api/tutor/generate-questions-from-image', methods=['POST'])
def generate_questions_from_image():
    """Generate questions automatically from uploaded image using AI vision."""
    try:
        data = request.get_json()

        if 'image_data' not in data:
            return jsonify({'error': 'No image data provided'}), 400

        image_data = data['image_data']
        num_questions = data.get('num_questions', 5)
        subject = data.get('subject', 'general')
        difficulty_level = data.get('difficulty_level', 'medium')
        question_types = data.get('question_types', ['factual', 'descriptive'])
        additional_images = data.get('additional_images', [])
        answer_format = data.get('answer_format', 'input')

        # Validate inputs
        if num_questions < 1 or num_questions > 20:
            return jsonify({'error': 'Number of questions must be between 1 and 20'}), 400

        if not question_types:
            return jsonify({'error': 'At least one question type must be selected'}), 400

        # Check if AI client is available
        if not anthropic_client:
            logging.error("AI question generation failed: anthropic_client is not initialized (ANTHROPIC_API_KEY may not be set)")
            return jsonify({'error': 'AI service is not configured. Please check that ANTHROPIC_API_KEY is set in the environment.'}), 503

        try:
            fmt = _build_answer_format_instructions(answer_format, num_questions)

            prompt = f"""Analyze this worksheet image carefully. Your job is to extract and understand the content shown in the image, then generate {num_questions} educational questions with answers based on what you see.

IMPORTANT INSTRUCTIONS:
1. First, identify what the image contains - it could be a printed worksheet, a math problem sheet, a reading passage, a diagram, a chart, a map, a science experiment, or any educational material.
2. If the image contains existing questions/problems (like a math worksheet), extract those actual problems and provide their correct answers.
3. If the image contains educational content (like a diagram, passage, or illustration), create questions that test understanding of that specific content.
4. Every answer must be specific and based on what is actually visible or solvable from the image content.

CONTEXT:
- Subject: {subject}
- Difficulty level: {difficulty_level}
- Desired question types: {', '.join(question_types)}

ANSWER FORMAT: {fmt['instruction']}
{fmt['note']}

QUESTION TYPES:
- factual: What, where, when, how many â€” direct answers from the content
- analytical: Why, how, explain, compare â€” deeper understanding
- descriptive: Describe, identify, name â€” observation-based

Return ONLY this JSON structure with no other text:
{{
  "questions": [
    {{
      "question_text": "The actual question based on the image content",
{fmt['json_fields']},
      "question_type": "factual",
      "difficulty": "{difficulty_level}"
    }}
  ],
  "image_description": "Brief description of what the worksheet/image contains",
  "suggested_title": "Suggested worksheet title based on the image content"
}}

Generate exactly {num_questions} questions. Make answers specific and accurate based on the image."""

            # Build message content with the primary image
            image_base64 = image_data.split(',')[1] if ',' in image_data else image_data
            # Detect media type from data URI
            media_type = 'image/jpeg'
            if image_data.startswith('data:'):
                media_type = image_data.split(';')[0].split(':')[1]

            message_content = [
                {
                    "type": "image",
                    "source": {
                        "type": "base64",
                        "media_type": media_type,
                        "data": image_base64
                    }
                }
            ]

            # Add additional images if provided (multi-image worksheet)
            for extra_img in additional_images[:4]:
                extra_base64 = extra_img.split(',')[1] if ',' in extra_img else extra_img
                extra_media_type = 'image/jpeg'
                if extra_img.startswith('data:'):
                    extra_media_type = extra_img.split(';')[0].split(':')[1]
                message_content.append({
                    "type": "image",
                    "source": {
                        "type": "base64",
                        "media_type": extra_media_type,
                        "data": extra_base64
                    }
                })

            message_content.append({
                "type": "text",
                "text": prompt
            })

            logging.info(f"Calling Anthropic vision API with {1 + len(additional_images)} image(s) for {num_questions} questions")

            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=4000,
                temperature=0.3,
                messages=[
                    {
                        "role": "user",
                        "content": message_content
                    }
                ]
            )

            content = response.content[0].text
            logging.info(f"AI vision response received, length={len(content)}")

            # Parse JSON response
            json_start = content.find('{')
            json_end = content.rfind('}') + 1

            if json_start >= 0 and json_end > json_start:
                json_content = content[json_start:json_end]
                result = json.loads(json_content)

                # Add question numbers, validate, and ensure answer_format is set
                for i, question in enumerate(result.get('questions', []), 1):
                    question['question_number'] = i
                    question.setdefault('question_type', 'factual')
                    question.setdefault('difficulty', difficulty_level)
                    question.setdefault('answer_format', answer_format if answer_format != 'mixed' else 'input')

                # Ensure we have the right number of questions
                result['questions'] = result['questions'][:num_questions]

                logging.info(f"Successfully generated {len(result['questions'])} AI questions from image")
                return jsonify(result), 200
            else:
                logging.error(f"AI response did not contain valid JSON: {content[:200]}")
                return jsonify({'error': 'AI returned an invalid response. Please try again.'}), 500

        except Exception as ai_error:
            logging.error(f"AI question generation error: {str(ai_error)}", exc_info=True)
            return jsonify({'error': f'AI analysis failed: {str(ai_error)}'}), 500

    except Exception as e:
        logging.error(f"Question generation error: {str(e)}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/tutor/generate-answers-from-image', methods=['POST'])
def generate_answers_from_image():
    """Analyze worksheet image and generate only answers for problems visible in the image."""
    try:
        data = request.get_json()

        if 'image_data' not in data:
            return jsonify({'error': 'No image data provided'}), 400

        image_data = data['image_data']
        subject = data.get('subject', 'general')
        additional_images = data.get('additional_images', [])
        answer_format = data.get('answer_format', 'input')

        if not anthropic_client:
            return jsonify({'error': 'AI service is not configured. Please check that ANTHROPIC_API_KEY is set.'}), 503

        try:
            fmt = _build_answer_format_instructions(answer_format, 10)

            prompt = f"""Analyze this worksheet image carefully. The worksheet already contains printed questions or problems that students need to solve. Your job is to read every question/problem visible in the image and provide the correct answer for each one.

IMPORTANT:
1. Read every question/problem visible in the image â€” they are already printed on the worksheet.
2. For each question/problem, provide the correct answer.
3. If it is a math worksheet with arrays, count the objects in each array and solve the multiplication (rows x columns = total).
4. If it is a fill-in-the-blank, provide what goes in the blank.
5. Number the answers to match the question/problem order on the worksheet.
6. The "question_text" should describe the problem as shown in the image (e.g., "Array 1: 3 rows x 4 columns" or "Problem 3: 4 x 5 =").

Subject: {subject}

ANSWER FORMAT: {fmt['instruction']}
{fmt['note']}

Return ONLY this JSON structure:
{{
  "answers": [
    {{
      "question_text": "Brief description of the problem as shown in the image",
{fmt['json_fields']},
      "question_type": "factual"
    }}
  ],
  "image_description": "Brief description of the worksheet content",
  "suggested_title": "Suggested title for this worksheet"
}}

Find and answer ALL problems/questions visible in the image. Be accurate."""

            image_base64 = image_data.split(',')[1] if ',' in image_data else image_data
            media_type = 'image/jpeg'
            if image_data.startswith('data:'):
                media_type = image_data.split(';')[0].split(':')[1]

            message_content = [
                {"type": "image", "source": {"type": "base64", "media_type": media_type, "data": image_base64}}
            ]

            for extra_img in additional_images[:4]:
                extra_base64 = extra_img.split(',')[1] if ',' in extra_img else extra_img
                extra_media_type = 'image/jpeg'
                if extra_img.startswith('data:'):
                    extra_media_type = extra_img.split(';')[0].split(':')[1]
                message_content.append(
                    {"type": "image", "source": {"type": "base64", "media_type": extra_media_type, "data": extra_base64}}
                )

            message_content.append({"type": "text", "text": prompt})

            logging.info(f"Calling Anthropic vision API for answers-only with {1 + len(additional_images)} image(s)")

            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=4000,
                temperature=0.2,
                messages=[{"role": "user", "content": message_content}]
            )

            content = response.content[0].text
            json_start = content.find('{')
            json_end = content.rfind('}') + 1

            if json_start >= 0 and json_end > json_start:
                result = json.loads(content[json_start:json_end])

                answers = result.get('answers', [])
                questions = []
                for i, ans in enumerate(answers, 1):
                    q = {
                        'question_number': i,
                        'question_text': ans.get('question_text', f'Problem {i}'),
                        'expected_answer': ans.get('expected_answer', ''),
                        'question_type': ans.get('question_type', 'factual'),
                        'difficulty': 'medium',
                        'answer_format': ans.get('answer_format', answer_format if answer_format != 'mixed' else 'input')
                    }
                    if ans.get('options'):
                        q['options'] = ans['options']
                    questions.append(q)

                return jsonify({
                    'questions': questions,
                    'image_description': result.get('image_description', ''),
                    'suggested_title': result.get('suggested_title', ''),
                    'answers_only': True
                }), 200
            else:
                return jsonify({'error': 'AI returned an invalid response. Please try again.'}), 500

        except Exception as ai_error:
            logging.error(f"AI answer generation error: {str(ai_error)}", exc_info=True)
            return jsonify({'error': f'AI analysis failed: {str(ai_error)}'}), 500

    except Exception as e:
        logging.error(f"Answer generation error: {str(e)}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/tutor/generate-questions-from-video', methods=['POST'])
def generate_questions_from_video():
    """Generate questions from a YouTube video by analyzing its transcript and metadata."""
    try:
        data = request.get_json()
        youtube_id = data.get('youtube_id')
        if not youtube_id:
            return jsonify({'error': 'No YouTube video ID provided'}), 400

        num_questions = data.get('num_questions', 5)
        subject = data.get('subject', 'general')
        difficulty_level = data.get('difficulty_level', 'medium')
        question_types = data.get('question_types', ['factual', 'descriptive'])
        answers_only = data.get('answers_only', False)
        answer_format = data.get('answer_format', 'input')

        if not anthropic_client:
            return jsonify({'error': 'AI service is not configured.'}), 503

        # Fetch video metadata from YouTube oEmbed
        video_title = ''
        video_author = ''
        try:
            oembed_url = f"https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v={youtube_id}&format=json"
            oembed_resp = requests.get(oembed_url, timeout=10)
            if oembed_resp.ok:
                oembed_data = oembed_resp.json()
                video_title = oembed_data.get('title', '')
                video_author = oembed_data.get('author_name', '')
                logging.info(f"YouTube metadata: title='{video_title}', author='{video_author}'")
        except Exception as e:
            logging.warning(f"Could not fetch YouTube oEmbed: {e}")

        # Fetch video transcript using youtube_transcript_api
        transcript_text = ''
        try:
            from youtube_transcript_api import YouTubeTranscriptApi
            ytt_api = YouTubeTranscriptApi()
            fetched = ytt_api.fetch(youtube_id)
            # Build plain-text transcript from snippets
            lines = []
            for snippet in fetched.snippets:
                lines.append(snippet.text)
            transcript_text = ' '.join(lines)
            # Truncate to ~8000 chars to fit within AI context limits
            if len(transcript_text) > 8000:
                transcript_text = transcript_text[:8000] + '...'
            logging.info(f"Fetched YouTube transcript: {len(transcript_text)} chars")
        except Exception as e:
            logging.warning(f"Could not fetch YouTube transcript: {e}")

        # Fetch video thumbnail as supplementary visual context
        thumbnail_base64 = None
        thumbnail_media_type = 'image/jpeg'
        for thumb_quality in ['maxresdefault', 'sddefault', 'hqdefault', 'mqdefault']:
            try:
                thumb_url = f"https://img.youtube.com/vi/{youtube_id}/{thumb_quality}.jpg"
                thumb_resp = requests.get(thumb_url, timeout=10)
                if thumb_resp.ok and len(thumb_resp.content) > 1000:
                    import base64 as b64mod
                    thumbnail_base64 = b64mod.b64encode(thumb_resp.content).decode('utf-8')
                    logging.info(f"Fetched YouTube thumbnail ({thumb_quality}): {len(thumb_resp.content)} bytes")
                    break
            except Exception as e:
                logging.warning(f"Could not fetch thumbnail {thumb_quality}: {e}")

        # Build transcript section for the prompt
        transcript_section = ''
        if transcript_text:
            transcript_section = f"""
VIDEO TRANSCRIPT (this is the primary source â€” base ALL questions on the actual content spoken in the video):
{transcript_text}
"""
        else:
            transcript_section = """
(Transcript was not available. Use the video title, author, and thumbnail to infer content.)
"""

        try:
            fmt = _build_answer_format_instructions(answer_format, num_questions)

            if answers_only:
                prompt = f"""You are analyzing an educational YouTube video to extract the problems/questions it covers and provide correct answers.

Video Title: {video_title}
Video Author: {video_author}
Subject: {subject}
{transcript_section}
Based on the ACTUAL VIDEO CONTENT from the transcript above:
1. Identify the specific educational topics, problems, and concepts taught in the video
2. Extract or create problems/questions that directly relate to what is taught
3. Provide the correct answers based on what the video explains

IMPORTANT: Your questions and answers MUST be based on the specific content from the video transcript, NOT generic questions about the video itself. For example, if the video teaches multiplication, ask actual multiplication problems and conceptual questions about multiplication â€” do NOT ask "What is the main topic of the video?"

ANSWER FORMAT: {fmt['instruction']}
{fmt['note']}

Return ONLY this JSON:
{{
  "answers": [
    {{
      "question_text": "A specific question based on the video content",
{fmt['json_fields']},
      "question_type": "factual"
    }}
  ],
  "image_description": "Summary of what the video teaches",
  "suggested_title": "Suggested worksheet title"
}}

Generate answers for the key problems and concepts covered in this educational video."""
            else:
                prompt = f"""You are analyzing an educational YouTube video to generate worksheet questions that test a student's understanding of what the video teaches.

Video Title: {video_title}
Video Author: {video_author}
Subject: {subject}
Difficulty: {difficulty_level}
Question Types: {', '.join(question_types)}
{transcript_section}
Based on the ACTUAL VIDEO CONTENT from the transcript above:
1. Identify the specific concepts, facts, and skills taught in the video
2. Create questions that test whether a student understood and can apply what was taught
3. Provide specific correct answers based on the video content

IMPORTANT: Your questions MUST be based on the specific content from the video transcript, NOT generic questions about the video itself. For example, if the video teaches multiplication facts, ask actual multiplication problems, questions about the commutative property, the nines trick, etc. â€” do NOT ask "What is the main topic of the video?" or "What company made this video?"

ANSWER FORMAT: {fmt['instruction']}
{fmt['note']}

Return ONLY this JSON:
{{
  "questions": [
    {{
      "question_text": "A specific question testing understanding of video content",
{fmt['json_fields']},
      "question_type": "factual",
      "difficulty": "{difficulty_level}"
    }}
  ],
  "image_description": "Summary of what the video teaches",
  "suggested_title": "Suggested worksheet title"
}}

Generate exactly {num_questions} questions."""

            message_content = []
            if thumbnail_base64:
                message_content.append({
                    "type": "image",
                    "source": {
                        "type": "base64",
                        "media_type": thumbnail_media_type,
                        "data": thumbnail_base64
                    }
                })
            message_content.append({"type": "text", "text": prompt})

            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=4000,
                temperature=0.3,
                messages=[{"role": "user", "content": message_content}]
            )

            content = response.content[0].text
            json_start = content.find('{')
            json_end = content.rfind('}') + 1

            if json_start >= 0 and json_end > json_start:
                result = json.loads(content[json_start:json_end])

                if answers_only:
                    answers = result.get('answers', [])
                    questions = []
                    for i, ans in enumerate(answers, 1):
                        q = {
                            'question_number': i,
                            'question_text': ans.get('question_text', f'Problem {i}'),
                            'expected_answer': ans.get('expected_answer', ''),
                            'question_type': ans.get('question_type', 'factual'),
                            'difficulty': difficulty_level,
                            'answer_format': ans.get('answer_format', answer_format if answer_format != 'mixed' else 'input')
                        }
                        if ans.get('options'):
                            q['options'] = ans['options']
                        questions.append(q)
                    return jsonify({
                        'questions': questions,
                        'image_description': result.get('image_description', ''),
                        'suggested_title': result.get('suggested_title', ''),
                        'answers_only': True
                    }), 200
                else:
                    for i, q in enumerate(result.get('questions', []), 1):
                        q['question_number'] = i
                        q.setdefault('question_type', 'factual')
                        q.setdefault('difficulty', difficulty_level)
                        q.setdefault('answer_format', answer_format if answer_format != 'mixed' else 'input')
                    result['questions'] = result.get('questions', [])[:num_questions]
                    return jsonify(result), 200
            else:
                return jsonify({'error': 'AI returned an invalid response. Please try again.'}), 500

        except Exception as ai_error:
            logging.error(f"AI video question error: {str(ai_error)}", exc_info=True)
            return jsonify({'error': f'AI analysis failed: {str(ai_error)}'}), 500

    except Exception as e:
        logging.error(f"Video question generation error: {str(e)}")
        return jsonify({'error': str(e)}), 500


# S3-backed persistent worksheet store with in-memory cache
_worksheet_store = {}

import threading
_worksheet_lock = threading.Lock()

def _get_s3_worksheet_key(worksheet_id):
    """Get the S3 key for a worksheet JSON file."""
    return f"worksheets/{worksheet_id}.json"

def _persist_worksheet(key, data):
    """Store a worksheet in memory cache and upload to S3."""
    with _worksheet_lock:
        _worksheet_store[key] = data

    # Upload to S3 for persistent storage across pods/restarts
    try:
        s3_bucket = os.getenv('S3_BUCKET_NAME')
        if 's3_client' in globals() and s3_client and s3_bucket:
            import io
            json_bytes = json.dumps(data).encode('utf-8')
            s3_client.put_object(
                Bucket=s3_bucket,
                Key=_get_s3_worksheet_key(key),
                Body=json_bytes,
                ContentType='application/json'
            )
            logging.info(f"Worksheet {key} saved to S3 bucket {s3_bucket}")
        else:
            logging.warning(f"S3 not available, worksheet {key} stored in memory only")
    except Exception as e:
        logging.error(f"Error saving worksheet {key} to S3: {e}")

def _load_worksheet(key):
    """Load a worksheet by key: check memory cache first, then S3."""
    # Check memory cache
    if key in _worksheet_store:
        return _worksheet_store[key]

    # Try loading from S3
    try:
        s3_bucket = os.getenv('S3_BUCKET_NAME')
        if 's3_client' in globals() and s3_client and s3_bucket:
            response = s3_client.get_object(
                Bucket=s3_bucket,
                Key=_get_s3_worksheet_key(key)
            )
            data = json.loads(response['Body'].read().decode('utf-8'))
            # Cache in memory for fast subsequent reads
            _worksheet_store[key] = data
            logging.info(f"Worksheet {key} loaded from S3")
            return data
    except Exception as e:
        # ClientError with 404/NoSuchKey means worksheet doesn't exist
        error_code = getattr(getattr(e, 'response', {}), 'get', lambda *a: None) and \
                     e.response.get('Error', {}).get('Code', '') if hasattr(e, 'response') else ''
        if error_code != 'NoSuchKey' and error_code != '404':
            logging.error(f"Error loading worksheet {key} from S3: {e}")

    return None

@app.route('/api/tutor/create-worksheet', methods=['POST'])
def create_worksheet():
    """Create a new worksheet with timer, questions, and media support."""
    try:
        data = request.get_json()

        if not data:
            return jsonify({'error': 'No data provided'}), 400

        required_fields = ['title', 'subject', 'questions', 'timeLimit']
        missing_fields = [field for field in required_fields if field not in data]

        if missing_fields:
            return jsonify({'error': f'Missing required fields: {", ".join(missing_fields)}'}), 400

        # Generate unique worksheet ID
        worksheet_uid = str(uuid.uuid4())[:12]
        worksheet_id = None
        db_insert_success = False

        try:
            # Convert tutor_id to integer to match database schema
            tutor_id_param = data.get('tutorId', 1)
            if isinstance(tutor_id_param, str) and tutor_id_param.startswith('tutor_'):
                tutor_id = int(tutor_id_param.replace('tutor_', ''))
            else:
                tutor_id = int(tutor_id_param) if tutor_id_param else 1
            
            logging.info(f"âœ… Creating worksheet for tutor_id: {tutor_id} (type: {type(tutor_id).__name__})")
            
            media_file = data.get('mediaFile') or {}
            question_mode = data.get('questionMode', 'list')  # 'list' or 'auto_navigation'

            # Try full schema first, fall back to basic columns if columns are missing
            full_params = {
                'id': worksheet_uid,
                'tutor_id': tutor_id,  # Now an integer
                'title': data['title'],
                'subject': data['subject'],
                'topic': data.get('topic', ''),
                'include_questions': data.get('includeQuestions', True),
                'question_mode': question_mode,
                'time_limit_seconds': data['timeLimit']['totalSeconds'],
                'extra_time_allowed': data.get('extraTime', {}).get('allowed', False),
                'extra_time_seconds': data.get('extraTime', {}).get('seconds', 0),
                'media_file_url': media_file.get('url'),
                'media_file_type': media_file.get('type'),
                'media_files': json.dumps(data.get('mediaFiles', [])),
                'worksheet_data': json.dumps(data),
                'status': 'active',
                'created_at': datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
            }

            try:
                worksheet_query = text("""
                    INSERT INTO worksheets (
                        id, tutor_id, title, subject, topic, include_questions, question_mode,
                        time_limit_seconds, extra_time_allowed, extra_time_seconds,
                        media_file_url, media_file_type, media_files, worksheet_data, status,
                        created_at
                    ) VALUES (
                        :id, :tutor_id, :title, :subject, :topic, :include_questions, :question_mode,
                        :time_limit_seconds, :extra_time_allowed, :extra_time_seconds,
                        :media_file_url, :media_file_type, :media_files, :worksheet_data, :status,
                        :created_at
                    )
                """)
                db.session.execute(worksheet_query, full_params)
                db.session.commit()
                worksheet_id = worksheet_uid
                db_insert_success = True
                logging.info(f"âœ… Worksheet created in database with ID: {worksheet_id}")

            except Exception as col_err:
                # Full schema failed (missing columns), try basic columns only
                db.session.rollback()
                logging.warning(f"âš ï¸ Full insert failed ({col_err}), trying basic columns")

                basic_query = text("""
                    INSERT INTO worksheets (
                        id, tutor_id, title, subject, time_limit_seconds, worksheet_data, status,
                        created_at
                    ) VALUES (
                        :id, :tutor_id, :title, :subject, :time_limit_seconds, :worksheet_data, :status,
                        :created_at
                    )
                """)
                db.session.execute(basic_query, {
                    'id': worksheet_uid,
                    'tutor_id': tutor_id,  # Integer
                    'title': data['title'],
                    'subject': data['subject'],
                    'time_limit_seconds': data['timeLimit']['totalSeconds'],
                    'worksheet_data': json.dumps(data),
                    'status': 'active',
                    'created_at': datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
                })
                db.session.commit()
                worksheet_id = worksheet_uid
                db_insert_success = True
                logging.info(f"âœ… Worksheet created with basic schema, ID: {worksheet_id}")

            # Insert questions if provided
            if data.get('questions'):
                for idx, question in enumerate(data['questions'], 1):
                    question_query = text("""
                        INSERT INTO worksheet_questions (
                            worksheet_id, question_number, question_text, 
                            expected_answer, question_type, points
                        ) VALUES (
                            :worksheet_id, :question_number, :question_text,
                            :expected_answer, :question_type, :points
                        )
                    """)
                    db.session.execute(question_query, {
                        'worksheet_id': worksheet_id,
                        'question_number': idx,
                        'question_text': question.get('questionText', ''),
                        'expected_answer': question.get('expectedAnswer', ''),
                        'question_type': question.get('questionType', 'factual'),
                        'points': question.get('points', 10)
                    })
                db.session.commit()
                logging.info(f"âœ… Inserted {len(data['questions'])} questions for worksheet {worksheet_id}")

        except Exception as db_error:
            db.session.rollback()
            logging.error(f"âŒ Database error creating worksheet: {str(db_error)}")
            worksheet_id = worksheet_uid
            db_insert_success = False

        # Persist worksheet to memory cache + S3 for retrieval across pods/restarts
        store_key = str(worksheet_id) if worksheet_id else worksheet_uid
        _persist_worksheet(store_key, {
            'id': store_key,
            'title': data['title'],
            'subject': data['subject'],
            'topic': data.get('topic', ''),
            'includeQuestions': data.get('includeQuestions', True),
            'questionMode': data.get('questionMode', 'list'),
            'timeLimit': data['timeLimit'],
            'extraTime': data.get('extraTime', {'allowed': False, 'seconds': 0, 'minutes': 0}),
            'mediaFile': data.get('mediaFile'),
            'mediaFiles': data.get('mediaFiles', []),
            'questions': data['questions'],
            'createdAt': data.get('createdAt', datetime.utcnow().isoformat()),
            'tutorId': tutor_id,  # Store as integer
            'status': 'active'
        })

        # Build shareable link
        base_url = request.host_url.rstrip('/')
        shareable_link = f"{base_url}/student-worksheet?id={store_key}"

        logging.info(f"âœ… Worksheet {store_key} created successfully for tutor {tutor_id}")

        return jsonify({
            'message': 'Worksheet created successfully',
            'worksheet_id': store_key,
            'shareable_link': shareable_link,
            'success': True
        }), 201

    except Exception as e:
        logging.error(f"âŒ Create worksheet error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/student/submit-worksheet', methods=['POST'])
def submit_worksheet():
    """Submit completed worksheet answers for AI-powered evaluation."""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400

        worksheet_id = data.get('worksheet_id')
        answers = data.get('answers', {})
        questions = data.get('questions', [])
        subject = data.get('subject', 'general')
        title = data.get('title', 'Worksheet')
        time_taken = data.get('time_taken', 0)

        if not questions or not answers:
            return jsonify({'error': 'Questions and answers are required'}), 400

        # Build evaluation context
        evaluation_results = []
        total_points = 0
        earned_points = 0

        # Calculate actual total possible points from the questions
        actual_total_possible = sum(q.get('points', 10) for q in questions)
        num_questions = len(questions)

        try:
            # Use AI for context-aware answer validation
            if anthropic_client:
                eval_prompt = f"""You are a warm, encouraging educational tutor evaluating a student's worksheet titled "{title}" (Subject: {subject}).

This worksheet has exactly {num_questions} question(s) with a total of {actual_total_possible} possible points.

For each question below, compare the student's answer to the expected answer. Be context-aware:
- Accept answers that are semantically equivalent even if worded differently
- Accept reasonable abbreviations and alternate formats (e.g., "$46" and "46 dollars" are equivalent)
- For math: accept equivalent numerical forms (e.g., "1,180" and "1180")
- Be lenient with capitalization and minor spelling if meaning is clear
- For descriptive/analytical questions, evaluate if the student demonstrates understanding

FEEDBACK GUIDELINES (VERY IMPORTANT):
- When the student gets the answer CORRECT: Write a brief, dynamic, positive feedback message that celebrates their understanding. Vary your responses â€” do NOT just say the answer is "semantically equivalent" or "matches the expected answer." Instead, acknowledge what the student understood well. Examples: "Great job! You clearly understand the role of the nucleus.", "Excellent! You nailed the key differences between cell types.", "Well done â€” your explanation shows strong understanding of this concept."
- When the student gets the answer WRONG: Provide a brief, encouraging correction. First, gently note what was incorrect. Then, clearly explain the correct answer in a helpful way. End with encouragement. Examples: "Not quite â€” the nucleus is the control center of the cell, not the mitochondria. The nucleus contains genetic material and directs cell activities. Keep studying, you're making progress!", "Close, but the answer is eukaryotic, not prokaryotic. Eukaryotic cells have a membrane-bound nucleus. You'll get it next time!"
- NEVER use phrases like "semantically equivalent", "matches the expected answer", or "correctly identifies". Write like a supportive teacher, not a grading machine.
- Keep each feedback to 1-2 sentences for correct answers, and 2-3 sentences for incorrect answers.

Questions and Answers:
"""
                for q in questions:
                    q_num = q.get('questionNumber', 0)
                    student_answer = answers.get(f'q{q_num}', '')
                    eval_prompt += f"""
Question {q_num}: {q.get('questionText', 'Answer question ' + str(q_num))}
Expected Answer: {q.get('expectedAnswer', '')}
Student Answer: {student_answer}
Points: {q.get('points', 10)}
Question Type: {q.get('questionType', 'factual')}
---"""

                eval_prompt += f"""

IMPORTANT: There are exactly {num_questions} question(s) and the total possible points is exactly {actual_total_possible}. The "totalPossible" field MUST equal {actual_total_possible}.

Return ONLY this JSON structure with no other text:
{{
  "results": [
    {{
      "questionNumber": 1,
      "isCorrect": true,
      "pointsAwarded": 10,
      "feedback": "Dynamic, encouraging feedback following the FEEDBACK GUIDELINES above",
      "expectedAnswer": "the expected answer",
      "studentAnswer": "what student wrote"
    }}
  ],
  "totalScore": <sum of pointsAwarded for correct answers>,
  "totalPossible": {actual_total_possible},
  "overallFeedback": "A warm, personalized overall assessment. If the student did well, celebrate their achievement. If they struggled, encourage them and suggest reviewing the material. Be specific about what they did well or need to work on."
}}"""

                response = anthropic_client.messages.create(
                    model="claude-3-haiku-20240307",
                    max_tokens=3000,
                    temperature=0.4,
                    messages=[{"role": "user", "content": eval_prompt}]
                )

                content = response.content[0].text
                json_start = content.find('{')
                json_end = content.rfind('}') + 1

                if json_start >= 0 and json_end > json_start:
                    ai_result = json.loads(content[json_start:json_end])

                    # Enforce correct totalPossible based on actual questions
                    ai_total_possible = ai_result.get('totalPossible', actual_total_possible)
                    ai_total_score = ai_result.get('totalScore', 0)
                    # Clamp to actual values to prevent AI hallucinating wrong totals
                    if ai_total_possible != actual_total_possible:
                        ai_total_possible = actual_total_possible
                    if ai_total_score > actual_total_possible:
                        ai_total_score = actual_total_possible

                    # Save submission to database for dashboard/performance tracking
                    try:
                        submission_id = str(uuid.uuid4())[:12]
                        student_name = data.get('student_name', 'Anonymous Student')
                        db.session.execute(text("""
                            INSERT INTO worksheet_submissions (
                                id, worksheet_id, student_name, answers, evaluation_results,
                                final_score, total_points, time_taken_seconds,
                                extra_time_used, auto_submitted, completed, submitted_at, created_at
                            ) VALUES (
                                :id, :worksheet_id, :student_name, :answers, :evaluation_results,
                                :final_score, :total_points, :time_taken_seconds,
                                :extra_time_used, :auto_submitted, :completed, :submitted_at, :created_at
                            )
                        """), {
                            'id': submission_id,
                            'worksheet_id': worksheet_id,
                            'student_name': student_name,
                            'answers': json.dumps(answers),
                            'evaluation_results': json.dumps(ai_result.get('results', [])),
                            'final_score': ai_total_score,
                            'total_points': ai_total_possible,
                            'time_taken_seconds': time_taken,
                            'extra_time_used': data.get('extra_time_used', False),
                            'auto_submitted': data.get('auto_submitted', False),
                            'completed': True,
                            'submitted_at': datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'),
                            'created_at': datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
                        })
                        db.session.commit()
                        logging.info(f"âœ… Worksheet submission {submission_id} saved for worksheet {worksheet_id}")
                    except Exception as save_err:
                        db.session.rollback()
                        logging.error(f"âš ï¸ Failed to save worksheet submission: {str(save_err)}")

                    return jsonify({
                        'success': True,
                        'results': ai_result.get('results', []),
                        'totalScore': ai_total_score,
                        'totalPossible': ai_total_possible,
                        'overallFeedback': ai_result.get('overallFeedback', ''),
                        'evaluatedByAI': True,
                        'submissionId': submission_id if 'submission_id' in dir() else None
                    }), 200

        except Exception as ai_error:
            logging.error(f"AI evaluation error: {str(ai_error)}")

        # Fallback: basic string comparison evaluation
        import random
        positive_messages = [
            "Well done! You got this one right.",
            "Great work! That's the correct answer.",
            "Excellent! You clearly understand this concept.",
            "Nice job! You nailed it.",
            "Spot on! Keep up the great work.",
            "That's right! You're doing really well.",
            "Perfect answer! You've got a solid grasp on this.",
            "Correct! Your understanding is showing through.",
        ]
        encouraging_messages = [
            "Don't worry â€” review this topic and you'll get it next time!",
            "Keep practicing, you're making progress!",
            "Almost there â€” a little more study and you'll master this!",
            "No worries! Every mistake is a learning opportunity.",
            "Keep going â€” understanding comes with practice!",
        ]

        results = []
        for q in questions:
            q_num = q.get('questionNumber', 0)
            student_answer = answers.get(f'q{q_num}', '').strip().lower()
            expected_answer = q.get('expectedAnswer', '').strip().lower()
            points = q.get('points', 10)
            total_points += points

            # Flexible matching
            is_correct = (
                student_answer == expected_answer or
                student_answer in expected_answer or
                expected_answer in student_answer or
                student_answer.replace(',', '').replace('$', '').replace(' ', '') ==
                expected_answer.replace(',', '').replace('$', '').replace(' ', '')
            )

            points_awarded = points if is_correct else 0
            earned_points += points_awarded

            if is_correct:
                feedback = random.choice(positive_messages)
            else:
                correct_ans = q.get('expectedAnswer', '')
                encouragement = random.choice(encouraging_messages)
                feedback = f'The correct answer is: {correct_ans}. {encouragement}'

            results.append({
                'questionNumber': q_num,
                'isCorrect': is_correct,
                'pointsAwarded': points_awarded,
                'feedback': feedback,
                'expectedAnswer': q.get('expectedAnswer', ''),
                'studentAnswer': answers.get(f'q{q_num}', '')
            })

        # Generate dynamic overall feedback
        percentage = (earned_points / total_points * 100) if total_points > 0 else 0
        if percentage == 100:
            overall_msg = f"Outstanding! You scored {earned_points}/{total_points} â€” a perfect score! You've demonstrated excellent understanding of the material."
        elif percentage >= 80:
            overall_msg = f"Great job! You scored {earned_points}/{total_points}. You have a strong grasp of the material. Review the questions you missed to aim for a perfect score!"
        elif percentage >= 60:
            overall_msg = f"Good effort! You scored {earned_points}/{total_points}. You're on the right track â€” revisit the topics you missed and you'll improve in no time."
        elif percentage >= 40:
            overall_msg = f"You scored {earned_points}/{total_points}. Don't be discouraged â€” review the material and try again. Every attempt helps you learn!"
        else:
            overall_msg = f"You scored {earned_points}/{total_points}. This is a great opportunity to review the material. Take your time studying the topics and give it another go â€” you've got this!"

        # Save submission to database for dashboard/performance tracking
        fallback_submission_id = None
        try:
            fallback_submission_id = str(uuid.uuid4())[:12]
            student_name = data.get('student_name', 'Anonymous Student')
            db.session.execute(text("""
                INSERT INTO worksheet_submissions (
                    id, worksheet_id, student_name, answers, evaluation_results,
                    final_score, total_points, time_taken_seconds,
                    extra_time_used, auto_submitted, completed, submitted_at, created_at
                ) VALUES (
                    :id, :worksheet_id, :student_name, :answers, :evaluation_results,
                    :final_score, :total_points, :time_taken_seconds,
                    :extra_time_used, :auto_submitted, :completed, :submitted_at, :created_at
                )
            """), {
                'id': fallback_submission_id,
                'worksheet_id': worksheet_id,
                'student_name': student_name,
                'answers': json.dumps(answers),
                'evaluation_results': json.dumps(results),
                'final_score': earned_points,
                'total_points': total_points,
                'time_taken_seconds': time_taken,
                'extra_time_used': data.get('extra_time_used', False),
                'auto_submitted': data.get('auto_submitted', False),
                'completed': True,
                'submitted_at': datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'),
                'created_at': datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
            })
            db.session.commit()
            logging.info(f"âœ… Worksheet submission {fallback_submission_id} saved (fallback eval)")
        except Exception as save_err:
            db.session.rollback()
            logging.error(f"âš ï¸ Failed to save worksheet submission: {str(save_err)}")

        return jsonify({
            'success': True,
            'results': results,
            'totalScore': earned_points,
            'totalPossible': total_points,
            'overallFeedback': overall_msg,
            'evaluatedByAI': False,
            'submissionId': fallback_submission_id
        }), 200

    except Exception as e:
        logging.error(f"Submit worksheet error: {str(e)}")
        return jsonify({'error': 'Failed to evaluate worksheet'}), 500

# ============================================================================
# WORKSHEET SCORES & PERFORMANCE ENDPOINTS (for dashboard integration)
# ============================================================================

@app.route('/api/worksheet-scores/<worksheet_id>', methods=['GET'])
def get_worksheet_scores(worksheet_id):
    """Get all submissions for a specific worksheet (mirrors /api/quiz-scores/<id> format)."""
    try:
        logging.info(f"ðŸ“Š Fetching scores for worksheet {worksheet_id}")

        submissions = db.session.execute(text("""
            SELECT id, worksheet_id, student_name, final_score, total_points,
                   time_taken_seconds, extra_time_used, auto_submitted, submitted_at
            FROM worksheet_submissions
            WHERE worksheet_id = :worksheet_id
            ORDER BY submitted_at DESC
        """), {'worksheet_id': worksheet_id}).fetchall()

        formatted = []
        for sub in submissions:
            time_spent = "N/A"
            if sub.time_taken_seconds:
                minutes = sub.time_taken_seconds // 60
                seconds = sub.time_taken_seconds % 60
                time_spent = f"{minutes}m {seconds}s"

            max_score = sub.total_points or 0
            score = sub.final_score or 0
            percentage = round((score / max_score * 100) if max_score > 0 else 0, 1)

            formatted.append({
                'id': sub.id,
                'student_name': sub.student_name or 'Anonymous Student',
                'score': score,
                'max_score': max_score,
                'percentage': percentage,
                'time_spent': time_spent,
                'extra_time_used': bool(sub.extra_time_used),
                'auto_submitted': bool(sub.auto_submitted),
                'submitted_at': sub.submitted_at.isoformat() if sub.submitted_at else None
            })

        # Get worksheet title
        ws = db.session.execute(text(
            "SELECT title FROM worksheets WHERE id = :id"
        ), {'id': worksheet_id}).fetchone()

        return jsonify({
            'worksheet_id': worksheet_id,
            'worksheet_title': ws.title if ws else 'Unknown Worksheet',
            'submissions': formatted,
            'total_submissions': len(formatted)
        }), 200

    except Exception as e:
        logging.error(f"âŒ Get worksheet scores error: {str(e)}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/worksheet-performance', methods=['GET'])
def get_worksheet_performance():
    """Get worksheet performance metrics for dashboards (mirrors /api/quiz-performance format)."""
    try:
        worksheet_id = request.args.get('worksheet_id')
        period = request.args.get('period', 'month')

        now = datetime.utcnow()
        if period == 'week':
            start_date = now - timedelta(days=7)
        elif period == 'year':
            start_date = now - timedelta(days=365)
        else:
            start_date = now - timedelta(days=30)

        start_str = start_date.strftime('%Y-%m-%d %H:%M:%S')

        # Build query
        query = """
            SELECT ws.id, ws.worksheet_id, ws.student_name, ws.final_score,
                   ws.total_points, ws.time_taken_seconds, ws.submitted_at
            FROM worksheet_submissions ws
            WHERE ws.submitted_at >= :start_date
        """
        params = {'start_date': start_str}

        if worksheet_id:
            query += " AND ws.worksheet_id = :worksheet_id"
            params['worksheet_id'] = worksheet_id

        submissions = db.session.execute(text(query), params).fetchall()

        total_submissions = len(submissions)
        if total_submissions == 0:
            return jsonify({
                'total_submissions': 0,
                'total_students': 0,
                'average_score': 0,
                'completion_rate': 0,
                'score_distribution': {"0-59": 0, "60-69": 0, "70-79": 0, "80-89": 0, "90-100": 0},
                'activity_data': []
            }), 200

        score_distribution = {"0-59": 0, "60-69": 0, "70-79": 0, "80-89": 0, "90-100": 0}
        total_score = 0
        student_set = set()

        for sub in submissions:
            pct = (sub.final_score / sub.total_points * 100) if sub.total_points and sub.total_points > 0 else 0
            total_score += pct
            student_set.add(sub.student_name or 'Anonymous')

            if pct < 60:
                score_distribution["0-59"] += 1
            elif pct < 70:
                score_distribution["60-69"] += 1
            elif pct < 80:
                score_distribution["70-79"] += 1
            elif pct < 90:
                score_distribution["80-89"] += 1
            else:
                score_distribution["90-100"] += 1

        average_score = total_score / total_submissions if total_submissions > 0 else 0

        # Activity over time
        activity_query = text("""
            SELECT DATE(submitted_at) as date, COUNT(*) as count
            FROM worksheet_submissions
            WHERE submitted_at >= :start_date
            GROUP BY DATE(submitted_at)
            ORDER BY DATE(submitted_at)
        """)
        activity_rows = db.session.execute(activity_query, {'start_date': start_str}).fetchall()
        activity_data = [{'date': str(r.date), 'count': r.count} for r in activity_rows]

        # Total worksheets count
        ws_count_row = db.session.execute(text(
            "SELECT COUNT(*) as cnt FROM worksheets WHERE status = 'active'"
        )).fetchone()
        total_worksheets = ws_count_row.cnt if ws_count_row else 0

        return jsonify({
            'total_submissions': total_submissions,
            'total_students': len(student_set),
            'total_worksheets': total_worksheets,
            'average_score': round(average_score, 1),
            'completion_rate': 100,
            'score_distribution': score_distribution,
            'activity_data': activity_data
        }), 200

    except Exception as e:
        logging.error(f"âŒ Get worksheet performance error: {str(e)}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/worksheet-submissions', methods=['GET'])
def get_all_worksheet_submissions():
    """Get all worksheet submissions (list of worksheets with submission counts)."""
    try:
        worksheets = db.session.execute(text("""
            SELECT w.id, w.title, w.subject, w.created_at,
                   COUNT(ws.id) as submission_count,
                   AVG(ws.final_score) as avg_score,
                   AVG(ws.total_points) as avg_total
            FROM worksheets w
            LEFT JOIN worksheet_submissions ws ON ws.worksheet_id = w.id
            WHERE w.status = 'active'
            GROUP BY w.id, w.title, w.subject, w.created_at
            ORDER BY w.created_at DESC
        """)).fetchall()

        result = []
        for ws in worksheets:
            avg_pct = 0
            if ws.avg_score and ws.avg_total and ws.avg_total > 0:
                avg_pct = round((ws.avg_score / ws.avg_total) * 100, 1)

            result.append({
                'id': ws.id,
                'title': ws.title,
                'subject': ws.subject,
                'created_at': ws.created_at.isoformat() if ws.created_at else None,
                'submission_count': ws.submission_count or 0,
                'average_score': avg_pct
            })

        return jsonify({
            'success': True,
            'worksheets': result,
            'total': len(result)
        }), 200

    except Exception as e:
        logging.error(f"âŒ Get all worksheet submissions error: {str(e)}")
        return jsonify({'error': str(e)}), 500


# Student worksheet endpoint - get worksheet data by ID
@app.route('/api/student/worksheet/<worksheet_id>', methods=['GET'])
def get_student_worksheet(worksheet_id):
    """Get worksheet for student to complete."""
    try:
        logging.info(f"Student requesting worksheet {worksheet_id}")

        # Check persistent store (memory + disk)
        ws = _load_worksheet(worksheet_id)
        if ws:
            # Remove expected answers from questions sent to student
            student_questions = []
            for q in ws.get('questions', []):
                sq = {
                    'questionNumber': q.get('questionNumber'),
                    'questionText': q.get('questionText', ''),
                    'includeQuestion': q.get('includeQuestion', ws.get('includeQuestions', True)),
                    'questionType': q.get('question_type', q.get('questionType', 'factual')),
                    'points': q.get('points', 10),
                    'answer_format': q.get('answer_format', 'input')
                }
                # Include options for multiple choice and true/false
                if sq['answer_format'] == 'multiple_choice' and q.get('options'):
                    sq['options'] = q['options']
                elif sq['answer_format'] == 'true_false':
                    sq['options'] = ['True', 'False']
                student_questions.append(sq)

            result = {
                'id': ws['id'],
                'title': ws['title'],
                'subject': ws['subject'],
                'includeQuestions': ws.get('includeQuestions', True),
                'questionMode': ws.get('questionMode', 'list'),
                'timeLimit': ws['timeLimit'],
                'extraTime': ws.get('extraTime', {'allowed': False, 'seconds': 0, 'minutes': 0}),
                'mediaFile': ws.get('mediaFile'),
                'mediaFiles': ws.get('mediaFiles', []),
                'questions': student_questions
            }
            return jsonify(result), 200

        # Try database
        try:
            worksheet = db.session.execute(
                text("SELECT * FROM worksheets WHERE id = :id AND status = 'active'"),
                {"id": worksheet_id}
            ).fetchone()

            if worksheet:
                # Parse worksheet_data JSON for extra fields that may not be DB columns
                ws_data_raw = getattr(worksheet, 'worksheet_data', None)
                ws_extra = {}
                ws_data_questions = {}
                try:
                    if ws_data_raw:
                        ws_extra = json.loads(ws_data_raw) if isinstance(ws_data_raw, str) else ws_data_raw
                        for wq in ws_extra.get('questions', []):
                            ws_data_questions[wq.get('questionNumber')] = wq
                except Exception:
                    pass

                questions = db.session.execute(
                    text("SELECT * FROM worksheet_questions WHERE worksheet_id = :id ORDER BY question_number"),
                    {"id": worksheet_id}
                ).fetchall()

                # Safe column access with fallback to worksheet_data JSON
                include_questions = getattr(worksheet, 'include_questions', None)
                if include_questions is None:
                    include_questions = ws_extra.get('includeQuestions', True)

                student_questions = []
                for q in questions:
                    sq = {
                        'questionNumber': q.question_number,
                        'questionText': q.question_text or '',
                        'includeQuestion': bool(include_questions),
                        'questionType': q.question_type or 'factual',
                        'points': q.points or 10,
                        'answer_format': 'input'
                    }
                    # Enrich with answer_format/options from worksheet_data if available
                    stored_q = ws_data_questions.get(q.question_number, {})
                    if stored_q.get('answer_format'):
                        sq['answer_format'] = stored_q['answer_format']
                    if sq['answer_format'] == 'multiple_choice' and stored_q.get('options'):
                        sq['options'] = stored_q['options']
                    elif sq['answer_format'] == 'true_false':
                        sq['options'] = ['True', 'False']
                    student_questions.append(sq)

                # Get question_mode: try DB column, then worksheet_data JSON
                question_mode = getattr(worksheet, 'question_mode', None) or ws_extra.get('questionMode', 'list')

                # Build time limit
                tl_seconds = worksheet.time_limit_seconds or 0

                # Extra time from DB columns or JSON
                extra_time_allowed = getattr(worksheet, 'extra_time_allowed', None)
                extra_time_seconds = getattr(worksheet, 'extra_time_seconds', None)
                if extra_time_allowed is None:
                    et = ws_extra.get('extraTime', {})
                    extra_time_allowed = et.get('allowed', False)
                    extra_time_seconds = et.get('seconds', 0)

                # Media from DB columns or JSON
                media_file_url = getattr(worksheet, 'media_file_url', None)
                media_file_type = getattr(worksheet, 'media_file_type', None)
                media_files = ws_extra.get('mediaFiles', [])

                result = {
                    'id': worksheet.id,
                    'title': worksheet.title,
                    'subject': worksheet.subject,
                    'includeQuestions': bool(include_questions),
                    'questionMode': question_mode,
                    'timeLimit': {
                        'totalSeconds': tl_seconds,
                        'hours': tl_seconds // 3600,
                        'minutes': (tl_seconds % 3600) // 60,
                        'seconds': tl_seconds % 60
                    },
                    'extraTime': {
                        'allowed': bool(extra_time_allowed),
                        'seconds': extra_time_seconds or 0,
                        'minutes': (extra_time_seconds or 0) // 60
                    },
                    'mediaFile': {
                        'url': media_file_url,
                        'type': media_file_type
                    } if media_file_url else ws_extra.get('mediaFile'),
                    'mediaFiles': media_files,
                    'questions': student_questions
                }

                return jsonify(result), 200

        except Exception as db_error:
            logging.error(f"Database error: {str(db_error)}")

        return jsonify({'error': 'Worksheet not found'}), 404

    except Exception as e:
        logging.error(f"Get student worksheet error: {str(e)}")
        return jsonify({'error': 'Failed to load worksheet'}), 500


# ============================================================================
# TUTOR WORKSHEETS MANAGEMENT ENDPOINTS
# ============================================================================

@app.route('/api/tutor/worksheets', methods=['GET'])
def get_tutor_worksheets():
    """Get all worksheets, sorted by creation date. Worksheets are public and not restricted to a specific tutor."""
    try:
        logging.info(f"ðŸ” Fetching all worksheets")

        subject = request.args.get('subject', '')
        topic = request.args.get('topic', '')
        status = request.args.get('status', 'active')

        result = []
        db_worksheet_ids = set()

        # 1. Query database for all worksheets (not filtered by tutor_id)
        try:
            query = """
                SELECT id, title, subject, time_limit_seconds, status, created_at, worksheet_data,
                       (SELECT COUNT(*) FROM worksheet_questions WHERE worksheet_id = worksheets.id) as question_count
                FROM worksheets
                WHERE status = :status
            """
            params = {'status': status}

            if subject:
                query += " AND subject = :subject"
                params['subject'] = subject

            query += " ORDER BY created_at DESC"

            worksheets = db.session.execute(text(query), params).fetchall()

            logging.info(f"ðŸ“Š Found {len(worksheets)} worksheets in database")

            for ws in worksheets:
                # Parse worksheet_data JSON for extra fields (topic, questionMode, etc.)
                ws_extra = {}
                try:
                    raw = getattr(ws, 'worksheet_data', None)
                    if raw:
                        ws_extra = json.loads(raw) if isinstance(raw, str) else raw
                except Exception:
                    pass

                ws_topic = ws_extra.get('topic', '')
                ws_mode = ws_extra.get('questionMode', 'list')

                # Apply topic filter on parsed data if requested
                if topic and topic.lower() not in ws_topic.lower():
                    continue

                db_worksheet_ids.add(ws.id)
                result.append({
                    'id': ws.id,
                    'title': ws.title,
                    'subject': ws.subject,
                    'topic': ws_topic,
                    'questionMode': ws_mode,
                    'includeQuestions': ws_extra.get('includeQuestions', True),
                    'timeLimitSeconds': ws.time_limit_seconds,
                    'status': ws.status,
                    'questionCount': ws.question_count or 0,
                    'createdAt': ws.created_at.isoformat() if ws.created_at else None
                })
        except Exception as db_err:
            logging.error(f"âš ï¸ Database query error in get_tutor_worksheets: {str(db_err)}")

        # 2. Also check memory/S3 store for worksheets not found in database
        # This catches worksheets where the DB insert may have failed
        try:
            store_worksheets = dict(_worksheet_store)
            memory_added = 0
            for ws_id, ws_data in store_worksheets.items():
                if ws_id in db_worksheet_ids:
                    continue  # Already in DB results, skip duplicate

                ws_status = ws_data.get('status', 'active')
                if ws_status != status:
                    continue

                ws_topic_val = ws_data.get('topic', '')
                if subject and ws_data.get('subject') != subject:
                    continue
                if topic and topic.lower() not in ws_topic_val.lower():
                    continue

                time_limit = ws_data.get('timeLimit', {})
                total_seconds = time_limit.get('totalSeconds', 0) if isinstance(time_limit, dict) else 0

                result.append({
                    'id': ws_id,
                    'title': ws_data.get('title', 'Untitled'),
                    'subject': ws_data.get('subject', ''),
                    'topic': ws_topic_val,
                    'questionMode': ws_data.get('questionMode', 'list'),
                    'includeQuestions': ws_data.get('includeQuestions', True),
                    'timeLimitSeconds': total_seconds,
                    'status': ws_status,
                    'questionCount': len(ws_data.get('questions', [])),
                    'createdAt': ws_data.get('createdAt')
                })
                memory_added += 1

            if memory_added > 0:
                logging.info(f"ðŸ“Š Added {memory_added} worksheets from memory/S3 store")
        except Exception as store_err:
            logging.error(f"âš ï¸ Error loading worksheets from memory store: {str(store_err)}")

        # Sort combined results by createdAt descending (newest first)
        result.sort(key=lambda w: w.get('createdAt') or '', reverse=True)

        # Get unique subjects for filtering (from combined results)
        unique_subjects = sorted(set(ws['subject'] for ws in result if ws.get('subject')))

        logging.info(f"ðŸ“Š Returning {len(result)} total worksheets")

        return jsonify({
            'success': True,
            'worksheets': result,
            'subjects': unique_subjects,
            'total': len(result)
        }), 200

    except Exception as e:
        logging.error(f"âŒ Get tutor worksheets error: {str(e)}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/tutor/worksheet/<worksheet_id>', methods=['GET'])
def get_tutor_worksheet_for_edit(worksheet_id):
    """Get full worksheet data for editing (includes expected answers)."""
    try:
        # Try persistent store first
        ws = _load_worksheet(worksheet_id)
        if ws:
            return jsonify({
                'success': True,
                'worksheet': ws
            }), 200

        # Try database
        worksheet = db.session.execute(
            text("SELECT * FROM worksheets WHERE id = :id"),
            {"id": worksheet_id}
        ).fetchone()

        if worksheet:
            # Return stored worksheet_data if available (most complete source)
            ws_data_raw = getattr(worksheet, 'worksheet_data', None)
            if ws_data_raw:
                try:
                    ws_data = json.loads(ws_data_raw) if isinstance(ws_data_raw, str) else ws_data_raw
                    ws_data['id'] = worksheet.id
                    return jsonify({
                        'success': True,
                        'worksheet': ws_data
                    }), 200
                except Exception:
                    pass

            # Build from DB fields with safe column access
            questions = db.session.execute(
                text("SELECT * FROM worksheet_questions WHERE worksheet_id = :id ORDER BY question_number"),
                {"id": worksheet_id}
            ).fetchall()

            tl_seconds = worksheet.time_limit_seconds or 0
            ws_data = {
                'id': worksheet.id,
                'title': worksheet.title,
                'subject': worksheet.subject,
                'topic': getattr(worksheet, 'topic', '') or '',
                'includeQuestions': bool(getattr(worksheet, 'include_questions', True)),
                'questionMode': getattr(worksheet, 'question_mode', 'list') or 'list',
                'timeLimit': {
                    'totalSeconds': tl_seconds,
                    'hours': tl_seconds // 3600,
                    'minutes': (tl_seconds % 3600) // 60,
                    'seconds': tl_seconds % 60
                },
                'extraTime': {
                    'allowed': bool(getattr(worksheet, 'extra_time_allowed', False)),
                    'seconds': getattr(worksheet, 'extra_time_seconds', 0) or 0,
                    'minutes': (getattr(worksheet, 'extra_time_seconds', 0) or 0) // 60
                },
                'questions': [{
                    'questionNumber': q.question_number,
                    'questionText': q.question_text or '',
                    'expectedAnswer': q.expected_answer,
                    'answer_format': getattr(q, 'answer_format', 'input') or 'input',
                    'options': json.loads(q.options) if getattr(q, 'options', None) else [],
                    'question_type': q.question_type or 'factual',
                    'points': q.points or 10
                } for q in questions],
                'status': worksheet.status
            }

            return jsonify({
                'success': True,
                'worksheet': ws_data
            }), 200

        return jsonify({'error': 'Worksheet not found'}), 404

    except Exception as e:
        logging.error(f"Get worksheet for edit error: {str(e)}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/tutor/worksheet/<worksheet_id>', methods=['DELETE'])
def delete_worksheet(worksheet_id):
    """Archive (soft delete) a worksheet."""
    try:
        db.session.execute(
            text("UPDATE worksheets SET status = 'archived' WHERE id = :id"),
            {"id": worksheet_id}
        )
        db.session.commit()

        # Also remove from cache
        if worksheet_id in _worksheet_store:
            del _worksheet_store[worksheet_id]

        return jsonify({'success': True, 'message': 'Worksheet archived'}), 200

    except Exception as e:
        db.session.rollback()
        logging.error(f"Delete worksheet error: {str(e)}")
        return jsonify({'error': str(e)}), 500


# Internal endpoint to get worksheet with answers (for evaluation)
@app.route('/api/internal/worksheet-answers/<worksheet_id>', methods=['GET'])
def get_worksheet_answers(worksheet_id):
    """Get worksheet with expected answers for evaluation (internal use)."""
    try:
        # Check persistent store (memory + disk)
        ws = _load_worksheet(worksheet_id)
        if ws:
            return jsonify({
                'success': True,
                'questions': ws.get('questions', []),
                'title': ws['title'],
                'subject': ws['subject']
            }), 200

        # Try database
        try:
            worksheet = db.session.execute(
                text("SELECT * FROM worksheets WHERE id = :id"),
                {"id": worksheet_id}
            ).fetchone()

            if worksheet:
                questions = db.session.execute(
                    text("SELECT * FROM worksheet_questions WHERE worksheet_id = :id ORDER BY question_number"),
                    {"id": worksheet_id}
                ).fetchall()

                return jsonify({
                    'success': True,
                    'questions': [
                        {
                            'questionNumber': q.question_number,
                            'questionText': q.question_text or '',
                            'expectedAnswer': q.expected_answer,
                            'questionType': q.question_type or 'factual',
                            'points': q.points or 10
                        } for q in questions
                    ],
                    'title': worksheet.title,
                    'subject': worksheet.subject
                }), 200
        except Exception as db_error:
            logging.error(f"Database error fetching answers: {str(db_error)}")

        return jsonify({'error': 'Worksheet not found'}), 404
    except Exception as e:
        logging.error(f"Get worksheet answers error: {str(e)}")
        return jsonify({'error': str(e)}), 500


# Enhanced tutor required decorator
def tutor_required(f):
    """Decorator to require tutor authentication"""
    from functools import wraps
    
    @wraps(f)
    def decorated_function(*args, **kwargs):
        try:
            auth_header = request.headers.get('Authorization')
            if not auth_header or not auth_header.startswith('Bearer '):
                return jsonify({'error': 'No valid token provided'}), 401
                
            # For development, skip token validation
            # In production, implement proper JWT validation
            request.current_tutor = type('obj', (object,), {'id': 1, 'name': 'Sample Tutor'})
            
            return f(*args, **kwargs)
        except Exception as e:
            logging.error(f"Tutor auth error: {str(e)}")
            return jsonify({'error': 'Authentication failed'}), 401
    
    return decorated_function

# Enhanced route to get story context for evaluation
@app.route('/api/get-story-context/<story_id>', methods=['GET'])
def get_story_context(story_id):
    """Get story context for paragraph evaluation."""
    try:
        # This would typically query your database
        # For now, return context for the genetic diversity story
        story_contexts = {
            'genetic-diversity': {
                'title': 'Gene-iuses Come in All Kinds',
                'summary': 'A story about Jidenna learning that genetic variation within families is natural and valuable, where being different makes him unique rather than wrong.',
                'key_themes': [
                    'Genetic diversity within families',
                    'Individual uniqueness and self-acceptance',
                    'Scientific understanding of inheritance',
                    'The value of being different',
                    'Statistical concepts like outliers and variation'
                ],
                'character_context': 'Jidenna feels different from his family members who share obvious traits like dimples and curly hair, while he has straight hair and different features.',
                'lesson_learned': 'Genetic variation is nature\'s way of ensuring survival and adaptation - being different is valuable and special.'
            }
        }
        
        context = story_contexts.get(story_id)
        if not context:
            return jsonify({'error': 'Story not found'}), 404
            
        return jsonify(context), 200
        
    except Exception as e:
        app.logger.error(f"Error getting story context: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/stories/<int:story_id>', methods=['PUT'])
def update_story(story_id):
    """Update an existing story"""
    try:
        data = request.get_json()
        
        connection = get_db_connection()
        if not connection:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = connection.cursor()
        
        try:
            connection.start_transaction()
            
            # Update story
            story_query = """
                UPDATE stories 
                SET title = %s, subtitle = %s, description = %s, 
                    background_type = %s, primary_color = %s, 
                    secondary_color = %s, animated_elements = %s,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = %s
            """
            
            bg_settings = data.get('backgroundSettings', {})
            story_values = (
                data['title'],
                data.get('subtitle', ''),
                data.get('description', ''),
                bg_settings.get('type', 'gradient'),
                bg_settings.get('primaryColor', '#87CEEB'),
                bg_settings.get('secondaryColor', '#B0E0E6'),
                bg_settings.get('animatedElements', 'all'),
                story_id
            )
            
            cursor.execute(story_query, story_values)
            
            # Delete existing chapters and questions
            cursor.execute("DELETE FROM chapters WHERE story_id = %s", (story_id,))
            cursor.execute("DELETE FROM questions WHERE story_id = %s", (story_id,))
            
            # Re-insert chapters (same logic as create)
            for i, chapter in enumerate(data['chapters'], 1):
                chapter_query = """
                    INSERT INTO chapters (story_id, chapter_number, title, content, image_url)
                    VALUES (%s, %s, %s, %s, %s)
                """
                chapter_values = (story_id, i, chapter['title'], chapter['content'], chapter.get('image'))
                cursor.execute(chapter_query, chapter_values)
            
            # Re-insert questions (same logic as create)
            for i, question in enumerate(data['questions'], 1):
                question_query = """
                    INSERT INTO questions (story_id, question_number, question_text, 
                                         question_type, answer_station_id, explanation, 
                                         guidelines, min_words)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """
                question_values = (
                    story_id, i, question['question'], question['type'],
                    question.get('answerStationId'), question.get('explanation'),
                    question.get('guidelines'), question.get('minWords', 30)
                )
                cursor.execute(question_query, question_values)
                question_id = cursor.lastrowid
                
                # Insert multiple choice options if applicable
                if question['type'] == 'multiple-choice' and 'options' in question:
                    for j, option in enumerate(question['options']):
                        option_query = """
                            INSERT INTO question_options (question_id, option_letter, option_text, is_correct)
                            VALUES (%s, %s, %s, %s)
                        """
                        option_values = (
                            question_id,
                            chr(65 + j),  # A, B, C, D
                            option,
                            j == question.get('correct', 0)
                        )
                        cursor.execute(option_query, option_values)
            
            # Commit all changes
            connection.commit()
            
            cursor.close()
            connection.close()
            
            return jsonify({
                'success': True,
                'message': 'Story updated successfully',
                'story_id': story_id
            })
            
        except Exception as e:
            # Rollback transaction on error
            connection.rollback()
            logger.error(f"Error in update transaction: {str(e)}")
            raise e
            
    except Error as e:
        logger.error(f"Error updating story: {e}")
        return jsonify({'error': str(e)}), 500
    except Exception as e:
        logger.error(f"Unexpected error updating story: {e}")
        return jsonify({'error': 'An unexpected error occurred'}), 500
    finally:
        # Ensure connection is closed
        if 'connection' in locals() and connection.is_connected():
            cursor.close()
            connection.close()

# Additional helper function for bulk operations
def bulk_insert_questions(cursor, story_id, questions_data):
    """Helper function to insert multiple questions with their options"""
    try:
        for i, question in enumerate(questions_data, 1):
            # Insert question
            question_query = """
                INSERT INTO questions (story_id, question_number, question_text, 
                                     question_type, answer_station_id, explanation, 
                                     guidelines, min_words, points_possible)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            question_values = (
                story_id,
                i,
                question['question'],
                question['type'],
                question.get('answerStationId'),
                question.get('explanation'),
                question.get('guidelines'),
                question.get('minWords', 30),
                question.get('points', 10)
            )
            cursor.execute(question_query, question_values)
            question_id = cursor.lastrowid
            
            # Insert multiple choice options if applicable
            if question['type'] == 'multiple-choice' and 'options' in question:
                for j, option in enumerate(question['options']):
                    if option.strip():  # Only insert non-empty options
                        option_query = """
                            INSERT INTO question_options (question_id, option_letter, option_text, is_correct, explanation)
                            VALUES (%s, %s, %s, %s, %s)
                        """
                        option_values = (
                            question_id,
                            chr(65 + j),  # A, B, C, D
                            option.strip(),
                            j == question.get('correct', 0),
                            question.get('optionExplanations', {}).get(chr(65 + j), '')
                        )
                        cursor.execute(option_query, option_values)
            
            # Insert answer stations for "Find Answer" feature
            if question.get('answerStationId'):
                station_query = """
                    INSERT INTO answer_stations (story_id, station_id, context_description)
                    VALUES (%s, %s, %s)
                    ON DUPLICATE KEY UPDATE context_description = VALUES(context_description)
                """
                station_values = (
                    story_id,
                    question['answerStationId'],
                    f"Answer location for: {question['question'][:100]}..."
                )
                cursor.execute(station_query, station_values)
        
        return True
        
    except Exception as e:
        logger.error(f"Error in bulk insert questions: {str(e)}")
        raise e

def bulk_insert_chapters(cursor, story_id, chapters_data):
    """Helper function to insert multiple chapters"""
    try:
        for i, chapter in enumerate(chapters_data, 1):
            if not chapter.get('title') or not chapter.get('content'):
                raise ValueError(f"Chapter {i} missing title or content")
            
            chapter_query = """
                INSERT INTO chapters (story_id, chapter_number, title, content, image_url, image_alt_text)
                VALUES (%s, %s, %s, %s, %s, %s)
            """
            chapter_values = (
                story_id,
                i,
                chapter['title'],
                chapter['content'],
                chapter.get('image'),
                chapter.get('imageAlt', f"Chapter {i} illustration")
            )
            cursor.execute(chapter_query, chapter_values)
        
        return True
        
    except Exception as e:
        logger.error(f"Error in bulk insert chapters: {str(e)}")
        raise e

# Enhanced update function with better error handling and validation
@app.route('/api/stories/<int:story_id>/enhanced-update', methods=['PUT'])
def enhanced_update_story(story_id):
    """Enhanced update story with better validation and error handling"""
    try:
        data = request.get_json()
        
        # Validation
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        required_fields = ['title', 'chapters', 'questions']
        for field in required_fields:
            if field not in data:
                return jsonify({'error': f'Missing required field: {field}'}), 400
        
        if len(data['chapters']) != 3:
            return jsonify({'error': 'Exactly 3 chapters are required'}), 400
        
        if len(data['questions']) == 0:
            return jsonify({'error': 'At least one question is required'}), 400
        
        connection = get_db_connection()
        if not connection:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = connection.cursor()
        
        try:
            # Check if story exists
            cursor.execute("SELECT id, status FROM stories WHERE id = %s", (story_id,))
            existing_story = cursor.fetchone()
            
            if not existing_story:
                return jsonify({'error': 'Story not found'}), 404
            
            # Start transaction
            connection.start_transaction()
            
            # Update story metadata
            story_query = """
                UPDATE stories 
                SET title = %s, subtitle = %s, description = %s, 
                    background_type = %s, primary_color = %s, 
                    secondary_color = %s, animated_elements = %s,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = %s
            """
            
            bg_settings = data.get('backgroundSettings', {})
            story_values = (
                data['title'],
                data.get('subtitle', ''),
                data.get('description', ''),
                bg_settings.get('type', 'gradient'),
                bg_settings.get('primaryColor', '#87CEEB'),
                bg_settings.get('secondaryColor', '#B0E0E6'),
                bg_settings.get('animatedElements', 'all'),
                story_id
            )
            
            cursor.execute(story_query, story_values)
            
            # Delete existing related data (CASCADE will handle dependencies)
            cursor.execute("DELETE FROM chapters WHERE story_id = %s", (story_id,))
            cursor.execute("DELETE FROM questions WHERE story_id = %s", (story_id,))
            
            # Insert new chapters using bulk function
            bulk_insert_chapters(cursor, story_id, data['chapters'])
            
            # Insert new questions using bulk function
            bulk_insert_questions(cursor, story_id, data['questions'])
            
            # Update story tags if provided
            if 'tags' in data:
                cursor.execute("DELETE FROM story_tags WHERE story_id = %s", (story_id,))
                for tag in data['tags']:
                    if tag.strip():
                        tag_query = """
                            INSERT INTO story_tags (story_id, tag_name, tag_category)
                            VALUES (%s, %s, %s)
                        """
                        cursor.execute(tag_query, (story_id, tag.strip(), 'topic'))
            
            # Commit all changes
            connection.commit()
            
            # Get updated story data for response
            cursor.execute("SELECT * FROM stories WHERE id = %s", (story_id,))
            updated_story = cursor.fetchone()
            
            cursor.close()
            connection.close()
            
            return jsonify({
                'success': True,
                'message': 'Story updated successfully',
                'story_id': story_id,
                'updated_at': updated_story[9].isoformat() if updated_story[9] else None  # updated_at timestamp
            })
            
        except ValueError as ve:
            connection.rollback()
            return jsonify({'error': str(ve)}), 400
        except Exception as e:
            connection.rollback()
            logger.error(f"Error in enhanced update transaction: {str(e)}")
            raise e
            
    except Error as e:
        logger.error(f"Database error updating story: {e}")
        return jsonify({'error': f'Database error: {str(e)}'}), 500
    except Exception as e:
        logger.error(f"Unexpected error updating story: {e}")
        return jsonify({'error': 'An unexpected error occurred'}), 500
    finally:
        # Ensure connection is properly closed
        if 'connection' in locals() and connection and connection.is_connected():
            if 'cursor' in locals() and cursor:
                cursor.close()
            connection.close()

# Function to validate story data structure
def validate_story_data(data):
    """Validate the structure and content of story data"""
    errors = []
    
    # Basic required fields
    if not data.get('title', '').strip():
        errors.append('Story title is required and cannot be empty')
    
    # Chapters validation
    chapters = data.get('chapters', [])
    if len(chapters) != 3:
        errors.append('Exactly 3 chapters are required')
    
    for i, chapter in enumerate(chapters, 1):
        if not chapter.get('title', '').strip():
            errors.append(f'Chapter {i} title is required')
        if not chapter.get('content', '').strip():
            errors.append(f'Chapter {i} content is required')
        if len(chapter.get('content', '')) < 50:
            errors.append(f'Chapter {i} content should be at least 50 characters')
    
    # Questions validation
    questions = data.get('questions', [])
    if len(questions) == 0:
        errors.append('At least one question is required')
    
    for i, question in enumerate(questions, 1):
        if not question.get('question', '').strip():
            errors.append(f'Question {i} text is required')
        
        q_type = question.get('type')
        if q_type not in ['multiple-choice', 'paragraph']:
            errors.append(f'Question {i} must be either multiple-choice or paragraph type')
        
        if q_type == 'multiple-choice':
            options = question.get('options', [])
            if len(options) < 2:
                errors.append(f'Question {i} needs at least 2 options')
            if len([opt for opt in options if opt.strip()]) < 2:
                errors.append(f'Question {i} needs at least 2 non-empty options')
            if not isinstance(question.get('correct'), int) or question.get('correct') < 0:
                errors.append(f'Question {i} needs a valid correct answer index')
        
        elif q_type == 'paragraph':
            min_words = question.get('minWords', 0)
            if not isinstance(min_words, int) or min_words < 10:
                errors.append(f'Question {i} minimum words should be at least 10')
    
    return errors

# Route with validation
@app.route('/api/stories/<int:story_id>/validate-and-update', methods=['PUT'])
def validate_and_update_story(story_id):
    """Update story with comprehensive validation"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        # Validate data structure
        validation_errors = validate_story_data(data)
        if validation_errors:
            return jsonify({
                'error': 'Validation failed',
                'details': validation_errors
            }), 400
        
        # Proceed with update using the enhanced update function
        return enhanced_update_story(story_id)
        
    except Exception as e:
        logger.error(f"Error in validate and update: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/xwhy-creator.html')
def serve_xwhy_creator():
    """Serve the X-Why-Creator main page"""
    return send_from_directory('.', 'xwhy-creator.html')

# API endpoint for generating questions
@app.route('/api/xwhy-creator/generate-questions', methods=['POST'])
def xwhy_generate_questions():
    """Generate questions for the X-Why-Creator using Claude API"""
    try:
        # Get request data
        data = request.json
        topic = data.get('topic', 'mixed')
        grace_mode = data.get('graceMode', True)
        
        logger.info(f"Generating questions for topic: {topic}, grace mode: {grace_mode}")
        
        # Build prompt based on topic and grace mode
        prompt = build_prompt_for_topic(topic, grace_mode)
        
        # Call Claude API
        response = anthropic_client.messages.create(
            model="claude-3-haiku-20240307",
            max_tokens=4000,
            temperature=0.7,
            messages=[
                {"role": "user", "content": prompt}
            ]
        )
        
        # Extract AI response content
        content = response.content[0].text
        logger.info('Got AI response, length: %d', len(content))
        
        # Parse JSON from the response
        try:
            # Try to find JSON in the response using regex
            import re
            json_match = re.search(r'({[\s\S]*})', content)
            
            if json_match:
                questions_data = json.loads(json_match.group(1))
            else:
                logger.warning("No JSON found in response, attempting fallback parsing")
                # Try to extract just the questions array if complete JSON object not found
                questions_match = re.search(r'"questions":\s*(\[[\s\S]*\])', content)
                if questions_match:
                    questions_data = {"questions": json.loads(questions_match.group(1))}
                else:
                    raise ValueError("No parsable JSON found in Claude response")
        except Exception as parse_error:
            logger.error('Error parsing JSON from Claude response: %s', parse_error)
            return jsonify({"error": "Failed to parse AI response"}), 500
        
        # Validate questions format
        if not questions_data or not questions_data.get('questions') or not isinstance(questions_data.get('questions'), list):
            logger.error("Invalid question format from AI")
            return jsonify({"error": "Invalid response format from AI"}), 500
        
        # If we have incomplete questions, we'll regenerate them
        questions = questions_data.get('questions', [])
        has_incomplete_questions = any(
            not q.get('options') or 
            len(q.get('options', [])) != 2 or 
            not q.get('followUp') or
            not q.get('followUp', {}).get('correct') or
            not q.get('followUp', {}).get('correct', {}).get('options') or
            len(q.get('followUp', {}).get('correct', {}).get('options', [])) != 2 or
            not q.get('followUp', {}).get('incorrect') or
            not q.get('followUp', {}).get('incorrect', {}).get('options') or
            len(q.get('followUp', {}).get('incorrect', {}).get('options', [])) != 2
            for q in questions
        )
        
        if has_incomplete_questions:
            logger.warning('Detected incomplete questions. Requesting a new generation with stronger instructions')
            
            # Create a more specific prompt that emphasizes complete structure
            enhanced_prompt = prompt + """

CRITICAL ERROR IN PREVIOUS RESPONSE:
Your response was missing required elements for the X-Why-Creator game. Please regenerate with COMPLETE question structures.

EVERY question MUST have:
1. A main question with exactly TWO options (one correct, one incorrect)
2. A 'correct' follow-up with its own question about why the correct answer is correct
3. Two explanation options for the 'correct' follow-up (one correct, one incorrect)
4. An 'incorrect' follow-up with its own question about why the incorrect answer is wrong
5. Two explanation options for the 'incorrect' follow-up (one correct, one incorrect)

The game WILL BREAK if any of these elements are missing. Please provide a fully compliant response.
"""
            
            # Make another API call with enhanced prompt
            retry_response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=4000,
                temperature=0.7,
                messages=[
                    {"role": "user", "content": enhanced_prompt}
                ]
            )
            
            # Extract and parse the retry response
            retry_content = retry_response.content[0].text
            json_match = re.search(r'({[\s\S]*})', retry_content)
            
            if json_match:
                retry_data = json.loads(json_match.group(1))
                
                # Validate the retry response
                retry_questions = retry_data.get('questions', [])
                retry_valid = all(
                    q.get('options') and 
                    len(q.get('options', [])) == 2 and 
                    q.get('followUp') and
                    q.get('followUp', {}).get('correct') and
                    q.get('followUp', {}).get('correct', {}).get('options') and
                    len(q.get('followUp', {}).get('correct', {}).get('options', [])) == 2 and
                    q.get('followUp', {}).get('incorrect') and
                    q.get('followUp', {}).get('incorrect', {}).get('options') and
                    len(q.get('followUp', {}).get('incorrect', {}).get('options', [])) == 2
                    for q in retry_questions
                )
                
                if retry_valid and retry_questions:
                    logger.info("Retry generated valid questions")
                    questions = retry_questions
        
        # Validate each question to ensure correct structure
        validated_questions = []
        for i, question in enumerate(questions):
            # Skip questions with missing critical elements
            if (not question.get('question') or
                not question.get('options') or 
                len(question.get('options', [])) != 2 or
                not question.get('followUp') or
                not question.get('followUp', {}).get('correct') or
                not question.get('followUp', {}).get('correct', {}).get('options') or
                len(question.get('followUp', {}).get('correct', {}).get('options', [])) != 2 or
                not question.get('followUp', {}).get('incorrect') or
                not question.get('followUp', {}).get('incorrect', {}).get('options') or
                len(question.get('followUp', {}).get('incorrect', {}).get('options', [])) != 2):
                
                logger.warning(f"Skipping question {i+1} due to incomplete structure")
                continue
                
            # Ensure exactly one correct option in main question
            correct_count = sum(1 for opt in question['options'] if opt.get('isCorrect'))
            if correct_count != 1:
                logger.warning(f"Question {i+1} has {correct_count} correct answers, fixing...")
                for j, option in enumerate(question['options']):
                    option['isCorrect'] = j == 0  # Make first option correct
            
            # Ensure exactly one correct option in follow-up questions
            for follow_up_type in ['correct', 'incorrect']:
                follow_up = question['followUp'][follow_up_type]
                correct_count = sum(1 for opt in follow_up['options'] if opt.get('isCorrect'))
                if correct_count != 1:
                    logger.warning(f"Question {i+1}, {follow_up_type} follow-up has {correct_count} correct answers, fixing...")
                    for j, option in enumerate(follow_up['options']):
                        option['isCorrect'] = j == 0  # Make first option correct
            
            # Add validated question to list
            validated_questions.append(question)
        
        # If we have no valid questions after filtering, return an error
        if not validated_questions:
            logger.error("No valid questions after validation")
            return jsonify({"error": "Could not generate valid questions"}), 500
        
        # Send the questions back to the client
        return jsonify({"questions": validated_questions})
        
    except Exception as e:
        logger.exception('Error generating questions: %s', e)
        return jsonify({"error": str(e)}), 500

def build_prompt_for_topic(topic, grace_mode=True):
    """Build a prompt for Claude based on topic and grace mode"""
    prompt_base = """Generate 5 quiz questions for the X-Why-Creator quiz game. Each question should have two answer options, with only one being correct. 

For each question, create TWO follow-up questions:
1. A "Why" follow-up question that asks why the correct answer is correct
2. A "Why" follow-up question that asks why the incorrect answer is wrong (this is for Grace Mode when users get the first question wrong)

Each follow-up question must have exactly two possible explanations to choose from, with exactly one being correct and one being incorrect.

Make sure all explanations are educational and help learners understand the subject matter better. The explanations should be substantive and contain real information, not just simple statements.

IMPORTANT: Every question MUST include both follow-up questions with their options, as they are essential for the game mechanics.
"""

    # Add grace mode specific instructions
    if grace_mode:
        prompt_base += """
Grace Mode is ENABLED, which means players will see the "why" question even when they get the initial answer wrong. Make sure the explanations for incorrect answers are especially educational to help learners understand their mistakes.
"""
    else:
        prompt_base += """
Grace Mode is DISABLED, but still provide both types of follow-up questions as they are required for the game's structure.
"""

    # Add topic-specific instructions
    topic_instructions = {
        'math': "Focus on math concepts appropriate for middle school students. Include questions about algebra, geometry, arithmetic, and basic number theory.",
        'science': "Focus on science topics including biology, chemistry, physics, and environmental science. Make the questions educational but accessible.",
        'history': "Focus on important historical events, figures, and developments from around the world, covering different time periods.",
        'geography': "Focus on world geography including countries, capitals, major landforms, oceans, and geographical concepts.",
        'language': "Focus on English grammar, vocabulary, literary devices, and common language rules.",
        'mixed': "Provide a mix of questions across different subjects including math, science, history, geography, and language."
    }
    
    prompt_base += f"\n\n{topic_instructions.get(topic, topic_instructions['mixed'])}"
    
    # Add format instructions
    prompt_base += """

The format should be:
{
  "questions": [
    {
      "question": "Main question text",
      "options": [
        { "text": "Option A", "isCorrect": true },
        { "text": "Option B", "isCorrect": false }
      ],
      "followUp": {
        "correct": {
          "question": "Why is the correct answer correct?",
          "options": [
            { "text": "Correct explanation", "isCorrect": true },
            { "text": "Incorrect explanation", "isCorrect": false }
          ]
        },
        "incorrect": {
          "question": "Why is the incorrect answer wrong?",
          "options": [
            { "text": "Correct explanation", "isCorrect": true },
            { "text": "Incorrect explanation", "isCorrect": false }
          ]
        }
      }
    }
  ]
}

EXTREMELY IMPORTANT: 
1. EVERY question MUST have EXACTLY TWO options with ONE marked as correct (isCorrect: true) and ONE marked as incorrect (isCorrect: false)
2. EVERY question MUST include BOTH follow-up "why" questions (correct and incorrect)
3. EACH follow-up question MUST have EXACTLY TWO explanation options with ONE marked as correct
4. Content must be factually accurate and educational
5. DO NOT omit or skip any part of this structure as it will break the game completely
            
The game mechanics rely on this exact structure - if any part is missing, the entire game experience breaks for the user.

Return ONLY the JSON object - no other text.
"""
    
    return prompt_base

# Enhanced math quiz generation with better prompting and graph handling

# CRITICAL: Enhanced Prompt Generation with Lockout
@app.route('/fix-quiz-graphs/<quiz_id>', methods=['GET'])
def fix_quiz_graphs(quiz_id):
    """Fix graphs for an existing quiz"""
    try:
        quiz = MathQuiz.query.filter_by(id=quiz_id).first()
        if not quiz:
            return jsonify({'error': 'Quiz not found'}), 404
        
        questions = json.loads(quiz.questions_json)
        
        # Fix each question that requires a graph
        fixed_count = 0
        for question in questions:
            if question.get('requires_graph') and not question.get('graph_image_url'):
                # Generate graph URL for this question
                graph_id = f"{quiz_id}-q{question.get('id', 'unknown')}"
                question['graph_image_url'] = f"/api/math-graph/{graph_id}"
                
                # Remove the failed flag
                if 'graph_generation_failed' in question:
                    del question['graph_generation_failed']
                
                fixed_count += 1
        
        # Update the quiz in database
        quiz.questions_json = json.dumps(questions)
        db.session.commit()
        
        return jsonify({
            'message': f'Fixed {fixed_count} graph URLs',
            'quiz_id': quiz_id,
            'questions_fixed': fixed_count
        })
        
    except Exception as e:
        app.logger.error(f"Error fixing quiz graphs: {str(e)}")
        return jsonify({'error': str(e)}), 500


# SOLUTION 2: Create a manual graph URL for testing
class MathQuiz(db.Model):
    __tablename__ = 'math_quizzes'
    
    id = db.Column(db.String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = db.Column(db.String(36), db.ForeignKey('users.id'), nullable=False)
    title = db.Column(db.String(255), nullable=False)
    topic = db.Column(db.String(255), nullable=False)
    grade_level = db.Column(db.String(50), nullable=False)
    time_limit = db.Column(db.Integer, default=30)
    mode = db.Column(db.String(50), default='list')
    questions_json = db.Column(db.Text, nullable=True)
    
    # FIXED: Add the missing graph_types field
    graph_types = db.Column(db.Text, nullable=True)  # Store as JSON string
    
    # Keep math_types for backward compatibility
    math_types = db.Column(db.Text, nullable=True)
    
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    source = db.Column(db.String(50), nullable=True)
    source_id = db.Column(db.String(36), nullable=True)
    
    def __repr__(self):
        return f'<MathQuiz {self.id} - {self.title}>'
    
    def to_dict(self):
        return {
            'id': self.id,
            'user_id': self.user_id,
            'title': self.title,
            'topic': self.topic,
            'grade_level': self.grade_level,
            'time_limit': self.time_limit,
            'mode': self.mode,
            'questions': json.loads(self.questions_json) if self.questions_json else [],
            'graph_types': json.loads(self.graph_types) if self.graph_types else [],
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        }

class MathQuizSubmission(db.Model):
    __tablename__ = 'math_quiz_submissions'
    
    id = db.Column(db.String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    quiz_id = db.Column(db.String(36), nullable=False)
    quiz_owner_id = db.Column(db.String(36), nullable=True)
    student_name = db.Column(db.String(255), nullable=False)
    score = db.Column(db.Float, nullable=False)
    max_score = db.Column(db.Float, nullable=False)
    answers_json = db.Column(db.Text, nullable=True)
    time_taken = db.Column(db.Integer, default=0)
    submitted_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    def __repr__(self):
        return f'<MathQuizSubmission {self.id} - {self.student_name} - {self.score}/{self.max_score}>'
    
    def to_dict(self):
        return {
            'id': self.id,
            'quiz_id': self.quiz_id,
            'student_name': self.student_name,
            'score': self.score,
            'max_score': self.max_score,
            'percentage': round((self.score / self.max_score * 100) if self.max_score > 0 else 0, 1),
            'answers': json.loads(self.answers_json) if self.answers_json else {},
            'time_taken': self.time_taken,
            'submitted_at': self.submitted_at.isoformat() if self.submitted_at else None
        }


# IMPORTANT: If you're using your current models, you'll need to update the foreign key reference
# In your MathQuizSubmission model, change this line:
# quiz_id = db.Column(db.String(255), db.ForeignKey('math_quiz.id'), nullable=False)
# 
# To match your actual table name. If your MathQuiz table is called 'math_quiz' (without __tablename__),
# then keep it as 'math_quiz.id'. If you add __tablename__ = 'math_quizzes', change it to 'math_quizzes.id'

# Serve the Math Quiz Creator HTML page
# Add this to your Flask app.py file to fix the database connection issues

import logging
from sqlalchemy import event
from sqlalchemy.pool import Pool

# Database connection health check and reconnection logic
@event.listens_for(Pool, "connect")
def set_sqlite_pragma(dbapi_connection, connection_record):
    """Set SQLite connection options"""
    if 'sqlite' in str(dbapi_connection):
        cursor = dbapi_connection.cursor()
        cursor.execute("PRAGMA foreign_keys=ON")
        cursor.close()

@event.listens_for(Pool, "checkout")
def receive_checkout(dbapi_connection, connection_record, connection_proxy):
    """Test connection on checkout"""
    try:
        cursor = dbapi_connection.cursor()
        cursor.execute("SELECT 1")
        cursor.close()
    except Exception as e:
        # Connection is stale, invalidate it
        logging.warning(f"Database connection test failed: {e}")
        raise

# Improved database reconnection helper
def get_db_connection():
    """Get a fresh database connection with retry logic"""
    max_retries = 3
    for attempt in range(max_retries):
        try:
            # Test the connection
            db.session.execute(text("SELECT 1"))
            return True
        except Exception as e:
            logging.warning(f"Database connection attempt {attempt + 1} failed: {e}")
            if attempt < max_retries - 1:
                try:
                    db.session.remove()
                    db.engine.dispose()
                except Exception as dispose_error:
                    logging.error(f"Error disposing connection: {dispose_error}")
            else:
                raise e
    return False



    
    # Enable SQL statement logging for debugging (remove in production)
    # app.config['SQLALCHEMY_ECHO'] = True

# Call this function after creating your Flask app but before creating db
# configure_database_connection()

# Serve the Math Quiz HTML page
@app.route('/math-quiz.html')
def serve_math_quiz():
    return send_from_directory('.', 'math-quiz.html')

# Serve the Math Quiz Scores HTML page
@app.route('/math-quiz-scores.html')
def serve_math_quiz_scores():
    return send_from_directory('.', 'math-quiz-scores.html')

# Serve the Math Quiz Performance HTML page  
@app.route('/math-quiz-performance.html')
def serve_math_quiz_performance():
    return send_from_directory('.', 'math-quiz-performance.html')

# Add this route to handle paragraph evaluation for math questions
class GeometryShapeRenderer:
    """Professional geometry shape renderer using matplotlib and plotly"""
    
    def __init__(self):
        self.figure_size = (8, 6)
        self.dpi = 300
        self.colors = {
            'primary': '#10B981',
            'secondary': '#3B82F6', 
            'accent': '#F59E0B',
            'text': '#1F2937',
            'grid': '#E5E7EB'
        }
        
    def create_figure(self, figsize=None, is_3d=False):
        """Create a matplotlib figure with proper styling"""
        if figsize is None:
            figsize = self.figure_size
            
        fig = plt.figure(figsize=figsize, dpi=self.dpi)
        
        if is_3d:
            ax = fig.add_subplot(111, projection='3d')
            ax.grid(True, alpha=0.3)
        else:
            ax = fig.add_subplot(111)
            ax.grid(True, alpha=0.3, color=self.colors['grid'])
            ax.set_aspect('equal')
            
        # Set background color
        fig.patch.set_facecolor('white')
        ax.set_facecolor('white')
        
        return fig, ax
    
    
    
    
    def render_polygon(self, vertices: List[Tuple[float, float]], 
                      n_sides: int, labels: List[str] = None,
                      measurements: Dict = None) -> str:
        """Render regular polygons"""
        fig, ax = self.create_figure()
        
        # Create polygon
        polygon = Polygon(vertices, fill=False, edgecolor=self.colors['primary'], 
                         linewidth=2.5, alpha=0.8)
        ax.add_patch(polygon)
        
        # Fill polygon
        polygon_fill = Polygon(vertices, fill=True, facecolor=self.colors['primary'], 
                              alpha=0.1)
        ax.add_patch(polygon_fill)
        
        # Add vertex labels
        if labels:
            for vertex, label in zip(vertices, labels):
                ax.plot(vertex[0], vertex[1], 'o', color=self.colors['secondary'], 
                       markersize=8, zorder=10)
                
                # Calculate label position
                center_x = sum(v[0] for v in vertices) / len(vertices)
                center_y = sum(v[1] for v in vertices) / len(vertices)
                
                # Position label outside vertex
                direction_x = vertex[0] - center_x
                direction_y = vertex[1] - center_y
                length = np.sqrt(direction_x**2 + direction_y**2)
                
                label_x = vertex[0] + 0.4 * direction_x / length
                label_y = vertex[1] + 0.4 * direction_y / length
                
                ax.text(label_x, label_y, label, fontsize=14, fontweight='bold',
                       ha='center', va='center', color=self.colors['text'])
        
        # Add measurements
        if measurements:
            # Interior angle
            if 'interior_angle' in measurements:
                # Place angle measurement at first vertex
                ax.text(vertices[0][0], vertices[0][1] - 0.8, 
                       f'Interior angle: {measurements["interior_angle"]}Â°', 
                       fontsize=11, fontweight='bold',
                       bbox=dict(boxstyle='round,pad=0.3', 
                               facecolor='white', alpha=0.8),
                       ha='center', va='center', color=self.colors['secondary'])
            
            # Side length
            if 'side_length' in measurements:
                mid_x = (vertices[0][0] + vertices[1][0]) / 2
                mid_y = (vertices[0][1] + vertices[1][1]) / 2
                ax.text(mid_x, mid_y, f'Side: {measurements["side_length"]}', 
                       fontsize=11, fontweight='bold',
                       bbox=dict(boxstyle='round,pad=0.3', 
                               facecolor='white', alpha=0.8),
                       ha='center', va='center', color=self.colors['accent'])
        
        # Set title
        polygon_names = {3: 'Triangle', 4: 'Quadrilateral', 5: 'Pentagon', 
                        6: 'Hexagon', 7: 'Heptagon', 8: 'Octagon'}
        title = polygon_names.get(n_sides, f'{n_sides}-sided Polygon')
        ax.set_title(title, fontsize=16, fontweight='bold', 
                    color=self.colors['text'], pad=20)
        ax.set_xlabel('Units', fontsize=12)
        ax.set_ylabel('Units', fontsize=12)
        
        # Set limits
        x_coords = [v[0] for v in vertices]
        y_coords = [v[1] for v in vertices]
        margin = 1.5
        ax.set_xlim(min(x_coords) - margin, max(x_coords) + margin)
        ax.set_ylim(min(y_coords) - margin, max(y_coords) + margin)
        
        return self._figure_to_base64(fig)
    
    def render_3d_shape(self, shape_type: str, dimensions: Dict,
                       measurements: Dict = None) -> str:
        """Render 3D shapes using matplotlib 3D"""
        fig = plt.figure(figsize=self.figure_size, dpi=self.dpi)
        ax = fig.add_subplot(111, projection='3d')
        
        if shape_type == 'cube':
            return self._render_cube(fig, ax, dimensions, measurements)
        elif shape_type == 'rectangular_prism':
            return self._render_rectangular_prism(fig, ax, dimensions, measurements)
        elif shape_type == 'cylinder':
            return self._render_cylinder(fig, ax, dimensions, measurements)
        elif shape_type == 'sphere':
            return self._render_sphere(fig, ax, dimensions, measurements)
        elif shape_type == 'cone':
            return self._render_cone(fig, ax, dimensions, measurements)
        elif shape_type == 'pyramid':
            return self._render_pyramid(fig, ax, dimensions, measurements)
        
        return self._figure_to_base64(fig)
    
    

    def _render_cylinder(self, fig, ax, dimensions: Dict, measurements: Dict = None) -> str:
        """Render a cylinder"""
        radius = dimensions.get('radius', 1)
        height = dimensions.get('height', 2)
        
        # Create cylinder
        theta = np.linspace(0, 2*np.pi, 30)
        z_bottom = np.zeros_like(theta)
        z_top = np.full_like(theta, height)
        x = radius * np.cos(theta)
        y = radius * np.sin(theta)
        
        # Bottom and top circles
        ax.plot(x, y, z_bottom, color=self.colors['primary'], linewidth=2)
        ax.plot(x, y, z_top, color=self.colors['primary'], linewidth=2)
        
        # Vertical lines
        for i in range(0, len(theta), 5):
            ax.plot([x[i], x[i]], [y[i], y[i]], [0, height], 
                   color=self.colors['primary'], linewidth=1, alpha=0.6)
        
        # Fill top and bottom
        ax.plot_trisurf(x, y, z_bottom, alpha=0.3, color=self.colors['primary'])
        ax.plot_trisurf(x, y, z_top, alpha=0.3, color=self.colors['primary'])
        
        # Add measurements
        if measurements:
            # Radius
            ax.plot([0, radius], [0, 0], [0, 0], color=self.colors['secondary'], 
                   linewidth=2, linestyle='--')
            ax.text(radius/2, 0, -0.2, f'r = {radius}', 
                   fontsize=11, fontweight='bold',
                   ha='center', va='center', color=self.colors['accent'])
            
            # Height
            ax.plot([radius + 0.3, radius + 0.3], [0, 0], [0, height], 
                   color=self.colors['secondary'], linewidth=2, linestyle='--')
            ax.text(radius + 0.5, 0, height/2, f'h = {height}', 
                   fontsize=11, fontweight='bold',
                   ha='center', va='center', color=self.colors['accent'])
            
            # Volume and surface area
            if 'volume' in measurements:
                ax.text(0, 0, height/2, f'V = {measurements["volume"]}', 
                       fontsize=12, fontweight='bold',
                       bbox=dict(boxstyle='round,pad=0.3', 
                               facecolor='white', alpha=0.8))
        
        # Set labels and title
        ax.set_xlabel('X', fontsize=12)
        ax.set_ylabel('Y', fontsize=12)
        ax.set_zlabel('Z', fontsize=12)
        ax.set_title('Cylinder', fontsize=16, fontweight='bold', pad=20)
        
        # Set limits
        margin = max(radius, height) * 0.2
        ax.set_xlim(-radius - margin, radius + margin)
        ax.set_ylim(-radius - margin, radius + margin)
        ax.set_zlim(-margin, height + margin)
        
        return self._figure_to_base64(fig)
    
    def render_angle(self, vertex: Tuple[float, float], 
                    angle_degrees: float, 
                    arm_length: float = 2,
                    measurements: Dict = None) -> str:
        """Render an angle with proper labeling"""
        fig, ax = self.create_figure(figsize=(6, 6))
        
        # Convert angle to radians
        angle_rad = np.radians(angle_degrees)
        
        # Calculate arm endpoints
        arm1_end = (vertex[0] + arm_length, vertex[1])
        arm2_end = (vertex[0] + arm_length * np.cos(angle_rad), 
                   vertex[1] + arm_length * np.sin(angle_rad))
        
        # Draw arms
        ax.plot([vertex[0], arm1_end[0]], [vertex[1], arm1_end[1]], 
               color=self.colors['primary'], linewidth=3)
        ax.plot([vertex[0], arm2_end[0]], [vertex[1], arm2_end[1]], 
               color=self.colors['primary'], linewidth=3)
        
        # Draw angle arc
        arc_radius = arm_length * 0.3
        arc_angles = np.linspace(0, angle_rad, 50)
        arc_x = vertex[0] + arc_radius * np.cos(arc_angles)
        arc_y = vertex[1] + arc_radius * np.sin(arc_angles)
        ax.plot(arc_x, arc_y, color=self.colors['secondary'], linewidth=2.5)
        
        # Fill angle sector
        theta = np.linspace(0, angle_rad, 50)
        x_fill = np.concatenate([[vertex[0]], vertex[0] + arc_radius * np.cos(theta), [vertex[0]]])
        y_fill = np.concatenate([[vertex[1]], vertex[1] + arc_radius * np.sin(theta), [vertex[1]]])
        ax.fill(x_fill, y_fill, color=self.colors['primary'], alpha=0.2)
        
        # Add vertex point
        ax.plot(vertex[0], vertex[1], 'o', color=self.colors['secondary'], 
               markersize=10, zorder=10)
        
        # Add angle measurement
        label_radius = arc_radius * 1.5
        label_angle = angle_rad / 2
        label_x = vertex[0] + label_radius * np.cos(label_angle)
        label_y = vertex[1] + label_radius * np.sin(label_angle)
        
        ax.text(label_x, label_y, f'{angle_degrees}Â°', 
               fontsize=14, fontweight='bold',
               bbox=dict(boxstyle='round,pad=0.3', facecolor='white', alpha=0.8),
               ha='center', va='center', color=self.colors['accent'])
        
        # Add angle type label
        if measurements and 'type' in measurements:
            ax.text(vertex[0], vertex[1] - 1, measurements['type'], 
                   fontsize=12, fontweight='bold',
                   ha='center', va='center', color=self.colors['text'])
        
        # Set title
        ax.set_title('Angle Measurement', fontsize=16, fontweight='bold', 
                    color=self.colors['text'], pad=20)
        ax.set_xlabel('Units', fontsize=12)
        ax.set_ylabel('Units', fontsize=12)
        
        # Set limits
        margin = arm_length * 0.3
        ax.set_xlim(vertex[0] - margin, vertex[0] + arm_length + margin)
        ax.set_ylim(vertex[1] - margin, vertex[1] + arm_length + margin)
        
        return self._figure_to_base64(fig)
    
    
    def render_coordinate_system(self, points: List[Dict], 
                               lines: List[Dict] = None,
                               grid_size: int = 10) -> str:
        """Render coordinate geometry with points and lines"""
        fig, ax = self.create_figure(figsize=(8, 8))
        
        # Set up coordinate system
        ax.axhline(y=0, color='k', linewidth=0.8, alpha=0.3)
        ax.axvline(x=0, color='k', linewidth=0.8, alpha=0.3)
        
        # Add grid
        for i in range(-grid_size, grid_size + 1):
            ax.axhline(y=i, color=self.colors['grid'], linewidth=0.5, alpha=0.5)
            ax.axvline(x=i, color=self.colors['grid'], linewidth=0.5, alpha=0.5)
        
        # Plot points
        for point in points:
            x, y = point['coordinates']
            label = point.get('label', '')
            color = point.get('color', self.colors['secondary'])
            
            ax.plot(x, y, 'o', color=color, markersize=8, zorder=10)
            
            # Add label
            if label:
                ax.text(x + 0.2, y + 0.2, label, fontsize=12, fontweight='bold',
                       ha='left', va='bottom', color=self.colors['text'])
            
            # Add coordinates
            ax.text(x + 0.2, y - 0.3, f'({x}, {y})', fontsize=10,
                   ha='left', va='top', color=self.colors['text'])
        
        # Draw lines
        if lines:
            for line in lines:
                x_coords = [p['coordinates'][0] for p in line['points']]
                y_coords = [p['coordinates'][1] for p in line['points']]
                color = line.get('color', self.colors['primary'])
                
                ax.plot(x_coords, y_coords, color=color, linewidth=2.5, alpha=0.8)
                
                # Add line equation if provided
                if 'equation' in line:
                    mid_x = sum(x_coords) / len(x_coords)
                    mid_y = sum(y_coords) / len(y_coords)
                    ax.text(mid_x, mid_y + 0.5, line['equation'], 
                           fontsize=11, fontweight='bold',
                           bbox=dict(boxstyle='round,pad=0.3', facecolor='white', alpha=0.8),
                           ha='center', va='center', color=self.colors['accent'])
        
        # Set title and labels
        ax.set_title('Coordinate Geometry', fontsize=16, fontweight='bold', 
                    color=self.colors['text'], pad=20)
        ax.set_xlabel('X', fontsize=12)
        ax.set_ylabel('Y', fontsize=12)
        
        # Set limits
        ax.set_xlim(-grid_size, grid_size)
        ax.set_ylim(-grid_size, grid_size)
        
        return self._figure_to_base64(fig)
    
    def render_transformation(self, original_shape: Dict, 
                             transformed_shape: Dict,
                             transformation_type: str) -> str:
        """Render geometric transformations"""
        fig, ax = self.create_figure(figsize=(10, 8))
        
        # Set up coordinate system
        ax.axhline(y=0, color='k', linewidth=0.8, alpha=0.3)
        ax.axvline(x=0, color='k', linewidth=0.8, alpha=0.3)
        
        # Add grid
        for i in range(-10, 11):
            ax.axhline(y=i, color=self.colors['grid'], linewidth=0.5, alpha=0.3)
            ax.axvline(x=i, color=self.colors['grid'], linewidth=0.5, alpha=0.3)
        
        # Draw original shape
        orig_vertices = original_shape['vertices']
        orig_polygon = Polygon(orig_vertices, fill=True, 
                              facecolor=self.colors['primary'], alpha=0.3,
                              edgecolor=self.colors['primary'], linewidth=2)
        ax.add_patch(orig_polygon)
        
        # Label original shape
        ax.text(sum(v[0] for v in orig_vertices) / len(orig_vertices),
               sum(v[1] for v in orig_vertices) / len(orig_vertices),
               'Original', fontsize=12, fontweight='bold',
               ha='center', va='center', color=self.colors['text'])
        
        # Draw transformed shape
        trans_vertices = transformed_shape['vertices']
        trans_polygon = Polygon(trans_vertices, fill=True, 
                               facecolor=self.colors['secondary'], alpha=0.3,
                               edgecolor=self.colors['secondary'], linewidth=2)
        ax.add_patch(trans_polygon)
        
        # Label transformed shape
        ax.text(sum(v[0] for v in trans_vertices) / len(trans_vertices),
               sum(v[1] for v in trans_vertices) / len(trans_vertices),
               'Transformed', fontsize=12, fontweight='bold',
               ha='center', va='center', color=self.colors['text'])
        
        # Add transformation details
        if transformation_type == 'rotation':
            # Draw rotation center and angle arc
            center = transformed_shape.get('center', (0, 0))
            angle = transformed_shape.get('angle', 0)
            
            ax.plot(center[0], center[1], 'o', color='red', markersize=8)
            ax.text(center[0] + 0.5, center[1] + 0.5, f'Center of rotation\n({center[0]}, {center[1]})', 
                   fontsize=10, ha='left', va='bottom', color='red')
            
            # Draw angle arc
            if angle != 0:
                arc_radius = 1.5
                arc_angles = np.linspace(0, np.radians(angle), 30)
                arc_x = center[0] + arc_radius * np.cos(arc_angles)
                arc_y = center[1] + arc_radius * np.sin(arc_angles)
                ax.plot(arc_x, arc_y, color='red', linewidth=2)
                ax.text(center[0] + arc_radius * 1.2, center[1], f'{angle}Â°', 
                       fontsize=11, fontweight='bold', color='red')
        
        elif transformation_type == 'reflection':
            # Draw line of reflection
            line = transformed_shape.get('reflection_line')
            if line:
                x_vals = np.linspace(-10, 10, 100)
                y_vals = line['slope'] * x_vals + line['intercept']
                ax.plot(x_vals, y_vals, color='red', linewidth=2, linestyle='--', alpha=0.7)
                ax.text(0, line['intercept'], f'Line of reflection\ny = {line["slope"]}x + {line["intercept"]}', 
                       fontsize=10, ha='center', va='bottom', color='red')
        
        elif transformation_type == 'translation':
            # Draw translation vector
            vector = transformed_shape.get('translation_vector', (0, 0))
            orig_center = (sum(v[0] for v in orig_vertices) / len(orig_vertices),
                          sum(v[1] for v in orig_vertices) / len(orig_vertices))
            trans_center = (sum(v[0] for v in trans_vertices) / len(trans_vertices),
                           sum(v[1] for v in trans_vertices) / len(trans_vertices))
            
            ax.annotate('', xy=trans_center, xytext=orig_center,
                       arrowprops=dict(arrowstyle='->', color='red', lw=2))
            ax.text((orig_center[0] + trans_center[0]) / 2,
                   (orig_center[1] + trans_center[1]) / 2 + 0.5,
                   f'Translation: ({vector[0]}, {vector[1]})', 
                   fontsize=11, fontweight='bold', ha='center', va='bottom', color='red')
        
        # Set title and labels
        ax.set_title(f'{transformation_type.capitalize()} Transformation', 
                    fontsize=16, fontweight='bold', color=self.colors['text'], pad=20)
        ax.set_xlabel('X', fontsize=12)
        ax.set_ylabel('Y', fontsize=12)
        
        # Set limits based on shapes
        all_x = [v[0] for v in orig_vertices + trans_vertices]
        all_y = [v[1] for v in orig_vertices + trans_vertices]
        margin = 2
        ax.set_xlim(min(all_x) - margin, max(all_x) + margin)
        ax.set_ylim(min(all_y) - margin, max(all_y) + margin)
        
        return self._figure_to_base64(fig)
    
    

"""
GEOMETRY STRICT LOCKOUT SYSTEM - BACKEND
NO keyword guessing, ONLY user selection - Based on proven graph lockout system
"""

import json
import logging
import uuid
from typing import Dict, List, Set, Optional
from flask import request, jsonify

class GeometryLockoutManager:
    """Strict geometry lockout - NO keyword guessing, ONLY user selection"""
    
    def __init__(self):
        self.selectedGeometryTypes = set()
        self.strictLockoutMode = True
        
        # Valid geometry types (no complex patterns needed)
        self.valid_geometry_types = {
            'triangles', 'quadrilaterals', 'circles', 'polygons', 
            '3d_shapes', 'angles', 'similarity', 'symmetry', 
            'coordinate_geometry', 'transformations', 'volume_surface'
        }
        
        self.geometryDataTemplates = {
            'triangles': {
                'generateData': self._generate_triangle_data,
                'validate': lambda data: 'sides' in data or 'angles' in data
            },
            'quadrilaterals': {
                'generateData': self._generate_quadrilateral_data,
                'validate': lambda data: 'length' in data or 'width' in data
            },
            'circles': {
                'generateData': self._generate_circle_data,
                'validate': lambda data: 'radius' in data or 'diameter' in data
            },
            '3d_shapes': {
                'generateData': self._generate_3d_data,
                'validate': lambda data: 'shape_type' in data
            },
            'polygons': {
                'generateData': self._generate_polygon_data,
                'validate': lambda data: 'sides' in data
            },
            'angles': {
                'generateData': self._generate_angle_data,
                'validate': lambda data: 'angle_type' in data
            },
            'volume_surface': {
                'generateData': self._generate_volume_data,
                'validate': lambda data: 'volume' in data or 'surface_area' in data
            }
        }
    
    def setSelectedGeometryTypes(self, selectedTypes):
        """CRITICAL: Set ONLY user-selected types"""
        self.selectedGeometryTypes = set(selectedTypes)
        logging.info(f"ðŸ”’ GEOMETRY LOCKOUT: Only {selectedTypes} allowed")
        
        if len(selectedTypes) == 0:
            logging.info("ðŸš« NO GEOMETRY TYPES SELECTED: All shapes blocked")
    
    def isGeometryTypeAllowed(self, geometryType):
        """CRITICAL: Check if type is in user selection"""
        isAllowed = geometryType in self.selectedGeometryTypes
        if not isAllowed:
            logging.info(f"ðŸ”’ GEOMETRY LOCKOUT: {geometryType} NOT selected, blocking")
        return isAllowed
    
    def assignGeometryType(self, selectedTypes, questionIndex):
        """CRITICAL: Round-robin assignment from selected types ONLY"""
        if not selectedTypes:
            logging.info(f"ðŸš« NO GEOMETRY: No types selected for Q{questionIndex + 1}")
            return None
        
        # Use round-robin for even distribution
        geometryType = selectedTypes[questionIndex % len(selectedTypes)]
        logging.info(f"âœ… ASSIGNED: Q{questionIndex + 1} â†’ {geometryType} (round-robin)")
        return geometryType
    
    def processQuestionsWithLockout(self, questions, selectedGeometryTypes):
        """CRITICAL: Process questions with strict geometry lockout"""
        self.setSelectedGeometryTypes(selectedGeometryTypes)
        
        processedQuestions = []
        
        for i, question in enumerate(questions):
            question = dict(question)
            
            # LOCKOUT RULE 1: Only assign geometry if types are selected
            if len(self.selectedGeometryTypes) == 0:
                # No geometry types selected = NO GEOMETRY AT ALL
                question['requires_geometry'] = False
                question.pop('geometry_type', None)
                question.pop('geometry_data', None)
                question.pop('geometry_description', None)
                question.pop('geometry_image_url', None)
                logging.info(f"ðŸš« Q{i+1}: NO GEOMETRY - None selected")
            else:
                # LOCKOUT RULE 2: Assign only from selected types
                assignedGeometryType = self.assignGeometryType(selectedGeometryTypes, i)
                
                if assignedGeometryType and self.isGeometryTypeAllowed(assignedGeometryType):
                    question['requires_geometry'] = True
                    question['geometry_type'] = assignedGeometryType
                    question['geometry_data'] = self.generateCorrectGeometryData(assignedGeometryType, question.get('text', ''))
                    question['geometry_description'] = self.getGeometryDescription(assignedGeometryType)
                    question['geometry_image_url'] = f"/api/geometry-shape/{question.get('id', f'q{i}')}"
                    logging.info(f"âœ… Q{i+1}: LOCKED TO {assignedGeometryType}")
                else:
                    # Safety check
                    question['requires_geometry'] = False
                    question.pop('geometry_type', None)
                    question.pop('geometry_data', None)
                    question.pop('geometry_description', None)
                    question.pop('geometry_image_url', None)
                    logging.info(f"ðŸš« Q{i+1}: BLOCKED - Type not allowed")
            
            processedQuestions.append(question)
        
        return processedQuestions
    
    def generateCorrectGeometryData(self, geometryType, questionText):
        """Generate geometry data for the specified type"""
        # LOCKOUT CHECK: Ensure geometry type is allowed
        if not self.isGeometryTypeAllowed(geometryType):
            logging.error(f"ðŸ”’ LOCKOUT VIOLATION: Attempted to generate data for blocked type: {geometryType}")
            return None
        
        generator = self.geometryDataTemplates.get(geometryType)
        if not generator:
            logging.error(f"âŒ No data generator for geometry type: {geometryType}")
            return None
        
        try:
            data = generator['generateData'](questionText)
            
            if not generator['validate'](data):
                logging.error(f"âŒ Generated data failed validation for {geometryType}")
                return None
            
            logging.info(f"âœ… Generated valid {geometryType} data")
            return data
        except Exception as e:
            logging.error(f"Error generating {geometryType} data: {str(e)}")
            return None
    
    def validate_selected_types(self, selected_types):
        """Validate selected geometry types"""
        if not selected_types:
            return {"valid": True, "message": "No geometry types selected - no shapes will be generated"}
        
        selected_set = set(selected_types)
        invalid_types = selected_set - self.valid_geometry_types
        
        if invalid_types:
            return {
                "valid": False, 
                "message": f"Invalid geometry types: {list(invalid_types)}",
                "valid_types": list(self.valid_geometry_types)
            }
        
        return {"valid": True, "message": f"All selected types are valid: {selected_types}"}
    
    # Specific data generators for each geometry type
    def _generate_triangle_data(self, questionText):
        return {
            'shape_type': 'triangle',
            'sides': [5, 12, 13],  # Right triangle
            'angles': [37, 53, 90],
            'type': 'right_triangle'
        }
    
    def _generate_quadrilateral_data(self, questionText):
        import re
        text_lower = questionText.lower() if questionText else ''

        # Default values
        length = 8
        width = 6
        side = 5
        shape_type = 'rectangle'

        # Detect shape type
        if 'square' in text_lower:
            shape_type = 'square'
            # Extract side for square
            side_pattern = r'(?:side(?:s)?|side length)\s+(?:of\s+)?(\d+(?:\.\d+)?)'
            side_match = re.search(side_pattern, text_lower)
            if side_match:
                side = float(side_match.group(1))
            else:
                numbers = re.findall(r'\d+(?:\.\d+)?', questionText)
                if numbers:
                    side = float(numbers[0])
            return {
                'shape_type': 'square',
                'side': side,
                'area': side * side,
                'perimeter': 4 * side
            }
        else:
            # Rectangle - extract length and width
            length_pattern = r'length\s+(?:of\s+)?(\d+(?:\.\d+)?)'
            width_pattern = r'width\s+(?:of\s+)?(\d+(?:\.\d+)?)'

            length_match = re.search(length_pattern, text_lower)
            width_match = re.search(width_pattern, text_lower)

            if length_match:
                length = float(length_match.group(1))
            if width_match:
                width = float(width_match.group(1))

            # Fallback to dimension pattern "X by Y" or "X x Y"
            if not length_match and not width_match:
                dimension_pattern = r'(\d+(?:\.\d+)?)\s*(?:cm|m|mm|inches?|in|ft|feet)?\s*(?:by|x|Ã—)\s*(\d+(?:\.\d+)?)'
                dim_match = re.search(dimension_pattern, text_lower)
                if dim_match:
                    length = float(dim_match.group(1))
                    width = float(dim_match.group(2))
                else:
                    # Use first two numbers as fallback
                    numbers = re.findall(r'\d+(?:\.\d+)?', questionText)
                    if len(numbers) >= 2:
                        length = float(numbers[0])
                        width = float(numbers[1])

            return {
                'shape_type': 'rectangle',
                'length': length,
                'width': width,
                'area': length * width,
                'perimeter': 2 * (length + width)
            }
    
    def _generate_circle_data(self, questionText):
        return {
            'shape_type': 'circle',
            'radius': 7,
            'diameter': 14,
            'circumference': 43.98,
            'area': 153.94
        }
    
    def _generate_3d_data(self, questionText):
        import re
        import math
        text_lower = questionText.lower() if questionText else ''

        # Detect 3D shape type
        if 'cube' in text_lower:
            shape_type = 'cube'
        elif 'sphere' in text_lower:
            shape_type = 'sphere'
        elif 'cylinder' in text_lower:
            shape_type = 'cylinder'
        elif 'cone' in text_lower:
            shape_type = 'cone'
        else:
            shape_type = 'cube'  # Default

        # Extract numbers from question
        numbers = re.findall(r'\d+(?:\.\d+)?', questionText)
        numbers = [float(n) for n in numbers]

        if shape_type == 'cube':
            # Extract side/edge length
            side = 6  # Default
            side_patterns = [
                r'(?:side|edge)\s+length\s+(?:of\s+)?(\d+(?:\.\d+)?)',
                r'sides?\s+(?:of\s+)?(\d+(?:\.\d+)?)'
            ]
            for pattern in side_patterns:
                match = re.search(pattern, text_lower)
                if match:
                    side = float(match.group(1))
                    break
            if side == 6 and numbers:
                side = numbers[0]

            return {
                'shape_type': 'cube',
                'side': side,
                'edge_length': side,
                'volume': round(side ** 3, 2),
                'surface_area': round(6 * side * side, 2)
            }

        elif shape_type == 'sphere':
            radius = 5  # Default
            if 'radius' in text_lower:
                match = re.search(r'radius\s+(?:of\s+)?(\d+(?:\.\d+)?)', text_lower)
                if match:
                    radius = float(match.group(1))
            elif 'diameter' in text_lower:
                match = re.search(r'diameter\s+(?:of\s+)?(\d+(?:\.\d+)?)', text_lower)
                if match:
                    radius = float(match.group(1)) / 2
            elif numbers:
                radius = numbers[0]

            return {
                'shape_type': 'sphere',
                'radius': radius,
                'diameter': radius * 2,
                'volume': round((4/3) * math.pi * radius ** 3, 2),
                'surface_area': round(4 * math.pi * radius ** 2, 2)
            }

        elif shape_type == 'cylinder':
            radius = 5
            height = 10
            if len(numbers) >= 2:
                radius = numbers[0]
                height = numbers[1]
            elif len(numbers) == 1:
                radius = numbers[0]

            return {
                'shape_type': 'cylinder',
                'radius': radius,
                'height': height,
                'volume': round(math.pi * radius ** 2 * height, 2),
                'surface_area': round(2 * math.pi * radius * (radius + height), 2)
            }

        elif shape_type == 'cone':
            radius = 5
            height = 10
            if len(numbers) >= 2:
                radius = numbers[0]
                height = numbers[1]
            elif len(numbers) == 1:
                radius = numbers[0]

            slant_height = math.sqrt(radius ** 2 + height ** 2)
            return {
                'shape_type': 'cone',
                'radius': radius,
                'height': height,
                'slant_height': round(slant_height, 2),
                'volume': round((1/3) * math.pi * radius ** 2 * height, 2),
                'surface_area': round(math.pi * radius * (radius + slant_height), 2)
            }

        # Default fallback
        return {
            'shape_type': 'cube',
            'side': 6,
            'edge_length': 6,
            'volume': 216,
            'surface_area': 216
        }
    
    def _generate_polygon_data(self, questionText):
        import re
        text_lower = questionText.lower() if questionText else ''

        # Map polygon names to number of sides
        polygon_map = {
            'triangle': (3, 'triangle'),
            'square': (4, 'square'),
            'pentagon': (5, 'pentagon'),
            'hexagon': (6, 'hexagon'),
            'heptagon': (7, 'heptagon'),
            'octagon': (8, 'octagon'),
            'nonagon': (9, 'nonagon'),
            'decagon': (10, 'decagon'),
            'dodecagon': (12, 'dodecagon')
        }

        # Detect polygon type
        sides = 6  # Default to hexagon
        shape_type = 'hexagon'
        for name, (num_sides, stype) in polygon_map.items():
            if name in text_lower:
                sides = num_sides
                shape_type = stype
                break

        # Check for "X-sided polygon" pattern
        sided_match = re.search(r'(\d+)[- ]sided', text_lower)
        if sided_match:
            sides = int(sided_match.group(1))
            shape_type = 'polygon'

        # Extract side length
        side_length = 5  # Default
        side_patterns = [
            r'side\s+length\s+(?:of\s+)?(\d+(?:\.\d+)?)',
            r'sides?\s+(?:of\s+)?(\d+(?:\.\d+)?)\s*(?:cm|m|mm|inches?|in|ft|feet)',
            r'each\s+side\s+(?:is\s+)?(\d+(?:\.\d+)?)'
        ]
        for pattern in side_patterns:
            match = re.search(pattern, text_lower)
            if match:
                side_length = float(match.group(1))
                break

        # Fallback: use first number found
        if side_length == 5:
            numbers = re.findall(r'\d+(?:\.\d+)?', questionText)
            if numbers:
                side_length = float(numbers[0])

        # Calculate interior angle: (n-2) * 180 / n
        interior_angle = ((sides - 2) * 180) / sides

        return {
            'shape_type': shape_type,
            'sides': sides,
            'num_sides': sides,
            'interior_angle': round(interior_angle, 2),
            'side_length': side_length,
            'side': side_length
        }
    
    def _generate_angle_data(self, questionText):
        return {
            'angle_type': 'complementary',
            'angle1': 35,
            'angle2': 55,
            'total': 90
        }
    
    def _generate_volume_data(self, questionText):
        return {
            'shape_type': 'cylinder',
            'radius': 4,
            'height': 10,
            'volume': 502.65,
            'surface_area': 351.86
        }
    
    def getGeometryDescription(self, geometryType):
        """Get description for geometry type"""
        descriptions = {
            'triangles': 'Triangle geometry and properties',
            'quadrilaterals': 'Quadrilateral shapes and calculations',
            'circles': 'Circle properties and measurements',
            '3d_shapes': '3D shapes and volume calculations',
            'angles': 'Angle measurements and relationships',
            'polygons': 'Polygon properties and calculations',
            'similarity': 'Similar shapes and proportions',
            'symmetry': 'Symmetry and transformations',
            'coordinate_geometry': 'Coordinate plane and points',
            'transformations': 'Geometric transformations',
            'volume_surface': 'Volume and surface area calculations'
        }
        return descriptions.get(geometryType, f'{geometryType} geometry')


def generate_geometry_prompt_with_lockout(data, selected_geometry_types):
    """Generate geometry prompt with strict lockout - NO KEYWORD ANALYSIS"""
    
    topic = data.get('topic', 'geometry')
    grade_level = data.get('grade_level', 'high')
    numQuestions = int(data.get('numQuestions', 5))
    
    prompt = f"""Create a geometry quiz about {topic} for {grade_level} students with {numQuestions} questions.

CRITICAL GEOMETRY LOCKOUT RULES:
"""
    
    if not selected_geometry_types:
        prompt += """
âš ï¸  NO GEOMETRY TYPES SELECTED - COMPLETE LOCKOUT ACTIVE
- Do NOT include ANY geometric shapes in ANY questions
- Set "requires_geometry": false for ALL questions
- Focus on text-based mathematical questions only
- Do NOT include geometry_type, geometry_data, or geometry_description fields
"""
    else:
        prompt += f"""
ðŸ”’ STRICT GEOMETRY LOCKOUT ACTIVE - ONLY THESE TYPES ALLOWED:
{', '.join(selected_geometry_types)}

- ONLY use the geometry types listed above
- Do NOT use any other geometry types
- Questions requiring shapes MUST use ONLY the allowed types
- Distribute geometry types evenly among questions using round-robin
- If no allowed geometry type fits a question, make it text-only (requires_geometry: false)

ALLOWED GEOMETRY TYPE SPECIFICATIONS:
"""
        
        # Add specific examples for each allowed type
        geometry_examples = {
            'triangles': {
                'use_for': 'triangle properties, area, perimeter, angles, Pythagorean theorem',
                'example': 'A right triangle has legs of 5 cm and 12 cm. What is the length of the hypotenuse?',
                'data_format': '{"shape_type": "triangle", "sides": [5, 12, 13], "angles": [37, 53, 90]}'
            },
            'quadrilaterals': {
                'use_for': 'rectangles, squares, parallelograms, area and perimeter',
                'example': 'A rectangle has length 8 cm and width 6 cm. What is its area?',
                'data_format': '{"shape_type": "rectangle", "length": 8, "width": 6}'
            },
            'circles': {
                'use_for': 'circle area, circumference, radius, diameter calculations',
                'example': 'A circle has a radius of 7 cm. What is its circumference?',
                'data_format': '{"shape_type": "circle", "radius": 7, "diameter": 14}'
            },
            '3d_shapes': {
                'use_for': 'volume, surface area of cubes, spheres, cylinders, cones',
                'example': 'A cube has an edge length of 6 cm. What is its volume?',
                'data_format': '{"shape_type": "cube", "edge_length": 6, "volume": 216}'
            },
            'polygons': {
                'use_for': 'polygon properties, interior angles, regular polygons',
                'example': 'What is the interior angle of a regular hexagon?',
                'data_format': '{"shape_type": "hexagon", "sides": 6, "interior_angle": 120}'
            },
            'angles': {
                'use_for': 'angle measurements, complementary, supplementary angles',
                'example': 'Two angles are complementary. If one angle is 35Â°, what is the other?',
                'data_format': '{"angle_type": "complementary", "angle1": 35, "angle2": 55}'
            },
            'volume_surface': {
                'use_for': 'volume and surface area calculations for 3D shapes',
                'example': 'A cylinder has radius 4 cm and height 10 cm. What is its volume?',
                'data_format': '{"shape_type": "cylinder", "radius": 4, "height": 10, "volume": 502.65}'
            }
        }
        
        for geometry_type in selected_geometry_types:
            if geometry_type in geometry_examples:
                example = geometry_examples[geometry_type]
                prompt += f"""
âœ… {geometry_type.upper()} (ALLOWED):
  - Use for: {example['use_for']}
  - Example: "{example['example']}"
  - Data format: {example['data_format']}
"""
    
    prompt += """
FORMAT YOUR RESPONSE AS A JSON OBJECT:

{
  "questions": [
    {
      "id": "1",
      "text": "Your geometry question here (must be specific and mathematical)",
      "type": "multiple_choice",
      "options": [
        {"text": "Option A with actual value", "isCorrect": true},
        {"text": "Option B with actual value", "isCorrect": false},
        {"text": "Option C with actual value", "isCorrect": false},
        {"text": "Option D with actual value", "isCorrect": false}
      ],"""
    
    if selected_geometry_types:
        prompt += """
      "requires_geometry": true,
      "geometry_type": "selected_from_allowed_types_only",
      "geometry_description": "Description matching the geometry type",
      "geometry_data": {
        // Appropriate data structure for the selected geometry type
      }"""
    else:
        prompt += """
      "requires_geometry": false"""
    
    prompt += """
    }
  ]
}

CRITICAL SUCCESS CRITERIA:
1. Return ONLY valid JSON
2. Each question ID must be unique
3. If geometry is allowed, question text MUST match the geometry type used
4. Use ONLY the geometry types that were selected by the user
5. Distribute selected geometry types evenly using round-robin assignment
6. Geometry data MUST be appropriate and realistic
7. Mathematical accuracy in all calculations
8. No placeholder or generic questions
9. STRICT ADHERENCE to geometry type lockout rules
10. NO keyword-based type guessing - ONLY use selected types
"""
    
    return prompt


def detect_shape_type_from_question(question_text):
    """Enhanced shape type detection with priority-based validation

    PRIORITY ORDER:
    1. Explicit shape types (triangles, circles, etc.) - HIGHEST PRIORITY
    2. Transformation keywords - ONLY if no shape detected

    This prevents "A triangle after dilation..." from being classified as 'transformation'
    instead of 'triangle'.
    """
    if not question_text:
        return 'unknown'

    question_lower = question_text.lower()

    # ====== PRIORITY 1: EXPLICIT SHAPE TYPES ======
    # Check for specific shapes FIRST before transformation keywords

    # SECTORS (check before circles!)
    if 'sector' in question_lower or ('central angle' in question_lower and 'circle' in question_lower):
        return 'sector'

    # 3D SHAPES
    if 'cylinder' in question_lower:
        return 'cylinder'
    if 'cone' in question_lower:
        return 'cone'
    if 'sphere' in question_lower:
        return 'sphere'
    if 'cube' in question_lower:
        return 'cube'
    if 'triangular prism' in question_lower or 'prism' in question_lower:
        return 'triangular_prism'
    if 'rectangular prism' in question_lower or 'cuboid' in question_lower:
        return 'rectangular_prism'

    # 2D SHAPES - TRIANGLES (with specific type detection)
    # NOTE: Only check for 'triangle', NOT 'triangular' to avoid matching "triangular prism"
    if 'triangle' in question_lower and 'prism' not in question_lower:
        if 'right' in question_lower or 'right-angle' in question_lower:
            return 'right_triangle'
        elif 'equilateral' in question_lower:
            return 'equilateral_triangle'
        elif 'isosceles' in question_lower:
            return 'isosceles_triangle'
        elif 'scalene' in question_lower:
            return 'scalene_triangle'
        elif 'obtuse' in question_lower:
            return 'obtuse_triangle'
        elif 'acute' in question_lower:
            return 'acute_triangle'
        else:
            return 'triangle'

    # 2D SHAPES - OTHERS
    if 'circle' in question_lower and 'sector' not in question_lower:
        return 'circle'
    if 'rectangle' in question_lower:
        return 'rectangle'
    if 'square' in question_lower:
        return 'square'
    if 'trapezium' in question_lower or 'trapezoid' in question_lower:
        return 'trapezium'
    if 'pentagon' in question_lower:
        return 'pentagon'
    if 'hexagon' in question_lower:
        return 'hexagon'
    if 'polygon' in question_lower:
        return 'polygon'

    # LINES AND ANGLES
    if 'parallel' in question_lower:
        return 'parallel_lines'
    if 'complementary' in question_lower:
        return 'complementary_angles'
    if 'supplementary' in question_lower:
        return 'supplementary_angles'

    # ====== PRIORITY 2: TRANSFORMATIONS ======
    # ONLY check for transformations if NO explicit shape was detected above
    # This ensures "triangle after dilation" â†’ 'triangle', NOT 'transformation'
    if any(word in question_lower for word in ['rotation', 'reflection', 'translation', 'dilation', 'transformation', 'transformed', 'rotated', 'reflected', 'translated']):
        logging.warning(f"âš ï¸ Detected transformation keywords without explicit shape - classifying as 'transformation'")
        return 'transformation'

    return 'unknown'

# ENHANCED SHAPE RENDERING WITH LOCKOUT VALIDATION
@app.route('/api/geometry-shape/<question_id>', methods=['GET'])
def render_geometry_shape_with_lockout(question_id):
    """Render geometry shape with lockout validation"""
    try:
        # Get question data from database or request
        quiz_id = request.args.get('quiz_id')
        if not quiz_id:
            return jsonify({'error': 'Quiz ID required'}), 400
        
        # Get quiz and validate lockout
        quiz = GeometryQuiz.query.filter_by(id=quiz_id).first()
        if not quiz:
            return jsonify({'error': 'Quiz not found'}), 404
        
        # Parse questions and find the specific question
        questions = json.loads(quiz.questions_json)
        question = None
        
        for q in questions:
            if str(q.get('id')) == str(question_id):
                question = q
                break
        
        if not question:
            return jsonify({'error': 'Question not found'}), 404
        
        # LOCKOUT VALIDATION: Only render if geometry is allowed
        if not question.get('requires_geometry', False):
            return jsonify({'error': 'No geometry required for this question'}), 400
        
        geometry_type = question.get('geometry_type')
        selected_types = json.loads(quiz.geometry_types) if quiz.geometry_types else []
        
        # STRICT LOCKOUT CHECK
        if geometry_type not in selected_types:
            logging.error(f"ðŸ”’ LOCKOUT VIOLATION: Attempted to render {geometry_type} not in selected types {selected_types}")
            return jsonify({'error': f'Geometry type {geometry_type} not allowed in this quiz'}), 403
        
        # Render the shape using existing comprehensive renderer
        geometry_data = question.get('geometry_data', {})
        render_data = {
            'type': geometry_type,
            'measurements': geometry_data,
            'question_context': {
                'text': question.get('text', ''),
                'hide_answer': True  # Always hide answers in quizzes
            }
        }
        
        # Use existing enhanced renderer
        if 'renderer' in globals():
            result = renderer.render_shape_correctly(render_data)
            if result.get('success'):
                return jsonify(result)
        
        # Fallback response
        return jsonify({
            'success': True,
            'message': f'Shape rendering for {geometry_type} (lockout validated)',
            'geometry_type': geometry_type,
            'lockout_validated': True
        })
        
    except Exception as e:
        logging.error(f"Error rendering geometry shape: {str(e)}")
        return jsonify({'error': str(e)}), 500


print("ðŸ”’ GEOMETRY STRICT LOCKOUT SYSTEM LOADED!")
print("âœ… Features:")
print("   ðŸš« NO keyword analysis - only user selection")
print("   ðŸ”„ Round-robin assignment from selected types")
print("   ðŸŽ¯ Complete lockout if no types selected")
print("   ðŸ›¡ï¸ Lockout validation on shape rendering")
print("   ðŸ“‹ Comprehensive logging and validation") 

# Enhanced Triangle Rendering Backend
# Add this to your existing geometry renderer Python file

# NO-SPOILER TRIANGLE RENDERER WITH ORIGINAL BEAUTIFUL STYLING
# Maintains the exact visual appearance of your original triangles while hiding answers

import re
import math
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from typing import Dict, List, Tuple, Any, Optional
import io
import base64

# ENHANCED COMPREHENSIVE GEOMETRY FIX - SAME ENDPOINTS, ALL ISSUES FIXED
# This enhances your existing code to fix cylinder measurements and trapezium shape

import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.patches import Circle, Rectangle, Polygon, Wedge, FancyBboxPatch
import numpy as np
import io
import base64
from typing import Dict, List, Tuple, Any, Optional
import json
import re
from flask import Blueprint, jsonify, request
import plotly.graph_objects as go
import plotly.express as px
from plotly.offline import plot
import plotly.io as pio
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
import math

# Configure matplotlib for better rendering
plt.style.use('seaborn-v0_8-whitegrid')
pio.kaleido.scope.default_width = 600
pio.kaleido.scope.default_height = 400

    
    # DEBUG AND FIX FOR EnhancedFixedGeometryRenderer
# Replace your entire render_shape_correctly method with this

class EnhancedFixedGeometryRenderer:
    """Enhanced Fixed Geometry Renderer with proper _figure_to_base64 method"""
    
    def __init__(self):
        self.figure_size = (8, 6)
        self.dpi = 100
        self.colors = {
            'primary': '#10B981',
            'secondary': '#3B82F6',
            'accent': '#F59E0B',
            'text': '#1F2937',
            'grid': '#E5E7EB'
        }

    def render_shape_correctly(self, data):
        """FIXED: Complete render_shape_correctly method with all shapes"""
        try:
            print(f"ðŸ”§ render_shape_correctly called with data: {data}")
            
            # Extract shape information
            shape_type = data.get('type', 'triangle')
            measurements = data.get('measurements', {})
            dimensions = data.get('dimensions', {})
            question_context = data.get('question_context', {})
            
            # Merge measurements and dimensions
            all_measurements = {**measurements, **dimensions}
            hide_answer = question_context.get('hide_answer', False)
            question_text = question_context.get('text', '')
            
            print(f"ðŸŽ¯ Processing shape: {shape_type} with measurements: {all_measurements}")

            # ====== QUALITY ASSURANCE: Shape Type Validation ======
            # Prevent transformation rendering when explicit shape type is set
            explicit_shapes = [
                'triangle', 'right_triangle', 'equilateral_triangle', 'isosceles_triangle',
                'scalene_triangle', 'obtuse_triangle', 'acute_triangle',
                'circle', 'sector', 'rectangle', 'square', 'trapezium',
                'cylinder', 'cone', 'sphere', 'cube', 'pentagon', 'hexagon', 'polygon'
            ]

            has_explicit_shape = shape_type in explicit_shapes
            has_transformation_data = all_measurements.get('transformation_type') is not None

            if has_explicit_shape and has_transformation_data:
                # CONFLICT RESOLUTION: Explicit shape takes precedence
                logging.warning(
                    f"âš ï¸  CONFLICT DETECTED: shape_type='{shape_type}' but transformation_type='{all_measurements.get('transformation_type')}' also present. "
                    f"RESOLVING: Rendering as '{shape_type}' (explicit shape takes precedence)"
                )
                print(f"ðŸ›¡ï¸ QUALITY CHECK: Removing transformation_type to prevent mismatch")
                # Remove transformation_type to prevent incorrect rendering
                all_measurements.pop('transformation_type', None)
                has_transformation_data = False

            # Now check for transformation rendering (only if no explicit shape conflict)
            if has_transformation_data and not has_explicit_shape:
                print(f"ðŸ”„ TRANSFORMATION DETECTED: {all_measurements['transformation_type']}")
                try:
                    return {
                        'success': True,
                        'image': transformation_renderer.render_transformation(all_measurements, hide_answer),
                        'is_transformation': True,
                        'answer_hidden': hide_answer
                    }
                except Exception as trans_err:
                    print(f"âŒ Transformation rendering failed: {trans_err}")
                    return {
                        'success': False,
                        'error': f'Transformation rendering error: {str(trans_err)}'
                    }

            # If shape_type is 'transformation' but no transformation_type in measurements, return error
            if shape_type == 'transformation' and not has_transformation_data:
                print(f"âš ï¸ shape_type='transformation' but no transformation_type in measurements")
                return {
                    'success': False,
                    'error': 'Transformation shape type detected but transformation data is missing',
                    'shape_type': shape_type,
                    'measurements': all_measurements
                }
            
            # CRITICAL: Fix shape type mismatches
            if shape_type == 'circle' and 'central_angle' in all_measurements:
                print("ðŸ”„ Converting circle with central_angle to sector")
                shape_type = 'sector'
            
            if shape_type == 'circle' and ('height' in all_measurements or 'cylinder' in question_text.lower()):
                print("ðŸ”„ Converting circle to cylinder based on context")
                shape_type = 'cylinder'
            
            # Route to specific rendering methods
            if shape_type == 'sphere':
                return self.render_sphere_comprehensive(all_measurements, hide_answer)
            elif shape_type == 'cube':
                return self.render_cube_comprehensive(all_measurements, hide_answer)
            elif shape_type == 'cylinder':
                return self.render_cylinder_comprehensive(all_measurements, hide_answer)
            elif shape_type == 'cone':
                return self.render_cone_comprehensive(all_measurements, hide_answer)
            elif shape_type == 'triangular_prism':
                return self.render_triangular_prism_comprehensive(all_measurements, hide_answer)
            elif shape_type == 'rectangular_prism':
                return self.render_rectangular_prism_comprehensive(all_measurements, hide_answer)
            elif shape_type == 'circle':
                return self.render_circle_comprehensive(all_measurements, hide_answer)
            elif shape_type == 'sector':
                return self.render_sector_comprehensive(all_measurements, hide_answer)
            elif shape_type in ['triangle', 'right_triangle', 'equilateral_triangle', 'isosceles_triangle', 'scalene_triangle', 'obtuse_triangle', 'acute_triangle']:
                all_measurements['question_text'] = question_context.get('text', '')
                return self.render_triangle_comprehensive(shape_type, all_measurements, hide_answer)
            elif shape_type == 'rectangle':
                return self.render_rectangle_comprehensive(all_measurements, hide_answer)
            elif shape_type == 'square':
                return self.render_square_comprehensive(all_measurements, hide_answer)
            elif shape_type == 'trapezium':
                return self.render_trapezium_comprehensive(all_measurements, hide_answer)
            elif shape_type in ['polygon', 'pentagon', 'hexagon', 'octagon', 'heptagon']:
                return self.render_polygon_comprehensive(all_measurements, hide_answer, shape_type)
            elif shape_type == 'parallel_lines':
                question_text = question_context.get('text', '')
                return self.render_parallel_lines_comprehensive(all_measurements, hide_answer, question_text)
            elif shape_type in ['complementary_angles', 'supplementary_angles']:
                return self.render_angles_comprehensive(shape_type, all_measurements, hide_answer)
            elif 'net' in shape_type:
                return self.render_net_comprehensive(shape_type, all_measurements, hide_answer)
            else:
                # Fallback for unknown shape types
                print(f"âš ï¸ Unknown shape type: {shape_type}, returning error")
                return {
                    'success': False,
                    'error': f'Unsupported shape type: {shape_type}',
                    'shape_type': shape_type,
                    'measurements': all_measurements
                }
                
        except Exception as e:
            print(f"âŒ Error in render_shape_correctly: {e}")
            import traceback
            traceback.print_exc()
            return {'success': False, 'error': str(e)}

        
    def render_sphere_comprehensive(self, measurements, hide_answer=False):
        """Render a sphere with proper 3D visualization"""
        try:
            import matplotlib.pyplot as plt
            from mpl_toolkits.mplot3d import Axes3D
            import numpy as np
            import math
            
            fig = plt.figure(figsize=(8, 8), dpi=100)
            ax = fig.add_subplot(111, projection='3d')
            fig.patch.set_facecolor('white')
            
            radius = measurements.get('radius', 5)
            
            # Create sphere
            u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
            x = radius * np.cos(u) * np.sin(v)
            y = radius * np.sin(u) * np.sin(v)
            z = radius * np.cos(v)
            
            # Plot surface
            ax.plot_surface(x, y, z, alpha=0.7, color=self.colors['primary'], 
                           edgecolor=self.colors['text'], linewidth=0.5)
            
            # Add center point
            ax.scatter([0], [0], [0], color=self.colors['secondary'], s=30)
            
            # Always show radius
            ax.text(0, 0, -radius - 0.6, f'r = {radius} cm', 
                   fontsize=12, fontweight='bold',
                   ha='center', va='center', color=self.colors['accent'])
            
            # Only show volume if NOT hiding answer
            if not hide_answer:
                volume = (4/3) * math.pi * radius**3
                ax.text(0, 0, 0, f'V = {volume:.2f} cmÂ³', 
                       fontsize=12, fontweight='bold',
                       bbox=dict(boxstyle='round,pad=0.3', 
                               facecolor='white', alpha=0.8))
            
            # Set title and labels
            ax.set_title('Sphere', fontsize=16, fontweight='bold', pad=20)
            ax.set_xlabel('X', fontsize=12)
            ax.set_ylabel('Y', fontsize=12)
            ax.set_zlabel('Z', fontsize=12)
            
            # Set limits
            ax.set_xlim(-radius*1.5, radius*1.5)
            ax.set_ylim(-radius*1.5, radius*1.5)
            ax.set_zlim(-radius*1.5, radius*1.5)
            
            return {
                'success': True,
                'image': self._figure_to_base64(fig),
                'answer_hidden': hide_answer
            }
            
        except Exception as e:
            print(f"Error rendering sphere: {e}")
            return {'success': False, 'error': str(e)}

    
    # KEEP EXISTING METHODS FOR CIRCLES AND OTHER SHAPES
    def render_circle_comprehensive(self, measurements, hide_answer=False):
        """Render a basic circle - NEVER SHOW AREA IN QUIZ"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.patches import Circle
            import math
            
            fig, ax = plt.subplots(figsize=(8, 8), dpi=100)
            fig.patch.set_facecolor('white')
            ax.set_facecolor('white')
            
            # Extract radius from various possible keys
            radius = measurements.get('radius', 5)
            if 'circumference' in measurements:
                circumference = measurements['circumference']
                radius = circumference / (2 * math.pi)
            
            # Draw circle
            circle = Circle((0, 0), radius, fill=False, edgecolor='#10B981', linewidth=3)
            ax.add_patch(circle)
            
            # Fill with light color
            circle_fill = Circle((0, 0), radius, fill=True, facecolor='#10B981', alpha=0.1)
            ax.add_patch(circle_fill)
            
            # Center point
            ax.plot(0, 0, 'o', color='#3B82F6', markersize=8)
            ax.text(0, -radius*0.15, 'O', fontsize=12, fontweight='bold', ha='center')
            
            # Radius line
            ax.plot([0, radius], [0, 0], '--', color='#3B82F6', linewidth=2)
            ax.text(radius/2, radius*0.1, f'r = {radius:.1f} cm', fontsize=11, fontweight='bold', ha='center')
            
            # NEVER show area calculation in quiz questions
            
            margin = radius * 0.3
            ax.set_xlim(-radius - margin, radius + margin)
            ax.set_ylim(-radius - margin, radius + margin)
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.3)
            ax.set_title('Circle', fontsize=16, fontweight='bold')
            
            return {'success': True, 'image': self._figure_to_base64(fig), 'answer_hidden': True}
            
        except Exception as e:
            print(f"Error rendering circle: {e}")
            return {'success': False, 'error': str(e)}
        
    def render_sector_comprehensive(self, measurements, hide_answer=False):
        """Render a circle sector"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.patches import Circle, Wedge, Arc
            import math
            
            fig, ax = plt.subplots(figsize=(8, 8), dpi=100)
            fig.patch.set_facecolor('white')
            ax.set_facecolor('white')
            
            radius = measurements.get('radius', 5)
            central_angle = measurements.get('central_angle', 60)
            
            print(f"ðŸŽ¯ Rendering sector: radius={radius}, angle={central_angle}")
            
            # Draw full circle outline (dashed)
            circle = Circle((0, 0), radius, fill=False, edgecolor='#6B7280', 
                           linewidth=1, alpha=0.3, linestyle='--')
            ax.add_patch(circle)
            
            # Draw sector
            wedge = Wedge((0, 0), radius, 0, central_angle, facecolor='#10B981', 
                         alpha=0.6, edgecolor='#10B981', linewidth=2)
            ax.add_patch(wedge)
            
            # Radius lines
            ax.plot([0, radius], [0, 0], color='#3B82F6', linewidth=2)
            end_x = radius * math.cos(math.radians(central_angle))
            end_y = radius * math.sin(math.radians(central_angle))
            ax.plot([0, end_x], [0, end_y], color='#3B82F6', linewidth=2)
            
            # Center point
            ax.plot(0, 0, 'o', color='#1F2937', markersize=8)
            ax.text(0, -radius*0.15, 'O', fontsize=12, fontweight='bold', ha='center')
            
            # Angle arc
            angle_arc = Arc((0, 0), radius*0.6, radius*0.6, angle=0, theta1=0, theta2=central_angle,
                           color='#F59E0B', linewidth=3)
            ax.add_patch(angle_arc)
            
            # Labels
            ax.text(radius/2, -radius*0.1, f'r = {radius} cm', fontsize=10, ha='center')
            mid_angle = math.radians(central_angle / 2)
            label_x = (radius * 0.4) * math.cos(mid_angle)
            label_y = (radius * 0.4) * math.sin(mid_angle)
            ax.text(label_x, label_y, f'{central_angle}Â°', fontsize=12, fontweight='bold',
                   ha='center', va='center', 
                   bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
            
            # Show calculations if not hiding answer
            if not hide_answer:
                sector_area = (central_angle / 360) * math.pi * radius**2
                arc_length = (central_angle / 360) * 2 * math.pi * radius
                ax.text(0, -radius*1.2, f'Sector Area = {sector_area:.2f} cmÂ²', 
                       fontsize=11, fontweight='bold', ha='center',
                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.9))
            
            margin = radius * 0.3
            ax.set_xlim(-radius - margin, radius + margin)
            ax.set_ylim(-radius - margin*2, radius + margin)
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.3)
            ax.set_title(f'Circle Sector ({central_angle}Â°)', fontsize=16, fontweight='bold')
            
            return {
                'success': True,
                'image': self._figure_to_base64(fig),
                'answer_hidden': hide_answer
            }
            
        except Exception as e:
            print(f"Error rendering sector: {e}")
            return {'success': False, 'error': str(e)}
            

    def render_cube_comprehensive(self, measurements, hide_answer=False):
        """Render a cube with proper 3D visualization"""
        try:
            import matplotlib.pyplot as plt
            from mpl_toolkits.mplot3d.art3d import Poly3DCollection
            import numpy as np
            
            fig = plt.figure(figsize=(8, 8), dpi=100)
            ax = fig.add_subplot(111, projection='3d')
            fig.patch.set_facecolor('white')
            
            side = measurements.get('side', 5)
            
            # Define cube vertices
            vertices = np.array([
                [0, 0, 0], [side, 0, 0], [side, side, 0], [0, side, 0],
                [0, 0, side], [side, 0, side], [side, side, side], [0, side, side]
            ])
            
            # Define cube faces
            faces = [
                [vertices[0], vertices[1], vertices[2], vertices[3]],  # bottom
                [vertices[4], vertices[5], vertices[6], vertices[7]],  # top
                [vertices[0], vertices[1], vertices[5], vertices[4]],  # front
                [vertices[2], vertices[3], vertices[7], vertices[6]],  # back
                [vertices[1], vertices[2], vertices[6], vertices[5]],  # right
                [vertices[0], vertices[3], vertices[7], vertices[4]]   # left
            ]
            
            # Colors for faces
            face_colors = ['#3B82F6', '#10B981', '#10B981', '#F59E0B', '#10B981', '#F59E0B']
            
            # Draw faces
            for i, face in enumerate(faces):
                poly = Poly3DCollection([face], alpha=0.8, 
                                      facecolor=face_colors[i], 
                                      edgecolor='black', linewidth=1.5)
                ax.add_collection3d(poly)
            
            # Add dimension labels
            ax.text(side/2, -side*0.2, -side*0.1, f'{side} cm', 
                   fontsize=12, fontweight='bold', ha='center')
            
            # Show calculations if not hiding answer
            if not hide_answer:
                volume = side**3
                ax.text(side/2, side/2, side + side*0.3, 
                       f'Volume = {volume} cmÂ³', 
                       fontsize=12, fontweight='bold', ha='center',
                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.9))
            
            ax.set_xlabel('X (cm)')
            ax.set_ylabel('Y (cm)')
            ax.set_zlabel('Z (cm)')
            ax.set_title('Cube', fontsize=16, fontweight='bold')
            
            # Set viewing angle
            ax.view_init(elev=25, azim=45)
            
            # Set limits
            margin = side * 0.2
            ax.set_xlim(-margin, side + margin)
            ax.set_ylim(-margin, side + margin)
            ax.set_zlim(-margin, side + margin)
            
            return {
                'success': True,
                'image': self._figure_to_base64(fig),
                'answer_hidden': hide_answer
            }
            
        except Exception as e:
            print(f"Error rendering cube: {e}")
            return {'success': False, 'error': str(e)}


    # Proper shape rendering methods - properly indented for class
    def render_cylinder_comprehensive(self, measurements, hide_answer=False):
        """Render a cylinder with proper 3D visualization"""
        try:
            import matplotlib.pyplot as plt
            from mpl_toolkits.mplot3d import Axes3D
            import numpy as np
            import math
            
            fig = plt.figure(figsize=(8, 8), dpi=100)
            ax = fig.add_subplot(111, projection='3d')
            fig.patch.set_facecolor('white')
            
            radius = measurements.get('radius', 4)
            height = measurements.get('height', 10)
            
            # Create cylinder
            theta = np.linspace(0, 2*np.pi, 30)
            z_bottom = np.zeros_like(theta)
            z_top = np.full_like(theta, height)
            x = radius * np.cos(theta)
            y = radius * np.sin(theta)
            
            # Draw cylinder surfaces
            ax.plot(x, y, z_bottom, color='#10B981', linewidth=2)
            ax.plot(x, y, z_top, color='#10B981', linewidth=2)
            
            # Vertical lines
            for i in range(0, len(theta), 5):
                ax.plot([x[i], x[i]], [y[i], y[i]], [0, height], 
                       color='#10B981', linewidth=1, alpha=0.6)
            
            # Fill surfaces
            ax.plot_trisurf(x, y, z_bottom, alpha=0.3, color='#10B981')
            ax.plot_trisurf(x, y, z_top, alpha=0.3, color='#10B981')
            
            # Labels
            ax.text(radius/2, 0, -1, f'r = {radius} cm', fontsize=12, fontweight='bold', ha='center')
            ax.text(0, radius + 1, height/2, f'h = {height} cm', fontsize=12, fontweight='bold', ha='center')
            
            if not hide_answer:
                volume = math.pi * radius**2 * height
                ax.text(0, 0, height/2, f'V = {volume:.1f} cmÂ³', fontsize=12, fontweight='bold',
                       bbox=dict(boxstyle='round,pad=0.3', facecolor='white', alpha=0.8))
            
            ax.set_title('Cylinder', fontsize=16, fontweight='bold')
            ax.set_xlabel('X')
            ax.set_ylabel('Y')
            ax.set_zlabel('Z')
            
            margin = max(radius, height) * 0.2
            ax.set_xlim(-radius - margin, radius + margin)
            ax.set_ylim(-radius - margin, radius + margin)
            ax.set_zlim(-margin, height + margin)
            
            return {'success': True, 'image': self._figure_to_base64(fig), 'answer_hidden': hide_answer}
            
        except Exception as e:
            print(f"Error rendering cylinder: {e}")
            return {'success': False, 'error': str(e)}

    def render_cone_comprehensive(self, measurements, hide_answer=False):
        """Render a cone with proper 3D visualization"""
        try:
            import matplotlib.pyplot as plt
            from mpl_toolkits.mplot3d import Axes3D
            import numpy as np
            import math
            
            fig = plt.figure(figsize=(8, 8), dpi=100)
            ax = fig.add_subplot(111, projection='3d')
            fig.patch.set_facecolor('white')
            
            radius = measurements.get('radius', 3)
            height = measurements.get('height', 6)
            
            # Create cone
            theta = np.linspace(0, 2*np.pi, 30)
            z = np.linspace(0, height, 30)
            Theta, Z = np.meshgrid(theta, z)
            
            # Cone surface
            R = radius * (1 - Z/height)
            X = R * np.cos(Theta)
            Y = R * np.sin(Theta)
            
            # Plot surface
            ax.plot_surface(X, Y, Z, color='#10B981', alpha=0.7, edgecolor='#1F2937', linewidths=0.5)
            
            # Add circular base
            base_x = radius * np.cos(theta)
            base_y = radius * np.sin(theta)
            base_z = np.zeros_like(theta)
            ax.plot(base_x, base_y, base_z, color='#F59E0B', linewidth=2)
            
            # Labels
            ax.text(radius/2, 0, -1, f'r = {radius} cm', fontsize=11, fontweight='bold', ha='center')
            ax.text(0, radius + 1, height/2, f'h = {height} cm', fontsize=11, fontweight='bold', ha='center')
            
            if not hide_answer:
                volume = (1/3) * math.pi * radius**2 * height
                ax.text(0, 0, height/2, f'V = {volume:.2f} cmÂ³', fontsize=12, fontweight='bold',
                       bbox=dict(boxstyle='round,pad=0.3', facecolor='white', alpha=0.8))
            
            ax.set_title('Cone', fontsize=16, fontweight='bold')
            ax.set_xlabel('X')
            ax.set_ylabel('Y')
            ax.set_zlabel('Z')
            
            margin = max(radius, height) * 0.3
            ax.set_xlim(-radius - margin, radius + margin)
            ax.set_ylim(-radius - margin, radius + margin)
            ax.set_zlim(-margin, height + margin)
            
            return {'success': True, 'image': self._figure_to_base64(fig), 'answer_hidden': hide_answer}
            
        except Exception as e:
            print(f"Error rendering cone: {e}")
            return {'success': False, 'error': str(e)}

    def render_triangular_prism_comprehensive(self, measurements, hide_answer=False):
        """Render a triangular prism with support for different triangle types"""
        try:
            import matplotlib.pyplot as plt
            from mpl_toolkits.mplot3d.art3d import Poly3DCollection
            import numpy as np
            import math

            fig = plt.figure(figsize=(10, 8), dpi=100)
            ax = fig.add_subplot(111, projection='3d')
            fig.patch.set_facecolor('white')

            # Get prism height (depth)
            prism_height = measurements.get('height', measurements.get('prism_height', 8))

            # Determine triangle type and get appropriate measurements
            triangle_type = measurements.get('triangle_type', 'equilateral')

            # Calculate triangle vertices based on type
            if triangle_type == 'right' or triangle_type == 'right_isosceles':
                # Right triangle or right isosceles triangle
                leg_a = measurements.get('leg_a', measurements.get('base', 6))
                leg_b = measurements.get('leg_b', measurements.get('tri_height', leg_a if triangle_type == 'right_isosceles' else 8))

                # Right angle at origin, legs along x and z axes
                front_triangle = np.array([
                    [0, 0, 0],           # Right angle vertex
                    [leg_a, 0, 0],       # End of base
                    [0, 0, leg_b]        # End of height
                ])
                triangle_base = leg_a
                triangle_height = leg_b

            elif triangle_type == 'scalene':
                # Scalene triangle with three different sides
                side_a = measurements.get('side_a', measurements.get('base_side_a', 5))
                side_b = measurements.get('side_b', measurements.get('base_side_b', 7))
                side_c = measurements.get('side_c', measurements.get('base_side_c', 8))

                # Place side_a along x-axis, calculate position of third vertex using law of cosines
                # Using Heron's formula to find height
                s = (side_a + side_b + side_c) / 2
                area = math.sqrt(s * (s - side_a) * (s - side_b) * (s - side_c))
                tri_height = (2 * area) / side_a

                # Calculate x-coordinate of third vertex using law of cosines
                # cos(A) = (bÂ² + cÂ² - aÂ²) / (2bc)
                cos_angle = (side_b**2 + side_a**2 - side_c**2) / (2 * side_b * side_a)
                x_coord = side_b * cos_angle

                front_triangle = np.array([
                    [0, 0, 0],
                    [side_a, 0, 0],
                    [x_coord, 0, tri_height]
                ])
                triangle_base = side_a
                triangle_height = tri_height

            elif triangle_type == 'isosceles':
                # Isosceles triangle with two equal sides
                equal_side = measurements.get('equal_side', measurements.get('leg', 8))
                base = measurements.get('base', measurements.get('base_side', 6))

                # Calculate height
                tri_height = math.sqrt(equal_side**2 - (base/2)**2)

                front_triangle = np.array([
                    [0, 0, 0],
                    [base, 0, 0],
                    [base/2, 0, tri_height]
                ])
                triangle_base = base
                triangle_height = tri_height

            else:  # equilateral or default
                # Equilateral triangle
                base_side = measurements.get('base_side', measurements.get('base', measurements.get('side', 6)))
                triangle_height = (base_side * math.sqrt(3)) / 2

                front_triangle = np.array([
                    [0, 0, 0],
                    [base_side, 0, 0],
                    [base_side/2, 0, triangle_height]
                ])
                triangle_base = base_side

            # Back triangular face vertices (translate along y-axis)
            back_triangle = front_triangle.copy()
            back_triangle[:, 1] = prism_height

            # Define faces
            faces = [
                front_triangle,  # front triangle
                back_triangle,   # back triangle
                # Rectangular faces connecting front and back
                [front_triangle[0], front_triangle[1], back_triangle[1], back_triangle[0]],
                [front_triangle[1], front_triangle[2], back_triangle[2], back_triangle[1]],
                [front_triangle[2], front_triangle[0], back_triangle[0], back_triangle[2]]
            ]

            # Colors for different faces
            face_colors = ['#10B981', '#10B981', '#3B82F6', '#F59E0B', '#F59E0B']

            # Draw faces
            for i, face in enumerate(faces):
                poly = Poly3DCollection([face], alpha=0.7, facecolor=face_colors[i],
                                      edgecolor='black', linewidth=1.5)
                ax.add_collection3d(poly)

            # Add dimension labels
            max_x = np.max(front_triangle[:, 0])
            max_z = np.max(front_triangle[:, 2])

            ax.text(max_x/2, -prism_height*0.15, -max_z*0.1, f'{triangle_base:.1f} cm',
                   fontsize=12, fontweight='bold', ha='center')
            ax.text(-max_x*0.15, prism_height/2, max_z/2, f'{prism_height:.1f} cm',
                   fontsize=12, fontweight='bold', ha='center')

            if not hide_answer:
                # Calculate surface area based on triangle type
                if triangle_type == 'right' or triangle_type == 'right_isosceles':
                    base_area = 0.5 * triangle_base * triangle_height
                    side_lengths = [triangle_base, triangle_height,
                                   math.sqrt(triangle_base**2 + triangle_height**2)]
                elif triangle_type == 'scalene':
                    s = (side_a + side_b + side_c) / 2
                    base_area = math.sqrt(s * (s - side_a) * (s - side_b) * (s - side_c))
                    side_lengths = [side_a, side_b, side_c]
                elif triangle_type == 'isosceles':
                    base_area = 0.5 * triangle_base * triangle_height
                    side_lengths = [triangle_base, equal_side, equal_side]
                else:  # equilateral
                    base_area = (triangle_base**2 * math.sqrt(3)) / 4
                    side_lengths = [triangle_base, triangle_base, triangle_base]

                lateral_area = sum(side_lengths) * prism_height
                surface_area = 2 * base_area + lateral_area

                ax.text(max_x/2, prism_height/2, max_z + max_z*0.3,
                       f'Surface Area = {surface_area:.2f} cmÂ²', fontsize=12, fontweight='bold', ha='center',
                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.9))

            ax.set_xlabel('X (cm)')
            ax.set_ylabel('Y (cm)')
            ax.set_zlabel('Z (cm)')

            # Set title based on triangle type
            title = f'{triangle_type.replace("_", " ").title()} Triangular Prism'
            ax.set_title(title, fontsize=16, fontweight='bold')
            ax.view_init(elev=20, azim=45)

            # Set appropriate axis limits
            margin = max(max_x, prism_height, max_z) * 0.2
            ax.set_xlim(-margin, max_x + margin)
            ax.set_ylim(-margin, prism_height + margin)
            ax.set_zlim(-margin, max_z + margin)

            plt.tight_layout()
            return {'success': True, 'image': self._figure_to_base64(fig), 'answer_hidden': hide_answer}

        except Exception as e:
            print(f"Error rendering triangular prism: {e}")
            import traceback
            traceback.print_exc()
            return {'success': False, 'error': str(e)}

    def render_rectangular_prism_comprehensive(self, measurements, hide_answer=False):
        """Render a rectangular prism"""
        try:
            import matplotlib.pyplot as plt
            from mpl_toolkits.mplot3d.art3d import Poly3DCollection
            import numpy as np
            
            fig = plt.figure(figsize=(10, 8), dpi=100)
            ax = fig.add_subplot(111, projection='3d')
            fig.patch.set_facecolor('white')
            
            length = measurements.get('length', 6)
            width = measurements.get('width', 4)
            height = measurements.get('height', 3)
            
            # Define vertices
            vertices = np.array([
                [0, 0, 0], [length, 0, 0], [length, width, 0], [0, width, 0],
                [0, 0, height], [length, 0, height], [length, width, height], [0, width, height]
            ])
            
            # Define faces
            faces = [
                [vertices[0], vertices[1], vertices[2], vertices[3]],  # bottom
                [vertices[4], vertices[5], vertices[6], vertices[7]],  # top
                [vertices[0], vertices[1], vertices[5], vertices[4]],  # front
                [vertices[2], vertices[3], vertices[7], vertices[6]],  # back
                [vertices[1], vertices[2], vertices[6], vertices[5]],  # right
                [vertices[0], vertices[3], vertices[7], vertices[4]]   # left
            ]
            
            # Colors for faces
            face_colors = ['#3B82F6', '#10B981', '#10B981', '#F59E0B', '#10B981', '#F59E0B']
            
            # Draw faces
            for i, face in enumerate(faces):
                poly = Poly3DCollection([face], alpha=0.8, facecolor=face_colors[i], 
                                      edgecolor='black', linewidth=1.5)
                ax.add_collection3d(poly)
            
            # Add dimension labels
            ax.text(length/2, -width*0.2, -height*0.1, f'{length} cm', 
                   fontsize=12, fontweight='bold', ha='center')
            ax.text(length + length*0.1, width/2, height/2, f'{width} cm', 
                   fontsize=12, fontweight='bold', ha='left')
            ax.text(-length*0.1, width + width*0.1, height/2, f'{height} cm', 
                   fontsize=12, fontweight='bold', ha='right')
            
            if not hide_answer:
                perimeter = 2 * (length + width)  # Base perimeter
                ax.text(length/2, width/2, height + height*0.3, 
                       f'Base Perimeter = {perimeter} cm', fontsize=12, fontweight='bold', ha='center',
                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.9))
            
            ax.set_xlabel('X (cm)')
            ax.set_ylabel('Y (cm)')
            ax.set_zlabel('Z (cm)')
            ax.set_title('Rectangular Prism', fontsize=16, fontweight='bold')
            ax.view_init(elev=25, azim=45)
            
            margin = max(length, width, height) * 0.2
            ax.set_xlim(-margin, length + margin)
            ax.set_ylim(-margin, width + margin)
            ax.set_zlim(-margin, height + margin)
            
            return {'success': True, 'image': self._figure_to_base64(fig), 'answer_hidden': hide_answer}
            
        except Exception as e:
            print(f"Error rendering rectangular prism: {e}")
            return {'success': False, 'error': str(e)}

    def render_rectangle_comprehensive(self, measurements, hide_answer=False):
        """Render rectangle"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.patches import Rectangle
            
            fig, ax = plt.subplots(figsize=(8, 6), dpi=100)
            fig.patch.set_facecolor('white')
            ax.set_facecolor('white')
            
            length = measurements.get('length', 8)
            width = measurements.get('width', 5)
            
            # Draw rectangle
            rect = Rectangle((0, 0), length, width, fill=True, facecolor='#10B981', 
                            alpha=0.3, edgecolor='#10B981', linewidth=3)
            ax.add_patch(rect)
            
            # Add dimension labels
            ax.text(length/2, -0.3, f'{length} cm', fontsize=11, ha='center', fontweight='bold')
            ax.text(-0.5, width/2, f'{width} cm', fontsize=11, ha='center', va='center', 
                   rotation=90, fontweight='bold')
            
            if not hide_answer:
                area = length * width
                ax.text(length/2, width + 0.5, f'Area = {area} cmÂ²', 
                       fontsize=11, fontweight='bold', ha='center',
                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.9))
            
            margin = max(length, width) * 0.2
            ax.set_xlim(-margin, length + margin)
            ax.set_ylim(-margin, width + margin)
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.3)
            ax.set_title('Rectangle', fontsize=16, fontweight='bold')
            
            return {'success': True, 'image': self._figure_to_base64(fig), 'answer_hidden': hide_answer}
            
        except Exception as e:
            print(f"Error rendering rectangle: {e}")
            return {'success': False, 'error': str(e)}

    def render_square_comprehensive(self, measurements, hide_answer=False):
        """Render square"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.patches import Rectangle
            
            fig, ax = plt.subplots(figsize=(8, 8), dpi=100)
            fig.patch.set_facecolor('white')
            ax.set_facecolor('white')
            
            side = measurements.get('side', 5)
            
            # Draw square
            square = Rectangle((0, 0), side, side, fill=True, facecolor='#10B981', 
                              alpha=0.3, edgecolor='#10B981', linewidth=3)
            ax.add_patch(square)
            
            # Add dimension labels
            ax.text(side/2, -0.3, f'{side} cm', fontsize=11, ha='center', fontweight='bold')
            
            if not hide_answer:
                area = side * side
                ax.text(side/2, side + 0.5, f'Area = {area} cmÂ²', 
                       fontsize=11, fontweight='bold', ha='center',
                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.9))
            
            margin = side * 0.2
            ax.set_xlim(-margin, side + margin)
            ax.set_ylim(-margin, side + margin)
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.3)
            ax.set_title('Square', fontsize=16, fontweight='bold')
            
            return {'success': True, 'image': self._figure_to_base64(fig), 'answer_hidden': hide_answer}
            
        except Exception as e:
            print(f"Error rendering square: {e}")
            return {'success': False, 'error': str(e)}
    

    # Add this to your EnhancedFixedGeometryRenderer class
    def render_triangle_comprehensive(self, triangle_type, measurements, hide_answer=False):
        """Render triangle with proper right angle marker"""
        try:
            import matplotlib.pyplot as plt
            import matplotlib.patches as patches
            import numpy as np
            
            fig, ax = plt.subplots(figsize=(8, 6), dpi=100)
            fig.patch.set_facecolor('white')
            ax.set_facecolor('white')
            
            # Get measurements and triangle type info
            base = measurements.get('base', measurements.get('side_c', 6))
            height = measurements.get('height', 8)
            hypotenuse = measurements.get('hypotenuse', None)
            tri_type = measurements.get('triangle_type', triangle_type.replace('_triangle', ''))

            # Calculate vertices based on triangle type
            if 'equilateral' in triangle_type.lower() or tri_type == 'equilateral':
                # Equilateral triangle: all sides equal
                side = measurements.get('side_a', measurements.get('side_b', base))
                height_calc = (math.sqrt(3) / 2) * side
                A = np.array([0, 0])
                B = np.array([side, 0])
                C = np.array([side/2, height_calc])
                base = side  # For display purposes

            elif 'isosceles' in triangle_type.lower() or tri_type == 'isosceles':
                # Isosceles triangle: two equal sides
                equal_side = measurements.get('side_a', measurements.get('side_b', 8))
                base = measurements.get('side_c', measurements.get('base', 6))
                # Height at center of base
                height_calc = math.sqrt(equal_side**2 - (base/2)**2) if equal_side**2 >= (base/2)**2 else height
                A = np.array([0, 0])
                B = np.array([base, 0])
                C = np.array([base/2, height_calc])
                height = height_calc

            elif 'scalene' in triangle_type.lower() or tri_type == 'scalene':
                # Scalene triangle: all sides different - use law of cosines
                side_a = measurements.get('side_a', 7)
                side_b = measurements.get('side_b', 8)
                side_c = measurements.get('side_c', 9)
                # Place side_c as base
                A = np.array([0, 0])
                B = np.array([side_c, 0])
                # Calculate C using law of cosines: cosA = (bÂ² + cÂ² - aÂ²) / (2bc)
                cos_angle = (side_b**2 + side_c**2 - side_a**2) / (2 * side_b * side_c)
                cos_angle = max(-1, min(1, cos_angle))  # Clamp to [-1, 1]
                angle = math.acos(cos_angle)
                C = np.array([side_b * math.cos(angle), side_b * math.sin(angle)])
                base = side_c
                height = C[1]

            elif 'obtuse' in triangle_type.lower() or tri_type == 'obtuse':
                # Obtuse triangle: one angle > 90Â°
                base = measurements.get('base', measurements.get('side_c', 8))
                height_val = measurements.get('height', 6)
                # Place apex off-center to create obtuse angle
                A = np.array([0, 0])
                B = np.array([base, 0])
                C = np.array([base * 0.2, height_val])  # Closer to left for obtuse angle
                height = height_val

            elif 'acute' in triangle_type.lower() or tri_type == 'acute':
                # Acute triangle: all angles < 90Â°
                base = measurements.get('base', measurements.get('side_c', 8))
                height_val = measurements.get('height', 7)
                # Center the apex for acute angles
                A = np.array([0, 0])
                B = np.array([base, 0])
                C = np.array([base * 0.45, height_val])  # More centered
                height = height_val

            else:
                # Right triangle (default)
                base = measurements.get('base', 6)
                height = measurements.get('height', 8)
                A = np.array([0, 0])  # Bottom left (right angle here)
                B = np.array([base, 0])  # Bottom right
                C = np.array([0, height])  # Top

            # Draw triangle
            triangle = plt.Polygon([A, B, C], fill=True, facecolor='#10B98150',
                                   edgecolor='#10B981', linewidth=3)
            ax.add_patch(triangle)
            
            # ========== ADD RIGHT ANGLE MARKER ==========
            if 'right' in triangle_type.lower():
                # Draw small square at right angle corner (point A)
                square_size = min(base, height) * 0.08  # 8% of smaller dimension
                
                # Create square at origin
                right_angle_square = patches.Rectangle(
                    (0, 0),  # Bottom-left corner of square
                    square_size,  # Width
                    square_size,  # Height
                    linewidth=2,
                    edgecolor='#EF4444',  # Red color
                    facecolor='none',
                    zorder=10
                )
                ax.add_patch(right_angle_square)
            # ========== END RIGHT ANGLE MARKER ==========
            
            # Label vertices
            ax.text(A[0] - 0.3, A[1] - 0.3, 'A', fontsize=14, fontweight='bold', 
                    ha='right', va='top')
            ax.text(B[0] + 0.3, B[1] - 0.3, 'B', fontsize=14, fontweight='bold', 
                    ha='left', va='top')
            ax.text(C[0] - 0.3, C[1] + 0.3, 'C', fontsize=14, fontweight='bold', 
                    ha='right', va='bottom')
            
            # Add dimension labels - but hide the one being asked for
            question_text = measurements.get('question_text', '').lower()

            # Determine what's being asked - using more flexible pattern matching
            # Check for base-related questions
            asking_for_base = any(phrase in question_text for phrase in [
                'base', 'length of the base'
            ]) and any(word in question_text for word in ['what', 'find', 'calculate', 'determine'])

            # Check for height-related questions
            # Match variations like "what is the height", "find the triangle's height", "length of the height"
            asking_for_height = 'height' in question_text and any(word in question_text for word in [
                'what', 'find', 'calculate', 'determine', 'length'
            ]) and 'hypotenuse' not in question_text.replace("height", "")

            # Check for hypotenuse-related questions
            asking_for_hypotenuse = 'hypotenuse' in question_text and any(word in question_text for word in [
                'what', 'find', 'calculate', 'determine', 'length'
            ])

            # Check if asking for area - if so, hide height (since area = 1/2 * base * height)
            asking_for_area = 'area' in question_text and any(word in question_text for word in [
                'what', 'find', 'calculate', 'determine'
            ])

            # Check if asking for perimeter or side
            asking_for_perimeter = 'perimeter' in question_text and any(word in question_text for word in [
                'what', 'find', 'calculate', 'determine'
            ])
            asking_for_side = 'side' in question_text and any(word in question_text for word in [
                'what', 'find', 'calculate', 'determine', 'length'
            ])

            # If asking for area and both base and height are given, hide height
            if asking_for_area:
                asking_for_height = True  # Hide height to avoid giving away the answer

            # If asking for perimeter, hide all side measurements
            if asking_for_perimeter:
                asking_for_base = True
                asking_for_height = True
                asking_for_side = True

            # ========== ANGLE-RELATED QUESTION DETECTION ==========
            # Check if the question is about angles
            asking_about_angles = any(phrase in question_text for phrase in [
                'angle', 'angles', 'degree', 'degrees', 'measure of',
                'other two angles', 'other angles', 'remaining angle'
            ])

            # Extract angle value from question if present
            import re
            angle_match = re.search(r'(\d+(?:\.\d+)?)\s*[Â°]?\s*(?:degree|degrees)?', question_text)
            given_angle = float(angle_match.group(1)) if angle_match else None

            logging.info(f"ðŸ” TRIANGLE LABELS: asking_for_base={asking_for_base}, asking_for_height={asking_for_height}, asking_for_hypotenuse={asking_for_hypotenuse}, asking_for_area={asking_for_area}, asking_for_perimeter={asking_for_perimeter}, asking_about_angles={asking_about_angles}, given_angle={given_angle}")

            # ========== RENDER ANGLES IF QUESTION IS ABOUT ANGLES ==========
            if asking_about_angles:
                logging.info(f"ðŸ”º ANGLE QUESTION DETECTED - Rendering angles at vertices")

                # Calculate actual angles using vectors
                def calculate_angle(v1, v2):
                    """Calculate angle between two vectors in degrees"""
                    dot = np.dot(v1, v2)
                    mag1 = np.linalg.norm(v1)
                    mag2 = np.linalg.norm(v2)
                    if mag1 == 0 or mag2 == 0:
                        return 0
                    cos_angle = dot / (mag1 * mag2)
                    cos_angle = max(-1, min(1, cos_angle))  # Clamp
                    return math.degrees(math.acos(cos_angle))

                # Vectors from each vertex
                vec_AB = B - A
                vec_AC = C - A
                vec_BA = A - B
                vec_BC = C - B
                vec_CA = A - C
                vec_CB = B - C

                # Calculate angles at each vertex
                angle_A = calculate_angle(vec_AB, vec_AC)
                angle_B = calculate_angle(vec_BA, vec_BC)
                angle_C = calculate_angle(vec_CA, vec_CB)

                # For right triangle, set angle_A to 90Â°
                if 'right' in triangle_type.lower():
                    angle_A = 90.0
                    # Recalculate the other angles
                    if given_angle:
                        if given_angle != 90:
                            angle_B = given_angle
                            angle_C = 90 - given_angle
                        else:
                            angle_B = 60  # Default
                            angle_C = 30

                logging.info(f"ðŸ“ Calculated angles: A={angle_A:.1f}Â°, B={angle_B:.1f}Â°, C={angle_C:.1f}Â°")

                # Draw angle arcs and labels at vertices
                def draw_angle_arc(ax, vertex, vec1, vec2, angle_deg, label, arc_radius=None, is_right_angle=False):
                    """Draw an angle arc and label at a vertex"""
                    if arc_radius is None:
                        arc_radius = min(base, height) * 0.15

                    # Normalize vectors
                    v1_norm = vec1 / np.linalg.norm(vec1) if np.linalg.norm(vec1) > 0 else vec1
                    v2_norm = vec2 / np.linalg.norm(vec2) if np.linalg.norm(vec2) > 0 else vec2

                    if is_right_angle:
                        # Draw square for right angle
                        square_size = arc_radius * 0.8
                        # Calculate corner points for the right angle square
                        p1 = vertex + v1_norm * square_size
                        p2 = vertex + v1_norm * square_size + v2_norm * square_size
                        p3 = vertex + v2_norm * square_size
                        square = plt.Polygon([vertex, p1, p2, p3], fill=False,
                                           edgecolor='#EF4444', linewidth=2)
                        ax.add_patch(square)
                        # Label position
                        label_pos = vertex + (v1_norm + v2_norm) * arc_radius * 1.8
                        ax.text(label_pos[0], label_pos[1], f'{label}',
                               fontsize=11, fontweight='bold', ha='center', va='center',
                               color='#DC2626',
                               bbox=dict(boxstyle='round,pad=0.2', facecolor='white', alpha=0.8))
                    else:
                        # Draw arc for non-right angles
                        # Calculate start and end angles for the arc
                        start_angle = math.degrees(math.atan2(v1_norm[1], v1_norm[0]))
                        end_angle = math.degrees(math.atan2(v2_norm[1], v2_norm[0]))

                        # Ensure arc goes the short way
                        if end_angle < start_angle:
                            end_angle += 360
                        if end_angle - start_angle > 180:
                            start_angle, end_angle = end_angle, start_angle + 360

                        arc = patches.Arc(vertex, arc_radius*2, arc_radius*2,
                                         angle=0, theta1=min(start_angle, end_angle),
                                         theta2=max(start_angle, end_angle),
                                         color='#3B82F6', linewidth=2)
                        ax.add_patch(arc)

                        # Label position at midpoint of arc
                        mid_angle = math.radians((start_angle + end_angle) / 2)
                        label_pos = vertex + np.array([math.cos(mid_angle), math.sin(mid_angle)]) * arc_radius * 2
                        ax.text(label_pos[0], label_pos[1], f'{label}',
                               fontsize=11, fontweight='bold', ha='center', va='center',
                               color='#1D4ED8',
                               bbox=dict(boxstyle='round,pad=0.2', facecolor='white', alpha=0.8))

                # Draw angle at vertex A
                is_right_at_A = 'right' in triangle_type.lower() and abs(angle_A - 90) < 1
                if given_angle and abs(angle_A - given_angle) < 1:
                    draw_angle_arc(ax, A, vec_AB, vec_AC, angle_A, f'{int(angle_A)}Â°', is_right_angle=is_right_at_A)
                elif is_right_at_A:
                    draw_angle_arc(ax, A, vec_AB, vec_AC, 90, '90Â°', is_right_angle=True)
                else:
                    # Don't show the angle being asked for
                    if not (given_angle and 'other' in question_text):
                        draw_angle_arc(ax, A, vec_AB, vec_AC, angle_A, f'{int(round(angle_A))}Â°', is_right_angle=is_right_at_A)

                # Draw angle at vertex B
                if given_angle and abs(angle_B - given_angle) < 1:
                    draw_angle_arc(ax, B, vec_BA, vec_BC, angle_B, f'{int(angle_B)}Â°')
                elif not (given_angle and 'other' in question_text and abs(angle_B - given_angle) > 1):
                    # Show given angle, hide others if asking for them
                    if given_angle and abs(angle_B - given_angle) < 5:
                        draw_angle_arc(ax, B, vec_BA, vec_BC, angle_B, f'{int(given_angle)}Â°')

                # Draw angle at vertex C
                if given_angle and abs(angle_C - given_angle) < 1:
                    draw_angle_arc(ax, C, vec_CA, vec_CB, angle_C, f'{int(angle_C)}Â°')

                # If we have a given angle, always show it
                if given_angle:
                    # Find which vertex has the given angle and show it
                    if abs(angle_A - given_angle) < 5:
                        draw_angle_arc(ax, A, vec_AB, vec_AC, given_angle, f'{int(given_angle)}Â°', is_right_angle=(given_angle == 90))
                    elif abs(angle_B - given_angle) < 5:
                        draw_angle_arc(ax, B, vec_BA, vec_BC, given_angle, f'{int(given_angle)}Â°')
                    elif abs(angle_C - given_angle) < 5:
                        draw_angle_arc(ax, C, vec_CA, vec_CB, given_angle, f'{int(given_angle)}Â°')
                    else:
                        # Place given angle at B (most visible position for non-right triangles)
                        if 'right' in triangle_type.lower():
                            # For right triangle, given angle is usually at B or C
                            draw_angle_arc(ax, B, vec_BA, vec_BC, given_angle, f'{int(given_angle)}Â°')
                            draw_angle_arc(ax, A, vec_AB, vec_AC, 90, '90Â°', is_right_angle=True)
                        else:
                            draw_angle_arc(ax, B, vec_BA, vec_BC, given_angle, f'{int(given_angle)}Â°')

                # Skip side labels for angle questions
                logging.info(f"âš ï¸ Skipping side labels - this is an angle question")

            else:
                # Original side label logic (not an angle question)
                # Only show labels for known values (not what's being asked)
                # SKIP generic base/height labels for special triangle types (they have custom labels below)
                is_special_triangle = any(t in triangle_type.lower() for t in ['equilateral', 'isosceles', 'scalene'])

                if base and not asking_for_base and not is_special_triangle:
                    ax.text(base/2, -0.8, f'Base = {base} cm',
                           fontsize=12, ha='center', fontweight='bold')
                    logging.info(f"âœ… Showing base label: {base} cm")

                if height and not asking_for_height and not is_special_triangle:
                    ax.text(-0.8, height/2, f'Height = {height} cm',
                           fontsize=12, ha='center', va='center',
                           rotation=90, fontweight='bold')
                    logging.info(f"âœ… Showing height label: {height} cm")
                elif not is_special_triangle:
                    logging.info(f"âš ï¸ Hiding height label (question asks for it)")

                if hypotenuse and not asking_for_hypotenuse:
                    # Calculate hypotenuse position (midpoint of hypotenuse line)
                    hyp_mid_x = base/2
                    hyp_mid_y = height/2
                    ax.text(hyp_mid_x + 1, hyp_mid_y, f'Hypotenuse = {hypotenuse} cm',
                           fontsize=12, ha='left', fontweight='bold',
                           rotation=-35)  # Angle the label along the hypotenuse
                    logging.info(f"âœ… Showing hypotenuse label: {hypotenuse} cm")

                # Show side labels for equilateral, isosceles, and scalene triangles
                if 'equilateral' in triangle_type.lower() and not asking_for_side and not asking_for_perimeter:
                    side_a = measurements.get('side_a', 0)
                    if side_a:
                        # Show one side label (all sides are equal)
                        ax.text(base/2, -0.8, f'Side = {round(side_a, 2)} cm',
                               fontsize=12, ha='center', fontweight='bold')

                elif 'isosceles' in triangle_type.lower() and not asking_for_side and not asking_for_perimeter:
                    side_a = measurements.get('side_a', 0)
                    side_c = measurements.get('side_c', measurements.get('base', 0))
                    if side_a and side_c:
                        # Show equal sides and base
                        mid_ac = (A + C) / 2
                        ax.text(mid_ac[0] - 0.8, mid_ac[1], f'{round(side_a, 2)} cm',
                               fontsize=11, ha='right', fontweight='bold')
                        mid_bc = (B + C) / 2
                        ax.text(mid_bc[0] + 0.8, mid_bc[1], f'{round(side_a, 2)} cm',
                               fontsize=11, ha='left', fontweight='bold')
                        if not asking_for_base:
                            ax.text(base/2, -0.8, f'Base = {round(side_c, 2)} cm',
                                   fontsize=12, ha='center', fontweight='bold')

                elif 'scalene' in triangle_type.lower() and not asking_for_side and not asking_for_perimeter:
                    side_a = measurements.get('side_a', 0)
                    side_b = measurements.get('side_b', 0)
                    side_c = measurements.get('side_c', 0)
                    if side_a and side_b and side_c:
                        # Show all three sides - NO "Base =" label for scalene!
                        ax.text(base/2, -0.8, f'{round(side_c, 2)} cm',
                               fontsize=11, ha='center', fontweight='bold', color='#1F2937')
                        mid_ac = (A + C) / 2
                        ax.text(mid_ac[0] - 0.8, mid_ac[1], f'{round(side_b, 2)} cm',
                               fontsize=11, ha='right', fontweight='bold', color='#1F2937')
                        mid_bc = (B + C) / 2
                        ax.text(mid_bc[0] + 0.8, mid_bc[1], f'{round(side_a, 2)} cm',
                               fontsize=11, ha='left', fontweight='bold', color='#1F2937')
                        logging.info(f"âœ… Showing scalene sides: {side_a}, {side_b}, {side_c} cm")
                    else:
                        logging.warning(f"âš ï¸ Scalene triangle missing sides! side_a={side_a}, side_b={side_b}, side_c={side_c}")

            # Set limits and display
            margin = max(base, height) * 0.2
            ax.set_xlim(-margin, base + margin)
            ax.set_ylim(-margin, height + margin)
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.3)
            ax.set_title('Triangle', fontsize=16, fontweight='bold')
            
            return {'success': True, 'image': self._figure_to_base64(fig)}
            
        except Exception as e:
            logging.error(f"Error rendering triangle: {e}")
            return {'success': False, 'error': str(e)}

    def render_polygon_comprehensive(self, measurements, hide_answer=False, shape_type='polygon'):
        """FIXED: Render polygons correctly with shape_type support"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.patches import RegularPolygon
            import numpy as np
            import math

            fig, ax = plt.subplots(figsize=(8, 8), dpi=100)
            fig.patch.set_facecolor('white')
            ax.set_facecolor('white')

            # Determine number of sides from shape_type if not in measurements
            shape_to_sides = {
                'triangle': 3,
                'square': 4,
                'pentagon': 5,
                'hexagon': 6,
                'heptagon': 7,
                'octagon': 8,
                'nonagon': 9,
                'decagon': 10,
                'dodecagon': 12
            }

            # Get sides from measurements, or infer from shape_type
            sides = measurements.get('sides', measurements.get('num_sides', None))
            if sides is None and shape_type:
                sides = shape_to_sides.get(shape_type.lower(), 6)
            if sides is None:
                sides = 6  # Default to hexagon

            sides = int(sides)
            print(f"ðŸ”· POLYGON: Rendering {shape_type} with {sides} sides")

            # Get side_length from measurements for labeling
            side_length = measurements.get('side_length', measurements.get('side', None))

            # Scale radius based on side_length if provided, otherwise use standard
            if side_length:
                # For regular polygon: side_length = 2 * radius * sin(pi/n)
                radius = side_length / (2 * math.sin(math.pi / sides))
            else:
                radius = 3  # Standard radius for display

            # Create polygon
            polygon = RegularPolygon((0, 0), sides, radius=radius,
                                   facecolor='#10B981', alpha=0.3,
                                   edgecolor='#10B981', linewidth=3)
            ax.add_patch(polygon)

            # Add vertex points and labels
            angles = np.linspace(0, 2*np.pi, sides, endpoint=False) + np.pi/2
            vertices = [(radius * np.cos(a), radius * np.sin(a)) for a in angles]

            for i, vertex in enumerate(vertices):
                ax.plot(vertex[0], vertex[1], 'o', color='#3B82F6', markersize=8)
                ax.text(vertex[0] * 1.15, vertex[1] * 1.15, f'V{i+1}', fontsize=10, fontweight='bold')

            # Add center point
            ax.plot(0, 0, 'o', color='#F59E0B', markersize=6)
            ax.text(0.2, -0.2, 'O', fontsize=10, ha='center', fontweight='bold')

            # Add side length label if available
            if side_length:
                # Label one side with its length
                mid_x = (vertices[0][0] + vertices[1][0]) / 2
                mid_y = (vertices[0][1] + vertices[1][1]) / 2
                # Get unit from measurements or default to 'cm'
                unit = measurements.get('unit', 'cm')
                ax.text(mid_x + 0.3, mid_y, f'{side_length} {unit}', fontsize=11, fontweight='bold',
                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.9))

            ax.set_xlim(-radius - 1.5, radius + 1.5)
            ax.set_ylim(-radius - 1.5, radius + 1.5)
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.3)

            # Polygon names
            polygon_names = {3: 'Triangle', 4: 'Square', 5: 'Pentagon', 6: 'Hexagon',
                           7: 'Heptagon', 8: 'Octagon', 9: 'Nonagon', 10: 'Decagon', 12: 'Dodecagon'}
            shape_name = polygon_names.get(sides, f'{sides}-sided Polygon')
            ax.set_title(shape_name, fontsize=16, fontweight='bold', color='#10B981')

            return {'success': True, 'image': self._figure_to_base64(fig), 'answer_hidden': True}

        except Exception as e:
            print(f"Error rendering polygon: {e}")
            import traceback
            traceback.print_exc()
            return {'success': False, 'error': str(e)}

    # FIX #1: CORRECTED TRAPEZIUM RENDERING (NO ANSWER VALUES)
    def render_trapezium_comprehensive(self, measurements, hide_answer=False):
        """FIXED: Render trapezium correctly with proper measurements extraction"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.patches import Polygon
            import numpy as np
            
            fig, ax = plt.subplots(figsize=(8, 6), dpi=100)
            fig.patch.set_facecolor('white')
            ax.set_facecolor('white')
            
            # Extract measurements more intelligently
            parallel_side1 = measurements.get('parallel_side1', measurements.get('base', 12))
            parallel_side2 = measurements.get('parallel_side2', measurements.get('top', 8))
            height = measurements.get('height', 6)
            
            # If we have specific measurements, use them
            if 'length' in measurements:
                parallel_side1 = max(measurements.get('length', 12), measurements.get('width', 8))
                parallel_side2 = min(measurements.get('length', 12), measurements.get('width', 8))
            
            print(f"ðŸ”· TRAPEZIUM: side1={parallel_side1}, side2={parallel_side2}, height={height}")
            
            # Calculate trapezium vertices
            offset = abs(parallel_side1 - parallel_side2) / 2
            vertices = np.array([
                [0, 0],                          # bottom left
                [parallel_side1, 0],             # bottom right
                [parallel_side1 - offset, height], # top right
                [offset, height]                 # top left
            ])
            
            # Draw trapezium
            trapezium = Polygon(vertices, closed=True, fill=True, facecolor='#10B981', 
                               alpha=0.3, edgecolor='#10B981', linewidth=3)
            ax.add_patch(trapezium)
            
            # Add vertex labels
            labels = ['A', 'B', 'C', 'D']
            for i, (vertex, label) in enumerate(zip(vertices, labels)):
                ax.plot(vertex[0], vertex[1], 'o', color='#3B82F6', markersize=8)
                ax.text(vertex[0] + 0.2, vertex[1] + 0.2, label, fontsize=12, fontweight='bold')
            
            # Add dimension labels
            ax.text(parallel_side1/2, -0.5, f'{parallel_side1} cm', fontsize=11, ha='center', fontweight='bold')
            ax.text((offset + parallel_side1 - offset)/2, height + 0.3, f'{parallel_side2} cm', 
                   fontsize=11, ha='center', fontweight='bold')
            
            # Height line (dashed) - ALWAYS SHOW
            ax.plot([offset, offset], [0, height], '--', color='#F59E0B', linewidth=2)
            ax.text(offset - 0.5, height/2, f'{height} cm', fontsize=11, ha='center', 
                   va='center', rotation=90, fontweight='bold')
            
            # NEVER SHOW AREA IN QUIZ QUESTIONS
            # Area calculation removed to prevent spoilers
            
            margin = max(parallel_side1, height) * 0.2
            ax.set_xlim(-margin, parallel_side1 + margin)
            ax.set_ylim(-margin, height + margin)
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.3)
            ax.set_title('Trapezium', fontsize=16, fontweight='bold')
            
            return {'success': True, 'image': self._figure_to_base64(fig), 'answer_hidden': True}
            
        except Exception as e:
            print(f"Error rendering trapezium: {e}")
            return {'success': False, 'error': str(e)}
    
    def render_parallel_lines_comprehensive(self, measurements, hide_answer=False, question_text=''):
        """Render parallel lines with slanted transversal, angle labels, and vertex labels"""
        try:
            import matplotlib.pyplot as plt
            import numpy as np
            from matplotlib.patches import Arc
            
            fig, ax = plt.subplots(figsize=(10, 7), dpi=100)
            fig.patch.set_facecolor('white')
            ax.set_facecolor('white')
            
            # Get angle from measurements
            angle = measurements.get('angle1', measurements.get('angle', 60))
            
            logging.info(f"ðŸŽ¨ RENDERING PARALLEL LINES: angle={angle}Â°, question={question_text[:50]}...")
            
            # Parallel lines
            y1, y2 = 2, 4
            distance = y2 - y1
            
            # Draw parallel lines
            ax.plot([0, 8], [y1, y1], color='#10B981', linewidth=3, 
                   label='Line 1', zorder=1)
            ax.plot([0, 8], [y2, y2], color='#3B82F6', linewidth=3, 
                   label='Line 2', zorder=1)
            
            # Calculate transversal with angle
            x_intersect = 3
            angle_rad = np.radians(angle)
            slope = np.tan(angle_rad)
            
            # Transversal endpoints
            x_start = 1
            x_end = 7
            y_start = y1 - slope * (x_intersect - x_start)
            y_end = y1 + slope * (x_end - x_intersect)
            
            # Draw transversal
            ax.plot([x_start, x_end], [y_start, y_end], 
                   color='#F59E0B', linewidth=3, linestyle='--', 
                   label='Transversal', zorder=2)
            
            # Mark intersection points
            x_int_1 = x_intersect
            y_int_1 = y1
            
            x_int_2 = x_int_1 + (y2 - y1) / slope if slope != 0 else x_int_1
            y_int_2 = y2
            
            ax.plot(x_int_1, y_int_1, 'ro', markersize=8, zorder=3)
            ax.plot(x_int_2, y_int_2, 'ro', markersize=8, zorder=3)
            
            # ========== VERTEX LABELS FOR PARALLELOGRAM ==========
            if 'parallelogram' in question_text.lower():
                logging.info(f"ðŸ“ Adding vertex labels for parallelogram question")
                
                # Parallelogram vertices
                # A = top-left, B = top-right, C = bottom-right, D = bottom-left
                A_x, A_y = 1, y2
                B_x, B_y = 7, y2
                D_x, D_y = 1, y1
                C_x, C_y = 7, y1
                
                # Draw vertex circles and labels
                ax.text(A_x - 0.3, A_y + 0.3, 'A', fontsize=16, fontweight='bold',
                       ha='center', va='center',
                       bbox=dict(boxstyle='circle,pad=0.3', facecolor='white', 
                                edgecolor='#EF4444', linewidth=2.5))
                ax.text(B_x + 0.3, B_y + 0.3, 'B', fontsize=16, fontweight='bold',
                       ha='center', va='center',
                       bbox=dict(boxstyle='circle,pad=0.3', facecolor='white', 
                                edgecolor='#EF4444', linewidth=2.5))
                ax.text(C_x + 0.3, C_y - 0.3, 'C', fontsize=16, fontweight='bold',
                       ha='center', va='center',
                       bbox=dict(boxstyle='circle,pad=0.3', facecolor='white', 
                                edgecolor='#EF4444', linewidth=2.5))
                ax.text(D_x - 0.3, D_y - 0.3, 'D', fontsize=16, fontweight='bold',
                       ha='center', va='center',
                       bbox=dict(boxstyle='circle,pad=0.3', facecolor='white', 
                                edgecolor='#EF4444', linewidth=2.5))
                
                logging.info(f"âœ… Added vertex labels: A, B, C, D")
            # ========== END VERTEX LABELS ==========
            
            # Draw angle arcs and labels
            arc_radius = 0.6
            
            # First angle arc
            arc1 = Arc((x_int_1, y_int_1), 2*arc_radius, 2*arc_radius,
                      angle=0, theta1=0, theta2=angle,
                      color='#EF4444', linewidth=3, zorder=4)
            ax.add_patch(arc1)
            
            # First angle label (always show)
            label_angle = angle / 2
            label_x = x_int_1 + arc_radius * 1.8 * np.cos(np.radians(label_angle))
            label_y = y_int_1 + arc_radius * 1.8 * np.sin(np.radians(label_angle))
            ax.text(label_x, label_y, f'{int(angle)}Â°',
                   fontsize=14, fontweight='bold', color='#EF4444',
                   bbox=dict(boxstyle='round,pad=0.4', 
                            facecolor='white', alpha=0.9))
            
            # Second angle arc
            arc2 = Arc((x_int_2, y_int_2), 2*arc_radius, 2*arc_radius,
                      angle=0, theta1=180, theta2=180+angle,
                      color='#8B5CF6', linewidth=3, zorder=4)
            ax.add_patch(arc2)
            
            # Second angle label - HIDE if hide_answer=True
            label_x2 = x_int_2 - arc_radius * 1.8 * np.cos(np.radians(label_angle))
            label_y2 = y_int_2 - arc_radius * 1.8 * np.sin(np.radians(label_angle))
            
            if not hide_answer:
                # Show the answer
                ax.text(label_x2, label_y2, f'{int(angle)}Â°',
                       fontsize=14, fontweight='bold', color='#8B5CF6',
                       bbox=dict(boxstyle='round,pad=0.4', 
                                facecolor='white', alpha=0.9))
                logging.info(f"âœ… Showing second angle: {angle}Â°")
            else:
                # Hide the answer - show "?"
                ax.text(label_x2, label_y2, '?',
                       fontsize=18, fontweight='bold', color='#8B5CF6',
                       bbox=dict(boxstyle='round,pad=0.4', 
                                facecolor='white', alpha=0.9))
                logging.info(f"âœ… Hiding second angle (answer)")
            
            # Distance marker
            ax.plot([0.5, 0.5], [y1, y2], 'k-', linewidth=1.5, alpha=0.5)
            ax.text(0.2, (y1+y2)/2, f'd = {distance} cm',
                   fontsize=10, ha='center', va='center',
                   rotation=90, fontweight='bold', alpha=0.7)
            
            # Direction arrows
            ax.annotate('', xy=(7.8, y1), xytext=(7.3, y1),
                       arrowprops=dict(arrowstyle='->', lw=2, color='#10B981'))
            ax.annotate('', xy=(7.8, y2), xytext=(7.3, y2),
                       arrowprops=dict(arrowstyle='->', lw=2, color='#3B82F6'))
            
            ax.set_xlim(-0.5, 8.5)
            ax.set_ylim(0.5, 5.5)
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.3)
            ax.legend(loc='upper right')
            ax.set_title('Parallel Lines with Transversal', 
                        fontsize=16, fontweight='bold')
            
            logging.info(f"âœ… Successfully rendered parallel lines")
            
            return {'success': True, 'image': self._figure_to_base64(fig)}
        
        except Exception as e:
            logging.error(f"âŒ Error rendering parallel lines: {e}")
            import traceback
            traceback.print_exc()
            return {'success': False, 'error': str(e)}

    def render_angles_comprehensive(self, angle_type, measurements, hide_answer=False):
        """Render complementary or supplementary angles"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.patches import Arc
            import numpy as np
            
            fig, ax = plt.subplots(figsize=(8, 6), dpi=100)
            fig.patch.set_facecolor('white')
            ax.set_facecolor('white')
            
            if angle_type == 'complementary_angles':
                angle1 = measurements.get('angle1', 30)
                angle2 = 90 - angle1
                total = 90
            else:  # supplementary_angles
                angle1 = measurements.get('angle1', 60)
                angle2 = 180 - angle1
                total = 180
            
            # Draw rays
            ax.plot([0, 3], [0, 0], 'k-', linewidth=2)
            ax.plot([0, 3*np.cos(np.radians(angle1))], [0, 3*np.sin(np.radians(angle1))], 'k-', linewidth=2)
            if angle_type == 'supplementary_angles':
                ax.plot([0, -3], [0, 0], 'k-', linewidth=2)
            else:
                ax.plot([0, 0], [0, 3], 'k-', linewidth=2)
            
            # Draw angle arcs
            arc1 = Arc((0, 0), 1, 1, angle=0, theta1=0, theta2=angle1, color='#10B981', linewidth=3)
            ax.add_patch(arc1)
            
            if angle_type == 'supplementary_angles':
                arc2 = Arc((0, 0), 1.2, 1.2, angle=0, theta1=angle1, theta2=180, color='#3B82F6', linewidth=3)
            else:
                arc2 = Arc((0, 0), 1.2, 1.2, angle=0, theta1=angle1, theta2=90, color='#3B82F6', linewidth=3)
            ax.add_patch(arc2)
            
            # Add angle labels
            ax.text(0.7, 0.2, f'{angle1}Â°', fontsize=12, fontweight='bold', color='#10B981')
            if angle_type == 'supplementary_angles':
                ax.text(-0.5, 0.3, f'{angle2}Â°', fontsize=12, fontweight='bold', color='#3B82F6')
            else:
                ax.text(0.2, 0.7, f'{angle2}Â°', fontsize=12, fontweight='bold', color='#3B82F6')
            
            if not hide_answer:
                ax.text(0, -1, f'{angle1}Â° + {angle2}Â° = {total}Â°', 
                       fontsize=12, fontweight='bold', ha='center',
                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.9))
            
            ax.set_xlim(-1, 4)
            ax.set_ylim(-1.5, 4)
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.3)
            ax.set_title(f'{angle_type.replace("_", " ").title()}', fontsize=16, fontweight='bold')
            
            return {'success': True, 'image': self._figure_to_base64(fig), 'answer_hidden': hide_answer}
            
        except Exception as e:
            print(f"Error rendering angles: {e}")
            return {'success': False, 'error': str(e)}

    def render_net_comprehensive(self, net_type, measurements, hide_answer=False):
        """Render nets of 3D shapes"""
        try:
            import matplotlib.pyplot as plt
            from matplotlib.patches import Rectangle
            
            fig, ax = plt.subplots(figsize=(10, 8), dpi=100)
            fig.patch.set_facecolor('white')
            ax.set_facecolor('white')
            
            if net_type == 'cube_net' or 'cube' in net_type:
                # Cube net - cross shape
                squares = [
                    (1, 2),  # top
                    (0, 1), (1, 1), (2, 1), (3, 1),  # middle row
                    (1, 0)   # bottom
                ]
                
                for i, (x, y) in enumerate(squares):
                    square = Rectangle((x, y), 1, 1, fill=True, 
                                     facecolor='#10B981', alpha=0.6,
                                     edgecolor='#1F2937', linewidth=2)
                    ax.add_patch(square)
                    
                    # Add face labels
                    labels = ['Top', 'Left', 'Front', 'Right', 'Back', 'Bottom']
                    ax.text(x + 0.5, y + 0.5, labels[i], ha='center', va='center',
                           fontsize=10, fontweight='bold')
                
                ax.set_xlim(-0.5, 4.5)
                ax.set_ylim(-0.5, 3.5)
                ax.set_title('Net of a Cube', fontsize=16, fontweight='bold')
                
            else:
                # Default to cube net
                ax.text(0.5, 0.5, 'Net diagram', ha='center', va='center', fontsize=16)
                ax.set_xlim(0, 1)
                ax.set_ylim(0, 1)
            
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.3)
            
            return {'success': True, 'image': self._figure_to_base64(fig), 'answer_hidden': hide_answer}
            
        except Exception as e:
            print(f"Error rendering net: {e}")
            return {'success': False, 'error': str(e)}

    
    def _render_default_shape(self) -> Dict:
        """Render default shape when no specific shape is detected"""
        try:
            import matplotlib.pyplot as plt
            fig, ax = plt.subplots(1, 1, figsize=(6, 6))
            ax.text(0.5, 0.5, 'Geometric Shape', fontsize=16, ha='center', va='center')
            ax.set_xlim(0, 1)
            ax.set_ylim(0, 1)
            
            return {
                'success': True,
                'image': self._figure_to_base64(fig),
                'measurements': {},
                'answer_hidden': False
            }
        except Exception as e:
            # Handle any errors that might occur
            return {
                'success': False,
                'error': str(e),
                'measurements': {},
                'answer_hidden': False
            }
        

    def _figure_to_base64(self, fig):
        """Convert matplotlib figure to base64 string"""
        try:
            import io
            import base64
            import matplotlib.pyplot as plt
            
            buffer = io.BytesIO()
            fig.savefig(buffer, format='png', bbox_inches='tight', 
                        dpi=100, facecolor='white', edgecolor='none')
            buffer.seek(0)
            image_png = buffer.getvalue()
            buffer.close()
            plt.close(fig)
            
            graphic = base64.b64encode(image_png)
            graphic = graphic.decode('utf-8')
            return f"data:image/png;base64,{graphic}"
            
        except Exception as e:
            print(f"Error converting figure to base64: {e}")
            try:
                import matplotlib.pyplot as plt
                plt.close(fig)
            except:
                pass
            return "data:image/png;base64,"

    def create_figure(self, figsize=None, projection=None):
        """Create a clean matplotlib figure - HELPER METHOD"""
        try:
            import matplotlib.pyplot as plt
            
            if figsize is None:
                figsize = (8, 6)
            
            if projection == '3d':
                fig = plt.figure(figsize=figsize, dpi=100)
                ax = fig.add_subplot(111, projection='3d')
            else:
                fig, ax = plt.subplots(figsize=figsize, dpi=100)
            
            # Set white background
            fig.patch.set_facecolor('white')
            if hasattr(ax, 'set_facecolor'):
                ax.set_facecolor('white')
            
            return fig, ax
            
        except Exception as e:
            print(f"âŒ Error creating figure: {e}")
            # Return basic figure as fallback
            import matplotlib.pyplot as plt
            return plt.subplots(figsize=(8, 6))

    def get_colors(self):
        """Get color scheme for shapes - HELPER METHOD"""
        return {
            'primary': '#10B981',
            'secondary': '#3B82F6', 
            'accent': '#F59E0B',
            'text': '#1F2937',
            'light_blue': '#E0F2FE',
            'light_green': '#ECFDF5',
            'light_orange': '#FEF3C7',
            'red': '#EF4444',
            'purple': '#8B5CF6',
            'pink': '#EC4899'
        }

@app.route('/api/geometry/render-sphere', methods=['POST'])
def render_sphere_enhanced_comprehensive_fix():
    """Enhanced sphere endpoint - same endpoint, enhanced functionality"""
    try:
        data = request.get_json()
        data['type'] = 'sphere'
        return render_shape_enhanced_comprehensive_fix()
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    
@app.route('/api/geometry/render-cylinder', methods=['POST'])
def render_cylinder_enhanced_comprehensive_fix():
    """Enhanced cylinder endpoint - same endpoint, enhanced functionality"""
    try:
        data = request.get_json()
        data['type'] = 'cylinder'
        return render_shape_enhanced_comprehensive_fix()
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/geometry/render-trapezium', methods=['POST'])
def render_trapezium_enhanced():
    """Enhanced trapezium endpoint"""
    try:
        data = request.get_json()
        data['type'] = 'trapezium'
        return render_shape_enhanced_comprehensive_fix()
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
@app.route('/api/geometry/render-circle', methods=['POST'])
def render_circle_enhanced():
    """Enhanced circle endpoint"""
    try:
        data = request.get_json()
        data['type'] = 'circle'
        
        # Use the lockout manager to validate and process
        if 'GEOMETRY_LOCKOUT_MANAGER' in app.config:
            lockout_manager = app.config['GEOMETRY_LOCKOUT_MANAGER']
            result = lockout_manager.generateCorrectGeometryData('circles', data.get('question_text', ''))
            return jsonify({'success': True, 'geometry_data': result})
        else:
            return jsonify({'success': False, 'error': 'Lockout manager not initialized'}), 500
            
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

print("ðŸŽ¯ ENHANCED COMPREHENSIVE GEOMETRY FIX LOADED!")

# FIXED INITIALIZATION - Only initialize once
print("ðŸ”§ Initializing geometry system...")

try:
    # Initialize lockout manager (main system)
    lockout_manager = GeometryLockoutManager()
    app.config['GEOMETRY_LOCKOUT_MANAGER'] = lockout_manager
    print("âœ… Geometry strict lockout manager loaded")
    
    # Try renderer only if needed
    renderer = None
    try:
        if 'EnhancedFixedGeometryRenderer' in globals():
            renderer = EnhancedFixedGeometryRenderer()
            app.config['GEOMETRY_RENDERER'] = renderer
            print("âœ… Enhanced geometry renderer loaded")
    except Exception as e:
        print(f"âš ï¸  Renderer initialization skipped: {e}")
        
except Exception as e:
    print(f"âŒ Error initializing geometry system: {e}")

print("ðŸ”’ Geometry strict lockout system ready!")

def clean_mathematical_notation(text):
    """Clean and format mathematical notation"""
    if not text:
        return text

    # Replace common notation
    text = text.replace('^2', 'Â²')
    text = text.replace('^3', 'Â³')
    text = text.replace('**2', 'Â²')
    text = text.replace('**3', 'Â³')
    text = text.replace('*', 'Ã—')
    text = text.replace('sqrt(', 'âˆš(')
    text = text.replace('pi', 'Ï€')
    text = text.replace('Pi', 'Ï€')

    return text

# UPDATED FLASK ENDPOINT WITH BEAUTIFUL STYLING
@app.route('/api/geometry/render-triangle', methods=['POST'])
def render_beautiful_triangle_no_spoilers():
    """Beautiful triangle rendering with strict no-spoiler enforcement"""
    try:
        data = request.get_json()
        print(f"ðŸŽ¨ Beautiful triangle render request: {data}")
        
        # Extract question context
        question_context = data.get('question_context', {})
        question_text = question_context.get('text', '')
        
        if not question_text:
            return jsonify({
                'success': False,
                'error': 'No question text provided'
            }), 400
        
        # Create beautiful styled renderer
        renderer = StyledNoSpoilerTriangleRenderer()
        result = renderer.render_beautiful_triangle_no_spoilers(question_text)
        
        print(f"âœ… Beautiful triangle rendered - shown: {result['measurements_shown']}, hidden: {result['measurements_hidden']}")
        
        return jsonify(result)
    
    except Exception as e:
        print(f"âŒ Error in beautiful triangle rendering: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500




# Register blueprint with Flask app
def register_geometry_api(app):
    """Register the geometry API blueprint with Flask app"""
    app.register_blueprint(geometry_api)
    
    # Add required dependencies info
    print("Geometry Shape Renderer API registered successfully!")
    print("Required Python packages: matplotlib, numpy, plotly, pillow")
    print("Install with: pip install matplotlib numpy plotly pillow kaleido")

# Function to validate and fix geometry questions
def validate_and_fix_geometry_questions(questions, question_types, numQuestions, geometry_types):
    """Validate and fix geometry questions to ensure they meet requirements"""
    
    fixed_questions = []
    
    for question in questions:
        # Ensure question has required fields
        if not question.get('id'):
            question['id'] = str(uuid.uuid4())
        
        if not question.get('text'):
            continue  # Skip invalid questions
        
        # Clean mathematical notation
        question['text'] = clean_mathematical_notation(question['text'])
        
        # Fix question type if invalid
        if question.get('type') not in question_types:
            if 'multiple_choice' in question_types:
                question['type'] = 'multiple_choice'
            else:
                question['type'] = question_types[0]
        
        # Ensure options exist for multiple choice and true/false
        if question['type'] in ['multiple_choice', 'true_false']:
            if not question.get('options') or not isinstance(question['options'], list):
                # Create default options based on type
                if question['type'] == 'true_false':
                    question['options'] = [
                        {"text": "True", "isCorrect": True},
                        {"text": "False", "isCorrect": False}
                    ]
                else:
                    # Try to extract answer from question text for better defaults
                    question['options'] = [
                        {"text": "Option A", "isCorrect": True},
                        {"text": "Option B", "isCorrect": False},
                        {"text": "Option C", "isCorrect": False},
                        {"text": "Option D", "isCorrect": False}
                    ]
            
            # Clean option text
            for option in question['options']:
                if 'text' in option:
                    option['text'] = clean_mathematical_notation(option['text'])
            
            # Ensure at least one correct answer
            has_correct = any(opt.get('isCorrect') for opt in question['options'])
            if not has_correct and question['options']:
                question['options'][0]['isCorrect'] = True
        
        fixed_questions.append(question)
    
    # If we don't have enough questions, generate more
    if len(fixed_questions) < numQuestions:
        missing_count = numQuestions - len(fixed_questions)
        for i in range(missing_count):
            geometric_question = create_fallback_geometry_question(i + len(fixed_questions), geometry_types)
            fixed_questions.append(geometric_question)
    
    # Trim to exact number if we have too many
    if len(fixed_questions) > numQuestions:
        fixed_questions = fixed_questions[:numQuestions]
    
    return fixed_questions



def fix_database_connection_warning():
    """Fix the database connection warning about textual SQL expressions"""
    try:
        # Import text from sqlalchemy
        from sqlalchemy import text
        
        # Replace any direct string SQL with text() wrapper
        # This fixes the warning: Textual SQL expression 'SELECT 1' should be explicitly declared as text('SELECT 1')
        
        # If you have any raw SQL queries, wrap them like this:
        # db.session.execute("SELECT 1")  # âŒ OLD
        # db.session.execute(text("SELECT 1"))  # âœ… FIXED
        
        logging.info("âœ… Database connection warning fixed")
        
    except Exception as e:
        logging.warning(f"Could not fix database connection warning: {e}")
fix_database_connection_warning()

print("âœ… SESSION EXPIRATION FIX APPLIED!")
print("ðŸ”§ FIXES:")
print("   âœ… Fixed function signature mismatch")
print("   âœ… Proper current_user parameter handling")
print("   âœ… Removed problematic function call")
print("   âœ… Fixed database connection warning")
print("   âœ… Enhanced error handling and logging")

@app.route('/api/get-geometry-quiz/<quiz_id>', methods=['GET'])
def get_geometry_quiz(quiz_id):
    try:
        logger.info(f"Request: GET /api/get-geometry-quiz/{quiz_id}")
        
        # Add connection retry logic
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                # Fetch the quiz from database
                quiz = GeometryQuiz.query.filter_by(id=quiz_id).first()
                
                if not quiz:
                    logger.warning(f"Geometry quiz not found: {quiz_id}")
                    return jsonify({'error': 'Quiz not found'}), 404
                
                # Parse the questions JSON
                questions = json.loads(quiz.questions_json) if quiz.questions_json else []
                
                quiz_data = {
                    'id': quiz.id,
                    'title': quiz.title,
                    'topic': quiz.topic,
                    'grade_level': quiz.grade_level,
                    'time_limit': quiz.time_limit,
                    'mode': quiz.mode,
                    'questions': questions
                }
                
                logger.info(f"Successfully retrieved geometry quiz: {quiz_id}")
                return jsonify(quiz_data), 200
                
            except Exception as e:
                retry_count += 1
                logger.error(f"Database error (attempt {retry_count}): {str(e)}")
                
                if retry_count < max_retries:
                    # Wait before retrying
                    time.sleep(1)
                    # Try to rollback and recreate connection
                    try:
                        db.session.rollback()
                        db.session.remove()
                    except:
                        pass
                else:
                    raise e
                    
    except Exception as e:
        logger.error(f"Error getting geometry quiz: {str(e)}")
        return jsonify({'error': f'Failed to load quiz: {str(e)}'}), 500


@app.route('/api/submit-geometry-quiz', methods=['POST'])
def submit_geometry_quiz():
    try:
        data = request.get_json()
        
        quiz_id = data.get('quiz_id')
        student_name = data.get('student_name', 'Anonymous')
        score = data.get('score', 0)
        max_score = data.get('max_score', 0)
        answers = data.get('answers', {})
        time_taken = data.get('time_taken', 0)
        
        if not quiz_id:
            return jsonify({'error': 'Quiz ID is required'}), 400
        
        # Get the quiz to verify it exists
        quiz = GeometryQuiz.query.filter_by(id=quiz_id).first()
        if not quiz:
            return jsonify({'error': 'Quiz not found'}), 404
        
        # Create the submission record
        submission = GeometryQuizSubmission(
            id=str(uuid.uuid4()),
            quiz_id=quiz_id,
            student_name=student_name,
            score=float(score),
            max_score=float(max_score),
            answers_json=json.dumps(answers),
            time_taken=int(time_taken),
            submitted_at=datetime.utcnow()
        )
        
        # Save the submission to the database
        db.session.add(submission)
        db.session.commit()
        
        logger.info(f"Geometry quiz submission saved: {quiz_id} - {student_name} - Score: {score}/{max_score}")
        
        return jsonify({
            'message': 'Geometry quiz submitted successfully',
            'submission_id': submission.id,
            'score': score,
            'max_score': max_score,
            'percentage': (score / max_score * 100) if max_score > 0 else 0
        }), 201
        
    except Exception as e:
        logger.error(f"Error submitting geometry quiz: {str(e)}")
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/api/geometry-quiz//print', methods=['GET'])
@token_required
def print_geometry_quiz(current_user, quiz_id):
    """Generate a printable version of a geometry quiz"""
    try:
        # Get the quiz from database
        quiz = GeometryQuiz.query.filter_by(
            id=quiz_id,
            user_id=current_user.id
        ).first()
        
        if not quiz:
            return jsonify({'error': 'Quiz not found'}), 404
        
        # Get questions for this quiz
        questions = GeometryQuestion.query.filter_by(quiz_id=quiz_id).all()
        
        if not questions:
            return jsonify({'error': 'No questions found for this quiz'}), 404
        
        # Format questions for printing
        formatted_questions = []
        for question in questions:
            q_data = {
                'id': question.id,
                'text': question.text,
                'type': question.type,
                'options': json.loads(question.options) if question.options else [],
                'shape_data': json.loads(question.shape_data) if question.shape_data else None
            }
            formatted_questions.append(q_data)
        
        # Generate HTML template for printing
        html_template = generate_geometry_print_template(
            quiz=quiz,
            questions=formatted_questions
        )
        
        return html_template, 200, {'Content-Type': 'text/html'}
        
    except Exception as e:
        logger.error(f"Error generating print version: {str(e)}")
        return jsonify({'error': str(e)}), 500


def generate_geometry_print_template(quiz, questions):
    """Generate HTML template for geometry quiz printing"""
    
    questions_html = ''
    for idx, question in enumerate(questions, 1):
        # Generate shape HTML if available
        shape_html = ''
        if question.get('shape_data'):
            shape_html = f'''
                
                    
                        ðŸ“ Geometry Shape: {question['shape_data'].get('shape_type', 'Geometric Figure')}
                    
                    
                        (Shape diagram included in test)
                    
                
            '''
        
        # Generate options HTML
        options_html = ''
        if question['type'] in ['multiple_choice', 'true_false']:
            options_html = ''
            for option in question['options']:
                options_html += f'''
                    
                        
                        {option['text']}
                    
                '''
            options_html += ''
        elif question['type'] == 'select_all':
            options_html = 'Select all that apply:'
            for option in question['options']:
                options_html += f'''
                    
                        
                        {option['text']}
                    
                '''
            options_html += ''
        elif question['type'] == 'paragraph':
            options_html = '''
                
                    
                    
                    
                    
                    
                
            '''
        
        questions_html += f'''
            
                
                    {idx}.
                    {question['text']}
                
                {shape_html}
                {options_html}
            
        '''
    
    html = f'''



    
    
    {quiz.title} - Printable
    
        @media print {{
            @page {{
                margin: 1in;
            }}
        }}
        
        body {{
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 8.5in;
            margin: 0 auto;
            padding: 20px;
        }}
        
        .header {{
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #10B981;
        }}
        
        .header h1 {{
            color: #10B981;
            font-size: 28pt;
            margin-bottom: 10px;
        }}
        
        .metadata {{
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
            font-size: 11pt;
        }}
        
        .student-info {{
            margin: 20px 0;
            padding: 15px;
            background: #f9fafb;
            border-radius: 8px;
        }}
        
        .student-info table {{
            width: 100%;
            border-collapse: collapse;
        }}
        
        .student-info td {{
            padding: 8px;
        }}
        
        .label {{
            font-weight: 600;
            width: 120px;
        }}
        
        .fill-in {{
            border-bottom: 2px solid #000;
        }}
        
        .instructions {{
            margin: 25px 0;
            padding: 15px;
            background: #fffbea;
            border-left: 4px solid #F59E0B;
        }}
        
        .instructions h2 {{
            font-size: 14pt;
            color: #F59E0B;
            margin: 0 0 10px 0;
        }}
        
        .instructions p {{
            margin: 5px 0;
            font-size: 10pt;
        }}
        
        .question {{
            margin: 25px 0;
            padding: 20px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            page-break-inside: avoid;
        }}
        
        .question-header {{
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }}
        
        .question-number {{
            font-weight: 700;
            color: #10B981;
            font-size: 14pt;
            min-width: 30px;
        }}
        
        .question-text {{
            font-size: 12pt;
            font-weight: 500;
            flex: 1;
        }}
        
        .geometry-shape-placeholder {{
            margin: 15px 0;
            padding: 15px;
            background: #f3f4f6;
            border: 1px dashed #9ca3af;
            border-radius: 6px;
            text-align: center;
        }}
        
        .options {{
            margin-left: 40px;
        }}
        
        .option {{
            margin-bottom: 10px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }}
        
        .option-checkbox {{
            width: 16px;
            height: 16px;
            border: 2px solid #000;
            border-radius: 3px;
            margin-top: 3px;
            flex-shrink: 0;
        }}
        
        .option-radio {{
            width: 16px;
            height: 16px;
            border: 2px solid #000;
            border-radius: 50%;
            margin-top: 3px;
            flex-shrink: 0;
        }}
        
        .option-text {{
            font-size: 11pt;
            flex: 1;
        }}
        
        .answer-lines {{
            margin-left: 40px;
            margin-top: 10px;
        }}
        
        .answer-line {{
            border-bottom: 1px solid #000;
            height: 25px;
            margin-bottom: 5px;
        }}
        
        .footer {{
            margin-top: 40px;
            padding-top: 15px;
            border-top: 1px solid #ccc;
            text-align: center;
            font-size: 9pt;
            color: #666;
        }}
        
        .print-button {{
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: #10B981;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14pt;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
        }}
        
        .print-button:hover {{
            background: #059669;
        }}
        
        @media print {{
            .print-button {{
                display: none;
            }}
        }}
        
        @media screen {{
            body {{
                background: #f0f0f0;
                padding: 40px 20px;
            }}
            
            .quiz-container {{
                background: white;
                padding: 40px;
                box-shadow: 0 0 10px rgba(0,0,0,0.1);
            }}
        }}
    


    ðŸ–¨ï¸ Print Quiz
    
    
        
            {quiz.title}
            
                Topic: {quiz.topic}
                Grade Level: {quiz.grade_level}
                Date Created: {quiz.created_at.strftime('%B %d, %Y') if quiz.created_at else datetime.now().strftime('%B %d, %Y')}
                Total Questions: {len(questions)}
            
        
        
        
            
                
                    Name:
                    
                    Date:
                    
                
                
                    Class/Period:
                    
                    Score:
                    
                
            
        
        
        
            Instructions
            â€¢ Read each question carefully before answering.
            â€¢ For multiple choice and true/false questions, mark your answer clearly.
            â€¢ For written response questions, write your answer in the space provided.
            â€¢ Show all work where applicable for geometry calculations.
        
        
        
            {questions_html}
        
        
        
            End of Quiz
            Generated on {datetime.now().strftime('%B %d, %Y')}
        
    


    '''
    
    return html


@app.route('/api/geometry-quiz//print-data', methods=['GET'])
@token_required
def get_geometry_quiz_print_data(current_user, quiz_id):
    """Get quiz data for frontend printing"""
    try:
        quiz = GeometryQuiz.query.filter_by(
            id=quiz_id,
            user_id=current_user.id
        ).first()
        
        if not quiz:
            return jsonify({'error': 'Quiz not found'}), 404
        
        questions = GeometryQuestion.query.filter_by(quiz_id=quiz_id).all()
        
        formatted_questions = []
        for question in questions:
            q_data = {
                'id': question.id,
                'text': question.text,
                'type': question.type,
                'options': json.loads(question.options) if question.options else [],
                'shape_data': json.loads(question.shape_data) if question.shape_data else None
            }
            formatted_questions.append(q_data)
        
        return jsonify({
            'id': quiz.id,
            'title': quiz.title,
            'topic': quiz.topic,
            'grade_level': quiz.grade_level,
            'created_at': quiz.created_at.isoformat() if quiz.created_at else None,
            'total_questions': len(formatted_questions),
            'questions': formatted_questions
        }), 200
        
    except Exception as e:
        logger.error(f"Error getting print data: {str(e)}")
        return jsonify({'error': str(e)}), 500

# Serve the Geometry Quiz Creator HTML page
@app.route('/geometry-quiz-creator.html')
def serve_geometry_quiz_creator():
    return send_from_directory('.', 'geometry-quiz-creator.html')

# Serve the Geometry Quiz HTML page (student interface)
@app.route('/geometry-quiz.html')
def serve_geometry_quiz():
    return send_from_directory('.', 'geometry-quiz.html')

# Serve the Geometry Quiz Scores HTML page
@app.route('/geometry-quiz-scores.html')
def serve_geometry_quiz_scores():
    return send_from_directory('.', 'geometry-quiz-scores.html')

# Serve the Geometry Quiz Performance HTML page  
@app.route('/geometry-quiz-performance.html')
def serve_geometry_quiz_performance():
    return send_from_directory('.', 'geometry-quiz-performance.html')

# Serve the Geometry Quiz Management HTML page
@app.route('/geometry-quiz-management.html')
def serve_geometry_quiz_management():
    return send_from_directory('.', 'geometry-quiz-management.html')

# Expanded Geometry API - Add these new functions to your existing GeometryShapeRenderer class
# Expanded Geometry API - Add these new functions to your existing GeometryShapeRenderer class

import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.patches import Circle, Rectangle, Polygon, Wedge, Arc, FancyBboxPatch
import numpy as np
import io
import base64
import math
import re
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from flask import Flask, request, jsonify



@app.route('/api/geometry/render-prism', methods=['POST'])
def render_prism():
    """Render triangular and rectangular prisms"""
    try:
        data = request.get_json() or {}
        prism_type = data.get('prism_type', 'triangular_prism')
        measurements = data.get('measurements', {})
        hide_answer = data.get('hide_answer', False)
        
        if prism_type == 'triangular_prism':
            image_base64 = renderer.render_triangular_prism(measurements, hide_answer)
        else:
            image_base64 = renderer.render_rectangular_prism(measurements, hide_answer)
        
        return jsonify({
            'success': True,
            'image': image_base64
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/geometry/render-parallel-lines', methods=['POST'])
def render_parallel_lines():
    """Render parallel lines with angle relationships"""
    try:
        data = request.get_json() or {}
        measurements = data.get('measurements', {})
        hide_answer = data.get('hide_answer', False)
        
        image_base64 = renderer.render_parallel_lines(measurements, hide_answer)
        
        return jsonify({
            'success': True,
            'image': image_base64
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/geometry/render-angles', methods=['POST'])
def render_angles():
    """Render angle relationships"""
    try:
        data = request.get_json() or {}
        angle_type = data.get('type', 'complementary_angles')
        measurements = data.get('measurements', {})
        hide_answer = data.get('hide_answer', False)
        
        image_base64 = renderer.render_angle_relationships(angle_type, measurements, hide_answer)
        
        return jsonify({
            'success': True,
            'image': image_base64
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/geometry/render-nets', methods=['POST'])
def render_nets():
    """Render nets of 3D shapes"""
    try:
        data = request.get_json() or {}
        net_type = data.get('net_type', 'cube_net')
        measurements = data.get('measurements', {})
        hide_answer = data.get('hide_answer', False)
        
        image_base64 = renderer.render_nets(net_type, measurements, hide_answer)
        
        return jsonify({
            'success': True,
            'image': image_base64
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

if __name__ == '__main__':
    print("ðŸŽ¯ COMPREHENSIVE GEOMETRY RENDERER READY!")
    print("âœ… SUPPORTED SHAPES:")
    print("   â­• Circles and Sectors")
    print("   ðŸ”º Triangles (Right, Scalene, Isosceles, Equilateral)")
    print("   â–­ Rectangles and Squares")
    print("   â¢ Trapeziums/Trapezoids")
    print("   ðŸ”® 3D Shapes (Sphere, Cube, Cylinder, Cone)")
    print("   ðŸ“¦ Prisms (Triangular, Rectangular)")
    print("   âˆ¥ Parallel Lines with Angle Relationships")
    print("   âˆ  Complementary and Supplementary Angles")
    print("   ðŸ“‹ Nets of 3D Shapes")
    print("   ðŸ§  INTELLIGENT QUESTION PARSING")
    print("   ðŸ“Š AUTOMATIC CALCULATION DISPLAY")
    
    app.run(debug=True, port=5000)
    
@app.route('/api/geometry-quiz-scores/<quiz_id>', methods=['GET'])
@token_required
def get_geometry_quiz_scores(current_user, quiz_id):
    try:
        # Get the quiz to verify ownership and existence
        quiz = GeometryQuiz.query.filter_by(id=quiz_id, user_id=current_user.id).first()
        if not quiz:
            return jsonify({'error': 'Quiz not found or unauthorized'}), 404
        
        # Get all submissions for this quiz
        submissions = GeometryQuizSubmission.query.filter_by(quiz_id=quiz_id).order_by(
            GeometryQuizSubmission.submitted_at.desc()
        ).all()
        
        # Format the submissions data
        scores_data = []
        for submission in submissions:
            percentage = (submission.score / submission.max_score * 100) if submission.max_score > 0 else 0
            
            scores_data.append({
                'id': submission.id,
                'student_name': submission.student_name,
                'score': submission.score,
                'max_score': submission.max_score,
                'percentage': round(percentage, 1),
                'time_taken': submission.time_taken,
                'submitted_at': submission.submitted_at.isoformat(),
                'answers': json.loads(submission.answers_json) if submission.answers_json else {}
            })
        
        # Calculate summary statistics
        if scores_data:
            percentages = [s['percentage'] for s in scores_data]
            summary = {
                'total_submissions': len(scores_data),
                'average_score': round(sum(percentages) / len(percentages), 1),
                'highest_score': max(percentages),
                'lowest_score': min(percentages),
                'passing_rate': len([p for p in percentages if p >= 70]) / len(percentages) * 100
            }
        else:
            summary = {
                'total_submissions': 0,
                'average_score': 0,
                'highest_score': 0,
                'lowest_score': 0,
                'passing_rate': 0
            }
        
        return jsonify({
            'quiz_info': {
                'id': quiz.id,
                'title': quiz.title,
                'topic': quiz.topic,
                'grade_level': quiz.grade_level,
                'created_at': quiz.created_at.isoformat()
            },
            'scores': scores_data,
            'summary': summary
        }), 200
        
    except Exception as e:
        logger.error(f"Error getting geometry quiz scores: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/geometry-quiz-analytics/<quiz_id>', methods=['GET'])
@token_required
def get_geometry_quiz_analytics(current_user, quiz_id):
    try:
        # Get the quiz to verify ownership and existence
        quiz = GeometryQuiz.query.filter_by(id=quiz_id, user_id=current_user.id).first()
        if not quiz:
            return jsonify({'error': 'Quiz not found or unauthorized'}), 404
        
        # Get all submissions for this quiz
        submissions = GeometryQuizSubmission.query.filter_by(quiz_id=quiz_id).all()
        
        if not submissions:
            return jsonify({
                'quiz_info': {
                    'id': quiz.id,
                    'title': quiz.title,
                    'topic': quiz.topic,
                    'grade_level': quiz.grade_level
                },
                'analytics': {
                    'score_distribution': [],
                    'question_analysis': [],
                    'time_analysis': {},
                    'performance_trends': []
                }
            }), 200
        
        # Parse quiz questions for analysis
        questions = json.loads(quiz.questions_json)
        
        # Calculate score distribution
        scores = [s.score / s.max_score * 100 for s in submissions]
        score_ranges = {
            '90-100%': sum(1 for s in scores if s >= 90),
            '80-89%': sum(1 for s in scores if 80 <= s < 90),
            '70-79%': sum(1 for s in scores if 70 <= s < 80),
            '60-69%': sum(1 for s in scores if 60 <= s < 70),
            'Below 60%': sum(1 for s in scores if s < 60)
        }
        
        # Analyze question performance
        question_analysis = []
        for i, question in enumerate(questions):
            correct_count = 0
            total_count = 0
            
            for submission in submissions:
                answers = json.loads(submission.answers_json) if submission.answers_json else {}
                if str(i) in answers:
                    total_count += 1
                    if answers[str(i)].get('isCorrect', False):
                        correct_count += 1
            
            accuracy = (correct_count / total_count * 100) if total_count > 0 else 0
            
            question_analysis.append({
                'question_number': i + 1,
                'question_text': question['text'][:100] + '...' if len(question['text']) > 100 else question['text'],
                'accuracy': round(accuracy, 1),
                'attempts': total_count,
                'difficulty': 'Easy' if accuracy >= 80 else 'Medium' if accuracy >= 60 else 'Hard'
            })
        
        # Analyze time performance
        times = [s.time_taken for s in submissions if s.time_taken]
        time_analysis = {
            'average_time': round(sum(times) / len(times), 1) if times else 0,
            'fastest_time': min(times) if times else 0,
            'slowest_time': max(times) if times else 0,
            'time_limit': quiz.time_limit * 60
        }
        
        # Performance trends (last 30 days)
        from datetime import datetime, timedelta
        end_date = datetime.utcnow()
        start_date = end_date - timedelta(days=30)
        
        recent_submissions = [s for s in submissions if s.submitted_at >= start_date]
        performance_trends = []
        
        # Group by day
        daily_scores = {}
        for submission in recent_submissions:
            day = submission.submitted_at.date()
            if day not in daily_scores:
                daily_scores[day] = []
            daily_scores[day].append(submission.score / submission.max_score * 100)
        
        for day, scores in sorted(daily_scores.items()):
            performance_trends.append({
                'date': day.isoformat(),
                'average_score': round(sum(scores) / len(scores), 1),
                'submission_count': len(scores)
            })
        
        return jsonify({
            'quiz_info': {
                'id': quiz.id,
                'title': quiz.title,
                'topic': quiz.topic,
                'grade_level': quiz.grade_level,
                'total_submissions': len(submissions)
            },
            'analytics': {
                'score_distribution': score_ranges,
                'question_analysis': question_analysis,
                'time_analysis': time_analysis,
                'performance_trends': performance_trends
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Error getting geometry quiz analytics: {str(e)}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/my-geometry-quizzes', methods=['GET'])
@token_required
def get_my_geometry_quizzes(current_user):
    try:
        # Get pagination parameters
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 10, type=int)
        
        # Get search and filter parameters
        search = request.args.get('search', '')
        grade_level = request.args.get('grade_level', '')
        sort_by = request.args.get('sort_by', 'created_at')
        sort_order = request.args.get('sort_order', 'desc')
        
        # Build the query
        query = GeometryQuiz.query.filter_by(user_id=current_user.id)
        
        # Apply search filter
        if search:
            query = query.filter(
                db.or_(
                    GeometryQuiz.title.contains(search),
                    GeometryQuiz.topic.contains(search)
                )
            )
        
        # Apply grade level filter
        if grade_level:
            query = query.filter(GeometryQuiz.grade_level == grade_level)
        
        # Apply sorting
        if sort_by == 'title':
            order_col = GeometryQuiz.title
        elif sort_by == 'topic':
            order_col = GeometryQuiz.topic
        elif sort_by == 'grade_level':
            order_col = GeometryQuiz.grade_level
        else:
            order_col = GeometryQuiz.created_at
        
        if sort_order == 'desc':
            query = query.order_by(order_col.desc())
        else:
            query = query.order_by(order_col.asc())
        
        # Execute paginated query
        quizzes = query.paginate(
            page=page, 
            per_page=per_page, 
            error_out=False
        )
        
        # Format the quizzes data
        quizzes_data = []
        for quiz in quizzes.items:
            # Get submission count for this quiz
            submission_count = GeometryQuizSubmission.query.filter_by(quiz_id=quiz.id).count()
            
            # Parse questions to get question count
            questions = json.loads(quiz.questions_json) if quiz.questions_json else []
            
            quizzes_data.append({
                'id': quiz.id,
                'title': quiz.title,
                'topic': quiz.topic,
                'grade_level': quiz.grade_level,
                'question_count': len(questions),
                'time_limit': quiz.time_limit,
                'mode': quiz.mode,
                'submission_count': submission_count,
                'created_at': quiz.created_at.isoformat(),
                'geometry_types': json.loads(quiz.geometry_types) if quiz.geometry_types else []
            })
        
        return jsonify({
            'quizzes': quizzes_data,
            'pagination': {
                'current_page': quizzes.page,
                'total_pages': quizzes.pages,
                'total_items': quizzes.total,
                'per_page': quizzes.per_page,
                'has_next': quizzes.has_next,
                'has_prev': quizzes.has_prev
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Error getting user's geometry quizzes: {str(e)}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/evaluate-geometry-paragraph', methods=['POST'])
@token_required
def evaluate_geometry_paragraph(current_user):
    try:
        data = request.get_json()
        
        question_text = data.get('question_text', '')
        student_answer = data.get('student_answer', '')
        topic = data.get('topic', '')
        grade_level = data.get('grade_level', 'high school')
        
        # Build the prompt for paragraph evaluation with geometry focus
        prompt = f"""Evaluate this student's answer to a geometry question.

Question: {question_text}
Student Answer: {student_answer}
Geometry Topic: {topic}
Grade Level: {grade_level}

Evaluate the answer based on:
1. Geometric understanding and concept application
2. Correct use of geometric terminology
3. Accuracy of calculations (if any)
4. Clarity of geometric reasoning
5. Use of appropriate geometric properties or theorems

Provide a detailed evaluation with:
1. A score from 0-100
2. An explanation of the score focusing on geometric concepts
3. Strengths of the answer (geometric understanding shown)
4. Areas for improvement (geometric concepts to review)

Return your evaluation as a JSON object with these keys: score, explanation, strengths, improvements.
"""

        # Call Claude API
        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=2000,
                temperature=0.3,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            content = response.content[0].text
            logger.info(f"Received geometry evaluation from Claude: {len(content)} characters")
            
        except Exception as claude_error:
            logger.error(f"Claude API error: {str(claude_error)}")
            return jsonify({'error': 'Failed to evaluate paragraph answer'}), 500
        
        # Parse the response as JSON
        try:
            # First, try to extract a JSON object from the response
            json_start = content.find('{')
            json_end = content.rfind('}') + 1
            
            if json_start >= 0 and json_end > json_start:
                json_content = content[json_start:json_end]
                evaluation = json.loads(json_content)
                
                # Ensure all required fields are present
                if 'score' not in evaluation:
                    evaluation['score'] = 70
                if 'explanation' not in evaluation:
                    evaluation['explanation'] = "No detailed explanation provided."
                if 'strengths' not in evaluation:
                    evaluation['strengths'] = []
                if 'improvements' not in evaluation:
                    evaluation['improvements'] = []
                
                return jsonify(evaluation), 200
            else:
                # If no JSON found, create a default response
                return jsonify({
                    'score': 70,
                    'explanation': "The answer shows some understanding of geometric concepts, but the evaluation system couldn't provide detailed feedback.",
                    'strengths': ["Shows some understanding of geometric concepts"],
                    'improvements': ["Could provide more detailed geometric explanations", "Review relevant geometric properties"]
                }), 200
                
        except Exception as parse_error:
            logger.error(f"Error parsing evaluation response: {str(parse_error)}")
            return jsonify({
                'score': 70,
                'explanation': "The answer shows some understanding of geometric concepts, but the evaluation system couldn't provide detailed feedback.",
                'strengths': ["Shows some understanding of geometric concepts"],
                'improvements': ["Could provide more detailed geometric explanations", "Review relevant geometric properties"]
            }), 200
    
    except Exception as e:
        logger.error(f"Geometry paragraph evaluation error: {str(e)}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/generate-geometry-explanations', methods=['POST'])
@token_required
def generate_geometry_explanations(current_user):
    try:
        data = request.get_json()
        
        topic = data.get('topic', 'geometry')
        incorrect_answers = data.get('incorrectAnswers', [])
        
        if not incorrect_answers:
            return jsonify({'explanations': []}), 200
        
        # Build the prompt for generating explanations with geometry focus
        prompt = f"""Generate helpful explanations for these incorrect geometry answers:

Geometry Topic: {topic}

"""
        
        # Add each incorrect answer to the prompt
        for i, answer in enumerate(incorrect_answers):
            prompt += f"""
Question {i+1}: {answer.get('question', '')}
User's incorrect answer: {answer.get('userAnswer', '')}
Correct answer: {answer.get('correctAnswer', '')}
"""
        
        prompt += """
For each question, provide a clear, educational explanation that:
1. Explains the geometric reasoning behind the correct answer
2. Identifies the geometric misconception or error in the user's answer
3. Explains the relevant geometric principles, formulas, or properties
4. Uses proper geometric terminology and notation
5. Provides helpful tips for remembering similar geometric concepts

Return your response as a JSON array of objects, each with:
- questionIndex: the index of the question
- question: the question text
- userAnswer: the incorrect answer given
- correctAnswer: the correct answer
- explanation: your detailed geometric explanation

"""

        # Call Claude API
        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=3000,
                temperature=0.3,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            content = response.content[0].text
            logger.info(f"Received geometry explanations from Claude: {len(content)} characters")
            
        except Exception as claude_error:
            logger.error(f"Claude API error: {str(claude_error)}")
            return jsonify({'error': 'Failed to generate explanations'}), 500
        
        # Parse the response as JSON
        try:
            # Try to extract a JSON array from the response
            json_start = content.find('[')
            json_end = content.rfind(']') + 1
            
            if json_start >= 0 and json_end > json_start:
                json_content = content[json_start:json_end]
                explanations = json.loads(json_content)
                
                return jsonify({'explanations': explanations}), 200
            else:
                # If no JSON array found, try to extract a JSON object
                json_start = content.find('{')
                json_end = content.rfind('}') + 1
                
                if json_start >= 0 and json_end > json_start:
                    json_content = content[json_start:json_end]
                    data = json.loads(json_content)
                    
                    if 'explanations' in data and isinstance(data['explanations'], list):
                        return jsonify(data), 200
                
                # If still no valid JSON, create default geometric explanations
                default_explanations = []
                for i, answer in enumerate(incorrect_answers):
                    default_explanations.append({
                        'questionIndex': answer.get('questionIndex', i),
                        'question': answer.get('question', ''),
                        'userAnswer': answer.get('userAnswer', ''),
                        'correctAnswer': answer.get('correctAnswer', ''),
                        'explanation': f"The correct answer follows from proper application of geometric principles and formulas. Review the relevant geometric concepts and ensure you're using the right formulas for this type of shape or calculation."
                    })
                
                return jsonify({'explanations': default_explanations}), 200
                
        except Exception as parse_error:
            logger.error(f"Error parsing explanations response: {str(parse_error)}")
            
            # Create default explanations if parsing fails
            default_explanations = []
            for i, answer in enumerate(incorrect_answers):
                default_explanations.append({
                    'questionIndex': answer.get('questionIndex', i),
                    'question': answer.get('question', ''),
                    'userAnswer': answer.get('userAnswer', ''),
                    'correctAnswer': answer.get('correctAnswer', ''),
                    'explanation': f"The correct answer follows from proper application of geometric principles and formulas. Review the relevant geometric concepts and ensure you're using the right formulas for this type of shape or calculation."
                })
            
            return jsonify({'explanations': default_explanations}), 200
    
    except Exception as e:
        logger.error(f"Geometry explanation generation error: {str(e)}")
        return jsonify({'error': str(e)}), 500

# Function to initialize the geometry quiz system
def setup_geometry_quiz_system():
    """Setup function to verify the geometry quiz system (use migrations to create tables)"""

    # Verify database connectivity
    with app.app_context():
        try:
            from sqlalchemy import text
            db.session.execute(text("SELECT 1")).fetchone()
            logger.info("âœ… Geometry quiz system verification complete - use migrations to create tables")
        except Exception as e:
            logger.error(f"âŒ Geometry quiz system verification failed: {str(e)}")

    # Log the available routes
    logger.info("Geometry Quiz System Routes:")
    logger.info("- GET /api/get-geometry-quiz/<quiz_id>")
    logger.info("- POST /api/regenerate-geometry-question")
    logger.info("- POST /api/submit-geometry-quiz")
    logger.info("- GET /api/geometry-quiz-scores/<quiz_id>")
    logger.info("- GET /api/geometry-quiz-analytics/<quiz_id>")
    logger.info("- GET /api/my-geometry-quizzes")
    logger.info("- DELETE /api/geometry-quiz/<quiz_id>")
    logger.info("- POST /api/geometry-quiz/<quiz_id>/duplicate")
    logger.info("- POST /api/evaluate-geometry-paragraph")
    logger.info("- POST /api/generate-geometry-explanations")
    
    # Frontend routes
    logger.info("Frontend Routes:")
    logger.info("- /geometry-quiz-creator")
    logger.info("- /geometry-quiz.html")
    logger.info("- /geometry-quiz-scores.html")
    logger.info("- /geometry-quiz-performance.html")
    logger.info("- /geometry-quiz-management.html")
    
    logger.info("Geometry Quiz System setup complete!")

# BACKEND ENDPOINTS FIX TO MATCH FRONTEND AI SYSTEM
# This modifies the backend to match the frontend's expected endpoints and structure

import random
from datetime import datetime
from flask import request, jsonify

# AI VALUE ASSIGNMENT BACKEND (Non-AI but Frontend Compatible)
class GeometryValueAssignmentSystem:
    """Backend system that mimics AI value assignment to match frontend expectations"""
    
    def __init__(self):
        self.shape_templates = {
            'trapezium': {
                'required_fields': ['parallel_side1', 'parallel_side2', 'height'],
                'optional_fields': ['area', 'perimeter'],
                'value_ranges': {
                    'parallel_side1': (8, 15),
                    'parallel_side2': (4, 10),
                    'height': (5, 12)
                }
            },
            'circle': {
                'required_fields': ['radius'],
                'optional_fields': ['diameter', 'circumference', 'area'],
                'value_ranges': {
                    'radius': (3, 12)
                }
            },
            'cube': {
                'required_fields': ['side'],
                'optional_fields': ['volume', 'surface_area'],
                'value_ranges': {
                    'side': (4, 10)
                }
            },
            'cylinder': {
                'required_fields': ['radius', 'height'],
                'optional_fields': ['volume', 'surface_area'],
                'value_ranges': {
                    'radius': (3, 8),
                    'height': (6, 15)
                }
            },
            'cone': {
                'required_fields': ['radius', 'height'],
                'optional_fields': ['volume', 'surface_area', 'slant_height'],
                'value_ranges': {
                    'radius': (3, 7),
                    'height': (8, 15)
                }
            },
            'sphere': {
                'required_fields': ['radius'],
                'optional_fields': ['diameter', 'volume', 'surface_area'],
                'value_ranges': {
                    'radius': (4, 10)
                }
            },
            'triangle': {
                'required_fields': ['base', 'height'],
                'optional_fields': ['area', 'perimeter', 'sides'],
                'value_ranges': {
                    'base': (6, 12),
                    'height': (4, 10)
                }
            },
            'rectangle': {
                'required_fields': ['length', 'width'],
                'optional_fields': ['area', 'perimeter'],
                'value_ranges': {
                    'length': (8, 15),
                    'width': (5, 10)
                }
            },
            'square': {
                'required_fields': ['side'],
                'optional_fields': ['area', 'perimeter'],
                'value_ranges': {
                    'side': (5, 12)
                }
            },
            'polygon': {
                'required_fields': ['sides', 'side_length'],
                'optional_fields': ['interior_angle', 'perimeter'],
                'value_ranges': {
                    'sides': (5, 8),
                    'side_length': (4, 8)
                }
            }
        }
    
    def detect_shape_from_question(self, question_text):
        """Detect shape type from question text with priority-based validation

        CRITICAL FIX: Checks explicit shapes FIRST, transformations LAST
        Prevents "A scalene triangle after dilation..." from being classified as 'transformation'
        """

        if not question_text:
            return None

        text_lower = question_text.lower()

        print(f"\nðŸ” SHAPE DETECTION: {question_text[:100]}...")

        # ====== PRIORITY 1: SECTORS (check before circles!) ======
        if 'sector' in text_lower or ('central angle' in text_lower and 'circle' in text_lower):
            print(f"âœ… Detected: sector")
            return 'sector'

        # ====== PRIORITY 2: PARALLEL LINES & ANGLES (check before other shapes) ======
        if 'parallel' in text_lower and ('line' in text_lower or 'transversal' in text_lower):
            print(f"âœ… Detected: parallel_lines")
            return 'parallel_lines'

        if 'corresponding angle' in text_lower:
            print(f"âœ… Detected: parallel_lines (from 'corresponding angle')")
            return 'parallel_lines'

        if 'alternate' in text_lower and 'angle' in text_lower:
            print(f"âœ… Detected: parallel_lines (from 'alternate angle')")
            return 'parallel_lines'

        if 'complementary' in text_lower and 'angle' in text_lower:
            print(f"âœ… Detected: complementary_angles")
            return 'complementary_angles'

        if 'supplementary' in text_lower and 'angle' in text_lower:
            print(f"âœ… Detected: supplementary_angles")
            return 'supplementary_angles'

        # ====== PRIORITY 3: 3D SHAPES ======
        if 'cylinder' in text_lower or 'cylindrical' in text_lower:
            print(f"âœ… Detected: cylinder")
            return 'cylinder'

        if 'cone' in text_lower or 'conical' in text_lower:
            print(f"âœ… Detected: cone")
            return 'cone'

        if 'sphere' in text_lower or 'spherical' in text_lower:
            print(f"âœ… Detected: sphere")
            return 'sphere'

        if 'cube' in text_lower or 'cubic' in text_lower:
            print(f"âœ… Detected: cube")
            return 'cube'

        if 'triangular prism' in text_lower or 'prism' in text_lower:
            print(f"âœ… Detected: triangular_prism")
            return 'triangular_prism'

        if 'rectangular prism' in text_lower or 'cuboid' in text_lower:
            print(f"âœ… Detected: rectangular_prism")
            return 'rectangular_prism'

        # ====== PRIORITY 4: 2D SHAPES - TRIANGLES ======
        # Check for TRIANGLES (with ALL triangle types)
        # NOTE: Only check for 'triangle', NOT 'triangular' to avoid matching "triangular prism"
        if 'triangle' in text_lower or 'pythagoras' in text_lower or 'pythagorean' in text_lower:
            # Check for specific triangle types with PRIORITY ORDER
            if 'right' in text_lower or 'right-angled' in text_lower or 'pythagoras' in text_lower:
                print(f"âœ… Detected: right_triangle")
                return 'right_triangle'
            elif 'equilateral' in text_lower:
                print(f"âœ… Detected: equilateral_triangle")
                return 'equilateral_triangle'
            elif 'isosceles' in text_lower:
                print(f"âœ… Detected: isosceles_triangle")
                return 'isosceles_triangle'
            elif 'scalene' in text_lower:
                print(f"âœ… Detected: scalene_triangle")
                return 'scalene_triangle'
            elif 'obtuse' in text_lower:
                print(f"âœ… Detected: obtuse_triangle")
                return 'obtuse_triangle'
            elif 'acute' in text_lower:
                print(f"âœ… Detected: acute_triangle")
                return 'acute_triangle'
            else:
                print(f"âœ… Detected: triangle (generic)")
                return 'triangle'
        
        # Check for CIRCLE (after sector check)
        if 'circle' in text_lower or 'circular' in text_lower:
            # But NOT if it's about angles (that's parallel lines)
            if 'corresponding' in text_lower or 'alternate' in text_lower:
                print(f"âœ… Detected: parallel_lines (circle question is actually about angles)")
                return 'parallel_lines'
            print(f"âœ… Detected: circle")
            return 'circle'
        
        if 'rectangle' in text_lower or 'rectangular' in text_lower:
            print(f"âœ… Detected: rectangle")
            return 'rectangle'
        
        if 'square' in text_lower:
            print(f"âœ… Detected: square")
            return 'square'
        
        if 'trapezium' in text_lower or 'trapezoid' in text_lower:
            print(f"âœ… Detected: trapezium")
            return 'trapezium'

        if 'pentagon' in text_lower:
            print(f"âœ… Detected: pentagon")
            return 'pentagon'

        if 'hexagon' in text_lower:
            print(f"âœ… Detected: hexagon")
            return 'hexagon'

        if 'polygon' in text_lower:
            print(f"âœ… Detected: polygon")
            return 'polygon'

        # ====== PRIORITY 6: TRANSFORMATIONS (LAST PRIORITY!) ======
        # ONLY detect transformations if NO explicit shape was detected above
        # This ensures "triangle after dilation" â†’ 'triangle', NOT 'transformation'
        if any(word in text_lower for word in ['rotation', 'reflection', 'translation', 'dilation', 'transformed', 'rotated', 'reflected', 'translated']):
            print(f"âš ï¸  Detected transformation keywords WITHOUT explicit shape - classifying as 'transformation'")
            return 'transformation'

        print(f"âŒ No shape detected")
        return None
    
    def assign_missing_values(self, shape_type, extracted_values):
        """Assign default values for missing shape properties"""
        complete_values = extracted_values.copy()
        
        # Add default values based on shape type
        if shape_type == 'sector':
            # SECTOR defaults
            if 'radius' not in complete_values:
                complete_values['radius'] = 10
            if 'central_angle' not in complete_values:
                complete_values['central_angle'] = 60
            
            # Calculate additional properties
            import math
            radius = complete_values['radius']
            angle = complete_values['central_angle']
            complete_values['arc_length'] = (angle / 360) * 2 * math.pi * radius
            complete_values['sector_area'] = (angle / 360) * math.pi * radius ** 2
        
        elif shape_type == 'trapezium':
            if 'parallel_side1' not in complete_values:
                complete_values['parallel_side1'] = 10
            if 'parallel_side2' not in complete_values:
                complete_values['parallel_side2'] = 6
            if 'height' not in complete_values:
                complete_values['height'] = 8
                
        elif shape_type == 'circle':
            if 'radius' not in complete_values:
                complete_values['radius'] = 5
                
        elif shape_type in ['cube', 'square']:
            if 'side' not in complete_values:
                complete_values['side'] = 6
                
        elif shape_type in ['cylinder', 'cone']:
            if 'radius' not in complete_values:
                complete_values['radius'] = 5
            if 'height' not in complete_values:
                complete_values['height'] = 10
                
        elif shape_type == 'sphere':
            if 'radius' not in complete_values:
                complete_values['radius'] = 5
                
        elif shape_type == 'rectangle':
            if 'length' not in complete_values:
                complete_values['length'] = 10
            if 'width' not in complete_values:
                complete_values['width'] = 6
                
        elif shape_type == 'triangle':
            if 'base' not in complete_values:
                complete_values['base'] = 8
            if 'height' not in complete_values:
                complete_values['height'] = 6
        
        return complete_values
    
    def calculate_derived_values(self, shape_type, values):
        """Calculate area, volume, etc. from basic measurements"""
        result = values.copy()
        
        try:
            if shape_type == 'trapezium':
                if all(k in values for k in ['parallel_side1', 'parallel_side2', 'height']):
                    area = 0.5 * (values['parallel_side1'] + values['parallel_side2']) * values['height']
                    result['area'] = round(area, 2)
                    
            elif shape_type == 'circle':
                if 'radius' in values:
                    r = values['radius']
                    result['diameter'] = round(2 * r, 2)
                    result['circumference'] = round(2 * math.pi * r, 2)
                    result['area'] = round(math.pi * r * r, 2)
                    
            elif shape_type == 'cube':
                if 'side' in values:
                    s = values['side']
                    result['volume'] = round(s ** 3, 2)
                    result['surface_area'] = round(6 * s * s, 2)
                    
            elif shape_type == 'cylinder':
                if all(k in values for k in ['radius', 'height']):
                    r, h = values['radius'], values['height']
                    result['volume'] = round(math.pi * r * r * h, 2)
                    result['surface_area'] = round(2 * math.pi * r * (r + h), 2)
                    
            elif shape_type == 'sphere':
                if 'radius' in values:
                    r = values['radius']
                    result['diameter'] = round(2 * r, 2)
                    result['volume'] = round((4/3) * math.pi * r ** 3, 2)
                    result['surface_area'] = round(4 * math.pi * r * r, 2)
                    
            elif shape_type == 'rectangle':
                if all(k in values for k in ['length', 'width']):
                    l, w = values['length'], values['width']
                    result['area'] = round(l * w, 2)
                    result['perimeter'] = round(2 * (l + w), 2)
                    
            elif shape_type == 'square':
                if 'side' in values:
                    s = values['side']
                    result['area'] = round(s * s, 2)
                    result['perimeter'] = round(4 * s, 2)
                    
        except Exception as e:
            logging.warning(f"Error calculating derived values for {shape_type}: {e}")
        
        return result
    
    def process_question_for_ai_values(self, question_text):
        """Main method to process a question and assign AI-like values"""
        shape_type = self.detect_shape_from_question(question_text)
        
        if not shape_type:
            return {
                'ai_assigned': False,
                'shape_type': None,
                'error': 'No geometry shape detected'
            }
        
        # Extract values from question
        extracted_values = self.extract_values_from_question(question_text, shape_type)
        
        # Assign missing values
        complete_values = self.assign_missing_values(shape_type, extracted_values)
        
        # Mark as AI assigned
        complete_values.update({
            'ai_assigned': True,
            'shape_type': shape_type,
            'extraction_method': 'backend_value_assignment',
            'validation_passed': True
        })
        
        logging.info(f"ðŸ¤– BACKEND AI: Assigned values for {shape_type}: {complete_values}")
        return complete_values


# Initialize the value assignment system
value_assignment_system = GeometryValueAssignmentSystem()


def generate_geometry_prompt_with_ai_support(data, selected_geometry_types):
    """Generate geometry prompt with comprehensive triangle type support"""

    topic = data.get('topic', 'geometry')
    grade_level = data.get('grade_level', 'high')
    numQuestions = int(data.get('numQuestions', 5))

    # Build triangle-specific guidance if triangles are selected
    triangle_guidance = ""
    if 'triangles' in selected_geometry_types or 'triangle' in str(selected_geometry_types).lower():
        triangle_guidance = """
TRIANGLE TYPE DIVERSITY - Mathematical Properties Guide:

You must create ORIGINAL, VARIED triangle questions. Use these mathematical principles (NOT as templates, but as knowledge):

Triangle Classification by Sides:
- Right Triangle: Contains one 90Â° angle; Pythagorean theorem applies (aÂ² + bÂ² = cÂ²)
- Equilateral: All sides equal, all angles 60Â°; Area = (âˆš3/4)sÂ², Height = (âˆš3/2)s
- Isosceles: Two equal sides, two equal base angles
- Scalene: All sides different lengths, all angles different

Triangle Classification by Angles:
- Acute: All three angles < 90Â°
- Right: One angle = 90Â°
- Obtuse: One angle > 90Â°

Available Calculation Methods:
- Basic area formula: A = Â½ Ã— base Ã— height
- Heron's formula: A = âˆš[s(s-a)(s-b)(s-c)] where s = (a+b+c)/2
- Pythagorean theorem for right triangles
- Trigonometric ratios (for advanced levels)
- Perimeter calculations
- Altitude and median calculations

CRITICAL INSTRUCTIONS:
âœ“ Generate UNIQUE questions with ORIGINAL measurements and scenarios
âœ“ VARY the triangle types across ALL questions - distribute across different types
âœ“ Create DIVERSE problem types (area, perimeter, missing sides, angles, etc.)
âœ“ Use REALISTIC, grade-appropriate numerical values
âœ“ ALWAYS explicitly state the triangle type in the question text
âœ— DO NOT use predictable or template-based question patterns
âœ— DO NOT generate multiple questions of the same type in a row
"""

    prompt = f"""Create {numQuestions} geometry questions about {topic} for {grade_level} students.

CRITICAL AI VALUE ASSIGNMENT INSTRUCTIONS:
- Each question MUST include specific numerical values
- Focus on shapes that require measurements and calculations
- Include clear geometric properties in each question
- Make questions suitable for visual shape rendering
- VARY question types - don't repeat the same shape type for all questions

SELECTED GEOMETRY TYPES (STRICT LOCKOUT):
{', '.join(selected_geometry_types) if selected_geometry_types else 'No specific types selected'}
{triangle_guidance}

QUESTION REQUIREMENTS:
1. Include specific measurements in EVERY question (required for rendering)
2. Use realistic numerical values appropriate for {grade_level} level
3. Focus on calculation-based geometry problems
4. Ensure each question can be visualized with a shape diagram
5. Vary the difficulty and question types
6. For triangles: MUST specify triangle type (right/equilateral/isosceles/scalene/obtuse/acute)

FORMAT YOUR RESPONSE AS JSON:
{{
  "questions": [
    {{
      "id": "unique-id-1",
      "text": "Question with specific measurements and values (MUST mention shape type clearly)",
      "type": "multiple_choice",
      "options": [
        {{"text": "Option A with calculated value", "isCorrect": true}},
        {{"text": "Option B with calculated value", "isCorrect": false}},
        {{"text": "Option C with calculated value", "isCorrect": false}},
        {{"text": "Option D with calculated value", "isCorrect": false}}
      ]
    }}
  ]
}}

CRITICAL RULES:
- ALWAYS mention the shape type in the question (e.g., "A scalene triangle...", "An equilateral triangle...")
- Include ALL measurements needed for visualization
- Ensure answer options have realistic values with proper units
- Make questions educational and mathematically accurate"""

    return prompt


def apply_ai_value_assignment_to_questions(questions):
    """Apply AI-like value assignment to questions for frontend compatibility"""
    processed_questions = []
    
    for question in questions:
        question_copy = question.copy()
        
        # Process with value assignment system
        ai_values = value_assignment_system.process_question_for_ai_values(question['text'])
        
        if ai_values.get('ai_assigned'):
            question_copy['shape_data'] = ai_values
            question_copy['requires_geometry'] = True
            question_copy['geometry_type'] = ai_values['shape_type']
            logging.info(f"âœ… AI VALUES: Assigned {ai_values['shape_type']} to question: {question['text'][:50]}...")
        else:
            question_copy['requires_geometry'] = False
            logging.info(f"â„¹ï¸  NO SHAPE: No geometry shape detected for: {question['text'][:50]}...")
        
        processed_questions.append(question_copy)
    
    return processed_questions


# ENHANCED REGENERATE ENDPOINT FOR AI QUESTIONS
@app.route('/api/regenerate-geometry-question', methods=['POST'])
@token_required
def regenerate_geometry_question_ai(current_user):
    """ENHANCED: Regenerate question with AI value assignment"""
    try:
        data = request.get_json()
        quiz_id = data.get('quiz_id')
        question_id = data.get('question_id')
        topic = data.get('topic', 'geometry')
        grade_level = data.get('grade_level', 'high')
        ai_enhanced = data.get('ai_enhanced', True)
        
        if not quiz_id or not question_id:
            return jsonify({'error': 'Quiz ID and Question ID are required'}), 400
        
        # Get the existing quiz
        quiz = GeometryQuiz.query.filter_by(id=quiz_id, user_id=current_user.id).first()
        if not quiz:
            return jsonify({'error': 'Quiz not found or unauthorized'}), 404
        
        # Parse existing questions
        questions = json.loads(quiz.questions_json)
        question_index = None
        
        # Find the question to regenerate
        for i, q in enumerate(questions):
            if str(q.get('id')) == str(question_id):
                question_index = i
                break
        
        if question_index is None:
            return jsonify({'error': 'Question not found'}), 404
        
        # Get the question type from the existing question
        existing_question = questions[question_index]
        question_type = existing_question.get('type', 'multiple_choice')
        
        # Create a prompt for regenerating this specific geometry question
        prompt = f"""Generate a single {question_type} geometry question about {topic} for {grade_level} students.

REQUIREMENTS:
1. Create an ACTUAL geometric question with specific measurements
2. Focus on geometric concepts like shapes, areas, angles, or measurements
3. Use proper mathematical notation and include specific numerical values
4. Make it educational and appropriately challenging
5. Include clear measurements that can be used for shape visualization

Return format:
{{
  "id": "regenerated-question",
  "text": "Your actual geometry question with specific measurements",
  "type": "{question_type}",
  "options": [
    {{"text": "Option A with calculated answer", "isCorrect": true}},
    {{"text": "Option B with different value", "isCorrect": false}},
    {{"text": "Option C with different value", "isCorrect": false}},
    {{"text": "Option D with different value", "isCorrect": false}}
  ]
}}"""
        
        # Call Claude API
        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=2000,
                temperature=0.8,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            content = response.content[0].text
            logging.info(f"Received regenerated geometry question from Claude: {len(content)} characters")
            
        except Exception as claude_error:
            logging.error(f"Claude API error: {str(claude_error)}")
            return jsonify({'error': 'Failed to regenerate question'}), 500
        
        # Parse the response
        try:
            # Clean the response
            content = content.strip()
            if content.startswith('```json'):
                content = content[7:]
            if content.endswith('```'):
                content = content[:-3]
            content = content.strip()
            
            new_question = json.loads(content)
            
            # Clean mathematical notation
            new_question['text'] = clean_mathematical_notation(new_question['text'])
            if new_question.get('options'):
                for option in new_question['options']:
                    option['text'] = clean_mathematical_notation(option['text'])
            
            # Ensure question has a unique ID
            new_question['id'] = str(uuid.uuid4())
            
            # Apply AI value assignment if enabled
            if ai_enhanced:
                ai_values = value_assignment_system.process_question_for_ai_values(new_question['text'])
                if ai_values.get('ai_assigned'):
                    new_question['shape_data'] = ai_values
                    new_question['requires_geometry'] = True
                    new_question['geometry_type'] = ai_values['shape_type']
                    logging.info(f"âœ… AI REGENERATION: Assigned {ai_values['shape_type']} values")
            
            # Replace the question in the quiz
            questions[question_index] = new_question
            
            # Update the quiz in the database
            quiz.questions_json = json.dumps(questions)
            db.session.commit()
            
            logging.info(f"Successfully regenerated AI-enhanced question for geometry quiz {quiz_id}")
            
            return jsonify({
                'question': new_question,
                'message': 'Question regenerated with AI enhancement'
            }), 200
            
        except json.JSONDecodeError as e:
            logging.error(f"Error parsing regenerated question JSON: {e}")
            return jsonify({'error': 'Failed to parse regenerated question'}), 500
    
    except Exception as e:
        logging.error(f"Error regenerating AI geometry question: {str(e)}")
        return jsonify({'error': str(e)}), 500


# GEOMETRY QUIZ RETRIEVAL WITH AI SUPPORT
@app.route('/api/get-geometry-quiz/<quiz_id>', methods=['GET'])
def get_geometry_quiz_with_ai_support(quiz_id):
    """Enhanced quiz retrieval with AI value information"""
    try:
        logging.info(f"Request: GET /api/get-geometry-quiz/{quiz_id}")
        
        # Fetch the quiz from database
        quiz = GeometryQuiz.query.filter_by(id=quiz_id).first()
        
        if not quiz:
            logging.warning(f"Geometry quiz not found: {quiz_id}")
            return jsonify({'error': 'Quiz not found'}), 404
        
        # Parse the questions JSON
        questions = json.loads(quiz.questions_json) if quiz.questions_json else []
        
        # Check for AI-enhanced questions and add metadata
        for question in questions:
            if not question.get('shape_data') and question.get('text'):
                # Try to assign AI values if not already present
                ai_values = value_assignment_system.process_question_for_ai_values(question['text'])
                if ai_values.get('ai_assigned'):
                    question['shape_data'] = ai_values
                    question['requires_geometry'] = True
                    question['geometry_type'] = ai_values['shape_type']
        
        quiz_data = {
            'id': quiz.id,
            'title': quiz.title,
            'topic': quiz.topic,
            'grade_level': quiz.grade_level,
            'time_limit': quiz.time_limit,
            'mode': quiz.mode,
            'questions': questions,
            'ai_enhanced': any(q.get('shape_data', {}).get('ai_assigned') for q in questions),
            'shapes_count': len([q for q in questions if q.get('requires_geometry')])
        }
        
        logging.info(f"Successfully retrieved AI-enhanced geometry quiz: {quiz_id}")
        return jsonify(quiz_data), 200
        
    except Exception as e:
        logging.error(f"Error getting geometry quiz: {str(e)}")
        return jsonify({'error': f'Failed to load quiz: {str(e)}'}), 500


# UPDATE EXISTING RENDER ENDPOINTS TO SUPPORT AI VALUES
@app.route('/api/geometry/render-circle', methods=['POST'])
def render_circle_ai_support():
    """Circle rendering with AI value support"""
    try:
        data = request.get_json() or {}
        data['type'] = 'circle'
        return render_geometry_shape_enhanced()
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/geometry/render-cube', methods=['POST'])
def render_cube_ai_support():
    """Cube rendering with AI value support"""
    try:
        data = request.get_json() or {}
        data['type'] = 'cube'
        return render_geometry_shape_enhanced()
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/geometry/render-cylinder', methods=['POST'])
def render_cylinder_ai_support():
    """Cylinder rendering with AI value support"""
    try:
        data = request.get_json() or {}
        data['type'] = 'cylinder'
        return render_geometry_shape_enhanced()
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/geometry/render-sphere', methods=['POST'])
def render_sphere_ai_support():
    """Sphere rendering with AI value support"""
    try:
        data = request.get_json() or {}
        data['type'] = 'sphere'
        return render_geometry_shape_enhanced()
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/geometry/render-cone', methods=['POST'])
def render_cone_ai_support():
    """Cone rendering with AI value support"""
    try:
        data = request.get_json() or {}
        data['type'] = 'cone'
        return render_geometry_shape_enhanced()
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


# LOGGING AND DEBUGGING
def log_ai_system_status():
    """Log the current AI system status"""
    logging.info("ðŸ¤– AI VALUE ASSIGNMENT SYSTEM STATUS:")
    logging.info(f"   âœ… Backend Value Assignment: Active")
    logging.info(f"   ðŸŽ¯ Shape Detection: Pattern-based")
    logging.info(f"   ðŸ“ Supported Shapes: {len(value_assignment_system.shape_templates)}")
    logging.info(f"   ðŸ”§ Render Endpoints: Enhanced")
    logging.info(f"   ðŸ“Š Frontend Compatible: Yes")


# Initialize AI system on startup
try:
    log_ai_system_status()
    logging.info("âœ… Backend AI system initialized and ready for frontend integration")
except Exception as e:
    logging.error(f"âŒ Error initializing AI system: {e}")


print("ðŸ¤– BACKEND-FRONTEND BLEND COMPLETE!")
print("âœ… FIXED ENDPOINTS:")
print("   ðŸ“ /api/generate-geometry-quiz-atomic (main endpoint)")
print("   ðŸŽ¨ /api/geometry/render-shape-ai (AI shape rendering)")
print("   ðŸ”„ /api/regenerate-geometry-question (AI regeneration)")
print("   ðŸ“ /api/geometry/render-shape (enhanced)")
print("   ðŸ“Š /api/get-geometry-quiz/<id> (AI support)")
print("   ðŸ”§ All specific shape endpoints updated")
print("")
print("ðŸŽ¯ BACKEND AI CAPABILITIES:")
print("   âœ… Question text analysis for shape detection")
print("   ðŸ“ Automatic value extraction and assignment")
print("   ðŸ§® Derived value calculation (area, volume, etc.)")
print("   ðŸ”’ Integration with geometry lockout system")
print("   ðŸŽ¨ Enhanced shape rendering pipeline")
print("   ðŸ“‹ Frontend-compatible response format")
print("")
print("ðŸš€ SYSTEM READY: Frontend AI calls will work with backend logic!")


# GEOMETRIC TRANSFORMATIONS BACKEND SYSTEM
# Adds reflection, rotation, translation, and dilation to the geometry quiz system

import json
import logging
import uuid
import math
import random
import numpy as np
from typing import Dict, List, Tuple, Any, Optional

class GeometryTransformationsSystem:
    """System for handling geometric transformations in quiz questions"""
    
    def __init__(self):
        self.transformation_types = {
            'reflection': {
                'axes': ['x-axis', 'y-axis', 'line y=x', 'line y=-x'],
                'description': 'Mirror image across a line',
                'difficulty_levels': {
                    'elementary': ['x-axis', 'y-axis'],
                    'middle': ['x-axis', 'y-axis', 'line y=x'],
                    'high': ['x-axis', 'y-axis', 'line y=x', 'line y=-x'],
                    'college': ['x-axis', 'y-axis', 'line y=x', 'line y=-x']
                }
            },
            'rotation': {
                'angles': [90, 180, 270, 45, 135, 225, 315],
                'centers': ['origin', 'point'],
                'description': 'Turning a shape around a point',
                'difficulty_levels': {
                    'elementary': [90, 180, 270],
                    'middle': [90, 180, 270, 45],
                    'high': [90, 180, 270, 45, 135],
                    'college': [90, 180, 270, 45, 135, 225, 315]
                }
            },
            'translation': {
                'directions': ['horizontal', 'vertical', 'diagonal'],
                'description': 'Sliding a shape to a new position',
                'max_units': {
                    'elementary': 8,
                    'middle': 12,
                    'high': 15,
                    'college': 20
                }
            },
            'dilation': {
                'scale_factors': [0.5, 1.5, 2, 3, 0.25, 0.75, 4],
                'centers': ['origin', 'point'],
                'description': 'Resizing a shape by a scale factor',
                'difficulty_levels': {
                    'elementary': [2, 3, 0.5],
                    'middle': [2, 3, 0.5, 1.5],
                    'high': [2, 3, 0.5, 1.5, 0.25, 4],
                    'college': [0.5, 1.5, 2, 3, 0.25, 0.75, 4]
                }
            }
        }
        
        # Standard shapes for transformations
        self.base_shapes = {
            'triangle': [(2, 3), (6, 3), (4, 7)],
            'square': [(1, 1), (4, 1), (4, 4), (1, 4)],
            'rectangle': [(1, 2), (5, 2), (5, 6), (1, 6)],
            'pentagon': [(3, 1), (6, 2), (5, 5), (1, 5), (0, 2)],
            'hexagon': [(2, 0), (4, 0), (5, 2), (4, 4), (2, 4), (1, 2)]
        }
    
    def generate_reflection_data(self, grade_level='high', shape_type='triangle'):
        """Generate reflection transformation data"""
        try:
            # Get original shape coordinates
            original_coords = self.base_shapes.get(shape_type, self.base_shapes['triangle'])
            
            # Select reflection axis based on grade level
            available_axes = self.transformation_types['reflection']['difficulty_levels'].get(
                grade_level, ['x-axis', 'y-axis']
            )
            reflection_axis = random.choice(available_axes)
            
            # Calculate reflected coordinates
            reflected_coords = self._apply_reflection(original_coords, reflection_axis)
            
            return {
                'transformation_type': 'reflection',
                'shape_type': shape_type,
                'original_coordinates': original_coords,
                'transformed_coordinates': reflected_coords,
                'reflection_axis': reflection_axis,
                'ai_assigned': True,
                'validation_passed': True,
                'description': f'Reflection across {reflection_axis}'
            }
        except Exception as e:
            logging.error(f"Error generating reflection data: {e}")
            return None
    
    def generate_rotation_data(self, grade_level='high', shape_type='triangle'):
        """Generate rotation transformation data"""
        try:
            # Get original shape coordinates
            original_coords = self.base_shapes.get(shape_type, self.base_shapes['triangle'])
            
            # Select rotation angle based on grade level
            available_angles = self.transformation_types['rotation']['difficulty_levels'].get(
                grade_level, [90, 180, 270]
            )
            rotation_angle = random.choice(available_angles)
            
            # For now, always rotate around origin (can be enhanced later)
            center_of_rotation = (0, 0)
            
            # Calculate rotated coordinates
            rotated_coords = self._apply_rotation(original_coords, rotation_angle, center_of_rotation)
            
            return {
                'transformation_type': 'rotation',
                'shape_type': shape_type,
                'original_coordinates': original_coords,
                'transformed_coordinates': rotated_coords,
                'rotation_angle': rotation_angle,
                'center_of_rotation': center_of_rotation,
                'ai_assigned': True,
                'validation_passed': True,
                'description': f'Rotation {rotation_angle}Â° around origin'
            }
        except Exception as e:
            logging.error(f"Error generating rotation data: {e}")
            return None
    
    def generate_translation_data(self, grade_level='high', shape_type='triangle'):
        """Generate translation transformation data"""
        try:
            # Get original shape coordinates
            original_coords = self.base_shapes.get(shape_type, self.base_shapes['triangle'])
            
            # Generate translation vector based on grade level
            max_units = self.transformation_types['translation']['max_units'].get(grade_level, 10)
            
            # Random translation vector
            dx = random.randint(-max_units, max_units)
            dy = random.randint(-max_units, max_units)
            
            # Ensure it's not zero translation
            if dx == 0 and dy == 0:
                dx, dy = random.choice([(3, 0), (0, 3), (3, 3), (-3, 3)])
            
            translation_vector = (dx, dy)
            
            # Calculate translated coordinates
            translated_coords = self._apply_translation(original_coords, translation_vector)
            
            return {
                'transformation_type': 'translation',
                'shape_type': shape_type,
                'original_coordinates': original_coords,
                'transformed_coordinates': translated_coords,
                'translation_vector': translation_vector,
                'ai_assigned': True,
                'validation_passed': True,
                'description': f'Translation by vector ({dx}, {dy})'
            }
        except Exception as e:
            logging.error(f"Error generating translation data: {e}")
            return None
    
    def generate_dilation_data(self, grade_level='high', shape_type='triangle'):
        """Generate dilation transformation data"""
        try:
            # Get original shape coordinates
            original_coords = self.base_shapes.get(shape_type, self.base_shapes['triangle'])
            
            # Select scale factor based on grade level
            available_factors = self.transformation_types['dilation']['difficulty_levels'].get(
                grade_level, [2, 3, 0.5]
            )
            scale_factor = random.choice(available_factors)
            
            # For now, always dilate from origin (can be enhanced later)
            center_of_dilation = (0, 0)
            
            # Calculate dilated coordinates
            dilated_coords = self._apply_dilation(original_coords, scale_factor, center_of_dilation)
            
            return {
                'transformation_type': 'dilation',
                'shape_type': shape_type,
                'original_coordinates': original_coords,
                'transformed_coordinates': dilated_coords,
                'scale_factor': scale_factor,
                'center_of_dilation': center_of_dilation,
                'ai_assigned': True,
                'validation_passed': True,
                'description': f'Dilation by scale factor {scale_factor} from origin'
            }
        except Exception as e:
            logging.error(f"Error generating dilation data: {e}")
            return None
    
    def _apply_reflection(self, coordinates, reflection_axis):
        """Apply reflection transformation to coordinates"""
        reflected = []
        
        for x, y in coordinates:
            if reflection_axis == 'x-axis':
                reflected.append((x, -y))
            elif reflection_axis == 'y-axis':
                reflected.append((-x, y))
            elif reflection_axis == 'line y=x':
                reflected.append((y, x))
            elif reflection_axis == 'line y=-x':
                reflected.append((-y, -x))
            else:
                reflected.append((x, y))  # No transformation for unknown axis
        
        return reflected
    
    def _apply_rotation(self, coordinates, angle_degrees, center=(0, 0)):
        """Apply rotation transformation to coordinates"""
        angle_rad = math.radians(angle_degrees)
        cos_angle = math.cos(angle_rad)
        sin_angle = math.sin(angle_rad)
        
        rotated = []
        cx, cy = center
        
        for x, y in coordinates:
            # Translate to origin
            tx, ty = x - cx, y - cy
            
            # Apply rotation
            rx = tx * cos_angle - ty * sin_angle
            ry = tx * sin_angle + ty * cos_angle
            
            # Translate back and round to nearest integer
            new_x = round(rx + cx)
            new_y = round(ry + cy)
            
            rotated.append((new_x, new_y))
        
        return rotated
    
    def _apply_translation(self, coordinates, translation_vector):
        """Apply translation transformation to coordinates"""
        dx, dy = translation_vector
        return [(x + dx, y + dy) for x, y in coordinates]
    
    def _apply_dilation(self, coordinates, scale_factor, center=(0, 0)):
        """Apply dilation transformation to coordinates"""
        dilated = []
        cx, cy = center
        
        for x, y in coordinates:
            # Apply dilation formula: new_point = center + scale_factor * (point - center)
            new_x = cx + scale_factor * (x - cx)
            new_y = cy + scale_factor * (y - cy)
            
            # Round to reasonable precision
            new_x = round(new_x, 1) if new_x != int(new_x) else int(new_x)
            new_y = round(new_y, 1) if new_y != int(new_y) else int(new_y)
            
            dilated.append((new_x, new_y))
        
        return dilated
    
    def detect_transformation_from_question(self, question_text):
        """Detect transformation type from question text"""
        text_lower = question_text.lower()
        
        transformation_keywords = {
            'reflection': ['reflect', 'reflected', 'reflection', 'mirror', 'flip'],
            'rotation': ['rotate', 'rotated', 'rotation', 'turn', 'turned'],
            'translation': ['translate', 'translated', 'translation', 'slide', 'moved', 'shift'],
            'dilation': ['dilate', 'dilated', 'dilation', 'scale', 'resize', 'enlarge', 'shrink']
        }
        
        for transform_type, keywords in transformation_keywords.items():
            if any(keyword in text_lower for keyword in keywords):
                return transform_type
        
        return None
    
    def process_transformation_question(self, question_text, grade_level='high'):
        """Process a question to generate transformation data"""
        # Detect transformation type
        transformation_type = self.detect_transformation_from_question(question_text)
        
        if not transformation_type:
            return {
                'ai_assigned': False,
                'error': 'No transformation detected in question'
            }
        
        # Detect shape type
        shape_type = self._detect_shape_from_question(question_text)
        
        # Generate transformation data based on type
        if transformation_type == 'reflection':
            return self.generate_reflection_data(grade_level, shape_type)
        elif transformation_type == 'rotation':
            return self.generate_rotation_data(grade_level, shape_type)
        elif transformation_type == 'translation':
            return self.generate_translation_data(grade_level, shape_type)
        elif transformation_type == 'dilation':
            return self.generate_dilation_data(grade_level, shape_type)
        
        return {
            'ai_assigned': False,
            'error': f'Transformation type {transformation_type} not supported'
        }
    
    def _detect_shape_from_question(self, question_text):
        """Detect shape type from question text"""
        text_lower = question_text.lower()
        
        shape_keywords = {
            'triangle': ['triangle', 'triangular'],
            'square': ['square'],
            'rectangle': ['rectangle', 'rectangular'],
            'pentagon': ['pentagon'],
            'hexagon': ['hexagon']
        }
        
        for shape_type, keywords in shape_keywords.items():
            if any(keyword in text_lower for keyword in keywords):
                return shape_type
        
        return 'triangle'  # Default shape


# Initialize the transformations system
transformations_system = GeometryTransformationsSystem()

# Enhanced Value Assignment System with Transformations
class EnhancedGeometryValueAssignmentSystem(GeometryValueAssignmentSystem):
    """Enhanced system that includes transformations"""
    
    def __init__(self):
        super().__init__()
        self.transformations = transformations_system
        
        # Add transformations to shape templates
        self.shape_templates['transformations'] = {
            'required_fields': ['transformation_type', 'original_coordinates', 'transformed_coordinates'],
            'optional_fields': ['description'],
            'types': ['reflection', 'rotation', 'translation', 'dilation']
        }
    
    def process_question_for_ai_values(self, question_text, grade_level='high'):
        """Enhanced method that includes transformation detection"""
        # First check if it's a transformation question
        transformation_data = self.transformations.process_transformation_question(question_text, grade_level)
        
        if transformation_data.get('ai_assigned'):
            logging.info(f"ðŸ”„ TRANSFORMATION: Detected {transformation_data['transformation_type']}")
            return transformation_data
        
        # Otherwise, use the original shape detection
        return super().process_question_for_ai_values(question_text)

    def extract_values_from_question(self, question_text, shape_type):
        """OVERRIDE: Extract values with proper logging - FIXED VERSION"""
        import re
        import logging
        
        logging.info(f"\n{'='*80}")
        logging.info(f"ðŸ” ENHANCED EXTRACTION START")
        logging.info(f"Question: {question_text[:150]}...")
        logging.info(f"Shape Type: {shape_type}")
        
        extracted_values = {}
        
        if not question_text:
            logging.info(f"âŒ No question text!")
            return extracted_values
        
        text_lower = question_text.lower()
        
        # Find ALL numbers
        numbers = re.findall(r'\d+(?:\.\d+)?', question_text)
        numbers = [float(n) for n in numbers]
        logging.info(f"ðŸ“Š Found numbers: {numbers}")
        
        # ==================== TRIANGLES ====================
        if 'triangle' in shape_type.lower():
            logging.info(f"ðŸ”º EXTRACTION: Processing triangle (type: {shape_type})")

            # ========== TRIANGLE TYPE-SPECIFIC EXTRACTION ==========

            # EQUILATERAL TRIANGLE: All sides equal
            if 'equilateral' in shape_type.lower() or 'equilateral' in text_lower:
                # Patterns: "side length of X", "has a side of X", "with side X"
                has_side_pattern = any(pattern in text_lower for pattern in [
                    'side length', 'side of', 'has a side', 'with side',
                    'each side', 'sides of'
                ])

                if has_side_pattern and numbers:
                    side = numbers[0]
                    extracted_values['side_a'] = side
                    extracted_values['side_b'] = side
                    extracted_values['side_c'] = side
                    extracted_values['triangle_type'] = 'equilateral'
                    # Calculate height for rendering: h = (âˆš3/2) Ã— side
                    import math
                    extracted_values['height'] = (math.sqrt(3) / 2) * side
                    logging.info(f"âœ… EQUILATERAL: side={side}, height={extracted_values['height']:.2f}")
                    return extracted_values
                elif numbers:
                    # Fallback: use first number
                    side = numbers[0]
                    extracted_values['side_a'] = side
                    extracted_values['side_b'] = side
                    extracted_values['side_c'] = side
                    extracted_values['triangle_type'] = 'equilateral'
                    import math
                    extracted_values['height'] = (math.sqrt(3) / 2) * side
                    logging.info(f"âœ… EQUILATERAL (fallback): side={side}")
                    return extracted_values

            # ISOSCELES TRIANGLE: Two equal sides + base
            elif 'isosceles' in shape_type.lower() or 'isosceles' in text_lower:
                # Multiple patterns for isosceles triangles
                has_isosceles_pattern = any(pattern in text_lower for pattern in [
                    'two equal sides', 'equal sides of', 'has two equal sides',
                    'with two equal sides', 'isosceles triangle has'
                ])

                if has_isosceles_pattern and len(numbers) >= 2:
                    equal_side = numbers[0]
                    base = numbers[1]
                    extracted_values['side_a'] = equal_side
                    extracted_values['side_b'] = equal_side
                    extracted_values['side_c'] = base
                    extracted_values['base'] = base
                    extracted_values['triangle_type'] = 'isosceles'
                    # Calculate height: h = âˆš(equal_sideÂ² - (base/2)Â²)
                    import math
                    if equal_side**2 >= (base/2)**2:
                        extracted_values['height'] = math.sqrt(equal_side**2 - (base/2)**2)
                    logging.info(f"âœ… ISOSCELES: equal_sides={equal_side}, base={base}, height={extracted_values.get('height', 'N/A')}")
                    return extracted_values

            # SCALENE TRIANGLE: All three sides different
            elif 'scalene' in shape_type.lower() or 'scalene' in text_lower:
                # More robust pattern matching for scalene triangles
                # Patterns: "sides of X cm, Y cm, and Z cm" or "sides X, Y, Z" or "has sides of"
                has_sides_mentioned = any(pattern in text_lower for pattern in [
                    'sides of', 'side lengths', 'sides are', 'has sides',
                    'with sides', 'sides measure', 'sides:', 'sides,'
                ])

                if has_sides_mentioned and len(numbers) >= 3:
                    extracted_values['side_a'] = numbers[0]
                    extracted_values['side_b'] = numbers[1]
                    extracted_values['side_c'] = numbers[2]
                    # Also set triangle_type to ensure scalene rendering
                    extracted_values['triangle_type'] = 'scalene'
                    logging.info(f"âœ… SCALENE: side_a={numbers[0]}, side_b={numbers[1]}, side_c={numbers[2]}")
                    return extracted_values
                elif len(numbers) >= 3:
                    # Fallback: if we have 3 numbers and it's a scalene triangle, use them
                    extracted_values['side_a'] = numbers[0]
                    extracted_values['side_b'] = numbers[1]
                    extracted_values['side_c'] = numbers[2]
                    extracted_values['triangle_type'] = 'scalene'
                    logging.info(f"âœ… SCALENE (fallback): side_a={numbers[0]}, side_b={numbers[1]}, side_c={numbers[2]}")
                    return extracted_values

            # OBTUSE/ACUTE TRIANGLES: Usually given as base + height
            elif 'obtuse' in shape_type.lower() or 'acute' in shape_type.lower():
                if 'base' in text_lower and 'height' in text_lower and len(numbers) >= 2:
                    extracted_values['base'] = numbers[0]
                    extracted_values['height'] = numbers[1]
                    logging.info(f"âœ… {shape_type.upper()}: base={numbers[0]}, height={numbers[1]}")
                    if len(numbers) >= 3:
                        # If 3 sides given
                        extracted_values['side_a'] = numbers[0]
                        extracted_values['side_b'] = numbers[1]
                        extracted_values['side_c'] = numbers[2]
                    return extracted_values

            # ========== GENERIC TRIANGLE PATTERNS (fallback) ==========

            # Handle "one side... other side..." pattern
            if 'one side' in text_lower and 'other side' in text_lower:
                if len(numbers) >= 2:
                    # These are the two legs of the right triangle
                    extracted_values['side1'] = numbers[0]
                    extracted_values['side2'] = numbers[1]
                    # Also set as base and height for rendering
                    extracted_values['base'] = numbers[0]
                    extracted_values['height'] = numbers[1]
                    logging.info(f"âœ… EXTRACTION: side1={numbers[0]}, side2={numbers[1]} (from 'one side...other side' pattern)")
                    return extracted_values

            # Handle "two sides that measure X and Y" pattern
            if 'two sides' in text_lower or 'sides that measure' in text_lower:
                if len(numbers) >= 2:
                    extracted_values['side1'] = numbers[0]
                    extracted_values['side2'] = numbers[1]
                    extracted_values['base'] = numbers[0]
                    extracted_values['height'] = numbers[1]
                    logging.info(f"âœ… EXTRACTION: side1={numbers[0]}, side2={numbers[1]} (from 'two sides' pattern)")
                    return extracted_values
            
            # BASE (existing code continues...)
            if 'base' in text_lower:
                base_match = re.search(r'base\s+of\s+(\d+(?:\.\d+)?)', text_lower)
                if base_match:
                    extracted_values['base'] = float(base_match.group(1))
                    logging.info(f"âœ… Extracted base (regex): {extracted_values['base']}")
                elif numbers:
                    extracted_values['base'] = numbers[0]
                    logging.info(f"âœ… Extracted base (first number): {extracted_values['base']}")
            
            # HEIGHT - FIXED VERSION
            if 'height' in text_lower:
                # Only extract height if the question explicitly mentions it with a value
                # NOT if the question is ASKING for the height
                
                # Check if height has an actual value in the question
                height_match = re.search(r'height\s+of\s+(\d+(?:\.\d+)?)', text_lower)
                if height_match:
                    extracted_values['height'] = float(height_match.group(1))
                    logging.info(f"âœ… EXTRACTION: height (from 'height of X') = {extracted_values['height']}")
                elif len(numbers) >= 2 and 'hypotenuse' not in text_lower:
                    # Only use second number as height if NOT asking about hypotenuse
                    extracted_values['height'] = numbers[1]
                    logging.info(f"âœ… EXTRACTION: height (second number) = {extracted_values['height']}")
                else:
                    logging.info(f"âš ï¸ EXTRACTION: 'height' mentioned but question is asking for it, not extracting")
            
            # HYPOTENUSE
            if 'hypotenuse' in text_lower:
                hyp_match = re.search(r'hypotenuse\s+of\s+(\d+(?:\.\d+)?)', text_lower)
                if hyp_match:
                    extracted_values['hypotenuse'] = float(hyp_match.group(1))
                    logging.info(f"âœ… EXTRACTION: hypotenuse = {extracted_values['hypotenuse']}")
                    
                    # DON'T set height if we're extracting hypotenuse!
                    # The question is ASKING for height, so don't give it away
                    
                elif len(numbers) >= 2:
                    # Only set hypotenuse from second number if 'base' was found
                    if 'base' in extracted_values and 'height' not in extracted_values:
                        extracted_values['hypotenuse'] = numbers[1]
                        logging.info(f"âœ… EXTRACTION: hypotenuse (second number) = {extracted_values['hypotenuse']}")
            
            # SIDES (for "two sides that measure X and Y")
            if 'two sides' in text_lower or 'sides that measure' in text_lower:
                if len(numbers) >= 2:
                    extracted_values['side1'] = numbers[0]
                    extracted_values['side2'] = numbers[1]
                    logging.info(f"âœ… Extracted side1={numbers[0]}, side2={numbers[1]}")
            
            # FALLBACK
            if not extracted_values and len(numbers) >= 2:
                extracted_values['base'] = numbers[0]
                extracted_values['height'] = numbers[1]
                logging.info(f"âš ï¸ FALLBACK: base={numbers[0]}, height={numbers[1]}")
            elif not extracted_values and len(numbers) == 1:
                extracted_values['base'] = numbers[0]
                logging.info(f"âš ï¸ FALLBACK: base={numbers[0]}")
        
        # ==================== PARALLEL LINES ====================
        elif 'parallel' in shape_type.lower():
            logging.info(f"ðŸ“ Processing PARALLEL LINES")
            
            angle_match = re.search(r'angle\s+\w+\s+is\s+(\d+(?:\.\d+)?)', text_lower)
            if angle_match:
                extracted_values['angle1'] = float(angle_match.group(1))
                extracted_values['angle2'] = float(angle_match.group(1))
                logging.info(f"âœ… Extracted angle={extracted_values['angle1']}")
            elif numbers:
                extracted_values['angle1'] = numbers[0]
                extracted_values['angle2'] = numbers[0]
                logging.info(f"âš ï¸ FALLBACK: angle={numbers[0]}")
        
        # ==================== ANGLES ====================
        elif 'complementary' in shape_type.lower() or 'supplementary' in shape_type.lower():
            logging.info(f"ðŸ“ Processing ANGLES")
            
            angle_match = re.search(r'(\d+(?:\.\d+)?)\s*degrees?', text_lower)
            if angle_match:
                extracted_values['angle1'] = float(angle_match.group(1))
                
                if 'complementary' in shape_type.lower():
                    extracted_values['angle2'] = 90 - extracted_values['angle1']
                else:
                    extracted_values['angle2'] = 180 - extracted_values['angle1']
                
                logging.info(f"âœ… Extracted angle1={extracted_values['angle1']}, angle2={extracted_values['angle2']}")
            elif numbers:
                extracted_values['angle1'] = numbers[0]
                logging.info(f"âš ï¸ FALLBACK: angle1={numbers[0]}")
        
        # ==================== CIRCLE ====================
        elif shape_type == 'circle':
            logging.info(f"â­• Processing CIRCLE")
            
            if 'radius' in text_lower and numbers:
                extracted_values['radius'] = numbers[0]
                logging.info(f"âœ… Extracted radius={numbers[0]}")
            elif 'diameter' in text_lower and numbers:
                extracted_values['radius'] = numbers[0] / 2
                logging.info(f"âœ… Extracted radius={numbers[0]/2} (from diameter)")
        
        # ==================== SECTOR ====================
        elif shape_type == 'sector':
            logging.info(f"ðŸ¥§ Processing SECTOR")
            
            if len(numbers) >= 2:
                extracted_values['radius'] = numbers[0]
                extracted_values['central_angle'] = numbers[1]
                logging.info(f"âœ… Extracted radius={numbers[0]}, central_angle={numbers[1]}")
            elif len(numbers) == 1:
                extracted_values['radius'] = numbers[0]
                logging.info(f"âœ… Extracted radius={numbers[0]}")
        
        # ==================== CYLINDER ====================
        elif shape_type == 'cylinder':
            logging.info(f"ðŸ¥« Processing CYLINDER")

            if len(numbers) >= 2:
                extracted_values['radius'] = numbers[0]
                extracted_values['height'] = numbers[1]
                logging.info(f"âœ… Extracted radius={numbers[0]}, height={numbers[1]}")

        # ==================== CUBE ====================
        elif shape_type == 'cube':
            logging.info(f"ðŸ§Š Processing CUBE")

            # Pattern: "side length of X" or "edge length of X" or "sides of X"
            side_patterns = [
                r'(?:side|edge)\s+length\s+(?:of\s+)?(\d+(?:\.\d+)?)',
                r'sides?\s+(?:of\s+)?(\d+(?:\.\d+)?)\s*(?:cm|m|mm|inches?|in|ft|feet)',
                r'(\d+(?:\.\d+)?)\s*(?:cm|m|mm|inches?|in|ft|feet)?\s*(?:cube|cubes)',
                r'cube.*?(\d+(?:\.\d+)?)\s*(?:cm|m|mm|inches?|in|ft|feet)'
            ]

            for pattern in side_patterns:
                if 'side' not in extracted_values:
                    match = re.search(pattern, text_lower)
                    if match:
                        extracted_values['side'] = float(match.group(1))
                        extracted_values['edge_length'] = float(match.group(1))
                        logging.info(f"âœ… EXTRACTION: side = {extracted_values['side']}")
                        break

            # Fallback: use first number
            if 'side' not in extracted_values and numbers:
                extracted_values['side'] = numbers[0]
                extracted_values['edge_length'] = numbers[0]
                logging.info(f"âš ï¸ FALLBACK: side={numbers[0]}")

        # ==================== SPHERE ====================
        elif shape_type == 'sphere':
            logging.info(f"ðŸ”µ Processing SPHERE")

            # Pattern: "radius of X" or "diameter of X"
            if 'radius' in text_lower:
                radius_pattern = r'radius\s+(?:of\s+)?(\d+(?:\.\d+)?)'
                match = re.search(radius_pattern, text_lower)
                if match:
                    extracted_values['radius'] = float(match.group(1))
                    logging.info(f"âœ… EXTRACTION: radius = {extracted_values['radius']}")
            elif 'diameter' in text_lower:
                diameter_pattern = r'diameter\s+(?:of\s+)?(\d+(?:\.\d+)?)'
                match = re.search(diameter_pattern, text_lower)
                if match:
                    extracted_values['radius'] = float(match.group(1)) / 2
                    extracted_values['diameter'] = float(match.group(1))
                    logging.info(f"âœ… EXTRACTION: radius = {extracted_values['radius']} (from diameter)")

            # Fallback: use first number as radius
            if 'radius' not in extracted_values and numbers:
                extracted_values['radius'] = numbers[0]
                logging.info(f"âš ï¸ FALLBACK: radius={numbers[0]}")

        # ==================== CONE ====================
        elif shape_type == 'cone':
            logging.info(f"ðŸ”º Processing CONE")

            # Extract radius and height
            radius_pattern = r'radius\s+(?:of\s+)?(\d+(?:\.\d+)?)'
            height_pattern = r'height\s+(?:of\s+)?(\d+(?:\.\d+)?)'

            radius_match = re.search(radius_pattern, text_lower)
            height_match = re.search(height_pattern, text_lower)

            if radius_match:
                extracted_values['radius'] = float(radius_match.group(1))
                logging.info(f"âœ… EXTRACTION: radius = {extracted_values['radius']}")
            if height_match:
                extracted_values['height'] = float(height_match.group(1))
                logging.info(f"âœ… EXTRACTION: height = {extracted_values['height']}")

            # Fallback: use first two numbers
            if not extracted_values and len(numbers) >= 2:
                extracted_values['radius'] = numbers[0]
                extracted_values['height'] = numbers[1]
                logging.info(f"âš ï¸ FALLBACK: radius={numbers[0]}, height={numbers[1]}")

        # ==================== TRIANGULAR PRISM ====================
        elif shape_type == 'triangular_prism':
            logging.info(f"ðŸ”ºðŸ“¦ Processing TRIANGULAR PRISM")
            import math

            # Detect triangle type from question text
            triangle_type = None
            if 'right isosceles' in text_lower:
                triangle_type = 'right_isosceles'
            elif 'right' in text_lower:
                triangle_type = 'right'
            elif 'scalene' in text_lower:
                triangle_type = 'scalene'
            elif 'isosceles' in text_lower:
                triangle_type = 'isosceles'
            elif 'equilateral' in text_lower:
                triangle_type = 'equilateral'

            extracted_values['triangle_type'] = triangle_type or 'equilateral'
            logging.info(f"âœ… Detected triangle type: {extracted_values['triangle_type']}")

            # Extract measurements based on triangle type
            if triangle_type == 'scalene':
                # Scalene: Look for three different sides
                # Pattern: "sides of X cm, Y cm, and Z cm"
                sides_pattern = r'sides?\s+of\s+(\d+(?:\.\d+)?)\s*cm,?\s*(\d+(?:\.\d+)?)\s*cm,?\s*and\s*(\d+(?:\.\d+)?)\s*cm'
                sides_match = re.search(sides_pattern, question_text)

                if sides_match:
                    extracted_values['side_a'] = float(sides_match.group(1))
                    extracted_values['side_b'] = float(sides_match.group(2))
                    extracted_values['side_c'] = float(sides_match.group(3))
                    logging.info(f"âœ… Extracted scalene sides: a={extracted_values['side_a']}, b={extracted_values['side_b']}, c={extracted_values['side_c']}")
                elif len(numbers) >= 4:
                    # First 3 numbers are triangle sides, last is prism height
                    extracted_values['side_a'] = numbers[0]
                    extracted_values['side_b'] = numbers[1]
                    extracted_values['side_c'] = numbers[2]
                    logging.info(f"âœ… Extracted scalene sides (fallback): a={numbers[0]}, b={numbers[1]}, c={numbers[2]}")

            elif triangle_type == 'right' or triangle_type == 'right_isosceles':
                # Right triangle: Look for legs/base and height
                # Pattern: "legs of X cm" or "base X cm and height Y cm"
                if 'legs of' in text_lower or 'leg of' in text_lower:
                    leg_pattern = r'legs?\s+of\s+(\d+(?:\.\d+)?)\s*cm'
                    leg_match = re.search(leg_pattern, question_text)
                    if leg_match:
                        leg = float(leg_match.group(1))
                        extracted_values['leg_a'] = leg
                        if triangle_type == 'right_isosceles':
                            extracted_values['leg_b'] = leg
                        logging.info(f"âœ… Extracted right triangle leg: {leg}")

                # Extract base and tri_height
                base_pattern = r'base\s+(?:of\s+)?(\d+(?:\.\d+)?)\s*cm'
                tri_height_pattern = r'height\s+(?:of\s+)?(\d+(?:\.\d+)?)\s*cm'

                base_match = re.search(base_pattern, question_text)
                height_match = re.search(tri_height_pattern, question_text)

                if base_match:
                    extracted_values['leg_a'] = float(base_match.group(1))
                    extracted_values['base'] = float(base_match.group(1))
                    logging.info(f"âœ… Extracted base: {extracted_values['base']}")

                # Check if we have multiple height mentions (triangle height vs prism height)
                all_height_matches = re.findall(r'height\s+(?:of\s+)?(\d+(?:\.\d+)?)\s*cm', question_text)
                if len(all_height_matches) >= 2:
                    # First is triangle height, second is prism height
                    extracted_values['leg_b'] = float(all_height_matches[0])
                    extracted_values['tri_height'] = float(all_height_matches[0])
                    extracted_values['prism_height'] = float(all_height_matches[1])
                    logging.info(f"âœ… Extracted tri_height: {extracted_values['tri_height']}, prism_height: {extracted_values['prism_height']}")
                elif height_match:
                    # Only one height mentioned - need to check context
                    height_val = float(height_match.group(1))
                    if 'prism height' in text_lower or 'height of the prism' in text_lower:
                        extracted_values['prism_height'] = height_val
                    else:
                        extracted_values['leg_b'] = height_val
                        extracted_values['tri_height'] = height_val
                    logging.info(f"âœ… Extracted height: {height_val}")

            elif triangle_type == 'isosceles':
                # Isosceles: Look for equal sides and base
                if 'equal sides' in text_lower or 'equal side' in text_lower:
                    equal_pattern = r'equal sides?\s+of\s+(\d+(?:\.\d+)?)\s*cm'
                    equal_match = re.search(equal_pattern, question_text)
                    if equal_match:
                        extracted_values['equal_side'] = float(equal_match.group(1))
                        extracted_values['leg'] = float(equal_match.group(1))
                        logging.info(f"âœ… Extracted equal sides: {extracted_values['equal_side']}")

                base_pattern = r'base\s+of\s+(\d+(?:\.\d+)?)\s*cm'
                base_match = re.search(base_pattern, question_text)
                if base_match:
                    extracted_values['base'] = float(base_match.group(1))
                    extracted_values['base_side'] = float(base_match.group(1))
                    logging.info(f"âœ… Extracted base: {extracted_values['base']}")

            else:  # equilateral or default
                # Equilateral: One side length
                side_pattern = r'side(?:s)?\s+(?:of\s+)?(\d+(?:\.\d+)?)\s*cm'
                side_match = re.search(side_pattern, question_text)
                if side_match:
                    side = float(side_match.group(1))
                    extracted_values['base_side'] = side
                    extracted_values['side'] = side
                    logging.info(f"âœ… Extracted equilateral side: {side}")

            # Extract prism height (depth)
            # Look for "prism height", "height of the prism", or the last number if not already assigned
            prism_height_patterns = [
                r'prism height\s+(?:of\s+)?(\d+(?:\.\d+)?)\s*cm',
                r'height of the prism\s+(?:is\s+)?(\d+(?:\.\d+)?)\s*cm',
                r'height\s+(?:is\s+)?(\d+(?:\.\d+)?)\s*cm'
            ]

            for pattern in prism_height_patterns:
                match = re.search(pattern, question_text)
                if match and 'prism_height' not in extracted_values:
                    extracted_values['prism_height'] = float(match.group(1))
                    extracted_values['height'] = float(match.group(1))
                    logging.info(f"âœ… Extracted prism height: {extracted_values['prism_height']}")
                    break

            # Fallback: use last number as prism height if not assigned
            if 'prism_height' not in extracted_values and 'height' not in extracted_values and numbers:
                extracted_values['prism_height'] = numbers[-1]
                extracted_values['height'] = numbers[-1]
                logging.info(f"âš ï¸ Fallback: Using last number as prism height: {numbers[-1]}")

            logging.info(f"ðŸŽ¯ TRIANGULAR PRISM EXTRACTION COMPLETE: {extracted_values}")

        # ==================== COORDINATE GEOMETRY ====================
        elif 'coordinate' in text_lower or ('vertices' in text_lower and '(' in question_text):
            logging.info(f"ðŸ“ EXTRACTION: Processing COORDINATE GEOMETRY")
            
            # Extract coordinates from question
            # Pattern: (x1, y1), (x2, y2), (x3, y3), etc.
            coord_pattern = r'\((\d+(?:\.\d+)?),\s*(\d+(?:\.\d+)?)\)'
            coordinates = re.findall(coord_pattern, question_text)
            
            if coordinates:
                coords = [(float(x), float(y)) for x, y in coordinates]
                logging.info(f"âœ… EXTRACTION: Found {len(coords)} coordinates: {coords}")
                
                # Store all coordinates
                extracted_values['coordinates'] = coords
                
                # Calculate dimensions based on shape type
                if 'triangle' in shape_type.lower():
                    # For right triangle: calculate base and height from coordinates
                    # Typically: (x1,y1), (x2,y1), (x2,y2) forms a right angle at (x2,y1)
                    if len(coords) >= 3:
                        # Find base (horizontal distance)
                        x_coords = [c[0] for c in coords]
                        y_coords = [c[1] for c in coords]
                        
                        base = max(x_coords) - min(x_coords)
                        height = max(y_coords) - min(y_coords)
                        
                        extracted_values['base'] = base
                        extracted_values['height'] = height
                        logging.info(f"âœ… EXTRACTION: Calculated base={base}, height={height} from coordinates")
                
                elif shape_type == 'square':
                    # For square: calculate side length
                    if len(coords) >= 2:
                        x_coords = [c[0] for c in coords]
                        y_coords = [c[1] for c in coords]
                        
                        # Side is either x-difference or y-difference (they should be equal)
                        side_x = max(x_coords) - min(x_coords)
                        side_y = max(y_coords) - min(y_coords)
                        side = max(side_x, side_y)  # Use the larger one
                        
                        extracted_values['side'] = side
                        logging.info(f"âœ… EXTRACTION: Calculated side={side} from coordinates")
                
                elif shape_type == 'rectangle':
                    # For rectangle: calculate length and width
                    if len(coords) >= 2:
                        x_coords = [c[0] for c in coords]
                        y_coords = [c[1] for c in coords]
                        
                        length = max(x_coords) - min(x_coords)
                        width = max(y_coords) - min(y_coords)
                        
                        extracted_values['length'] = length
                        extracted_values['width'] = width
                        logging.info(f"âœ… EXTRACTION: Calculated length={length}, width={width} from coordinates")
        
        # ==================== TRAPEZIUM/TRAPEZOID ====================
        elif 'trapezium' in shape_type.lower() or 'trapezoid' in shape_type.lower():
            logging.info(f"ðŸ”¶ EXTRACTION: Processing trapezium/trapezoid")

            # Pattern 1: "parallel sides of lengths X cm and Y cm"
            parallel_sides_pattern = r'parallel sides?\s+(?:of\s+)?(?:lengths?\s+)?(\d+(?:\.\d+)?)\s*(?:cm|m|mm|inches?|in|ft|feet)?\s*(?:and|,)\s*(\d+(?:\.\d+)?)'
            parallel_match = re.search(parallel_sides_pattern, text_lower)

            if parallel_match:
                extracted_values['parallel_side1'] = float(parallel_match.group(1))
                extracted_values['parallel_side2'] = float(parallel_match.group(2))
                extracted_values['base'] = extracted_values['parallel_side1']
                extracted_values['top'] = extracted_values['parallel_side2']
                logging.info(f"âœ… EXTRACTION: parallel_side1={extracted_values['parallel_side1']}, parallel_side2={extracted_values['parallel_side2']}")

            # Pattern 2: "parallel base of X cm" (legacy)
            if 'parallel_side1' not in extracted_values and 'parallel base' in text_lower:
                parallel_pattern = r'parallel base of (\d+(?:\.\d+)?)'
                matches = re.findall(parallel_pattern, text_lower)
                if len(matches) >= 1:
                    extracted_values['parallel_side1'] = float(matches[0])
                    extracted_values['base'] = float(matches[0])
                    logging.info(f"âœ… EXTRACTION: parallel_side1 = {extracted_values['parallel_side1']}")
                if len(matches) >= 2:
                    extracted_values['parallel_side2'] = float(matches[1])
                    extracted_values['top'] = float(matches[1])
                    logging.info(f"âœ… EXTRACTION: parallel_side2 = {extracted_values['parallel_side2']}")

            # Extract non-parallel sides
            non_parallel_pattern = r'non-parallel sides?\s+(?:are\s+)?(?:both\s+)?(\d+(?:\.\d+)?)'
            non_parallel_match = re.search(non_parallel_pattern, text_lower)
            if non_parallel_match:
                extracted_values['non_parallel_side'] = float(non_parallel_match.group(1))
                logging.info(f"âœ… EXTRACTION: non_parallel_side = {extracted_values['non_parallel_side']}")

            # Extract height - multiple patterns
            height_patterns = [
                r'height\s+(?:between\s+the\s+parallel\s+sides\s+)?(?:is\s+)?(\d+(?:\.\d+)?)',
                r'height\s+(?:of\s+)?(\d+(?:\.\d+)?)',
                r'(\d+(?:\.\d+)?)\s*(?:cm|m|mm|inches?|in|ft|feet)?\s+(?:high|tall|height)'
            ]
            for pattern in height_patterns:
                if 'height' not in extracted_values:
                    height_match = re.search(pattern, text_lower)
                    if height_match and 'what is the height' not in text_lower:
                        extracted_values['height'] = float(height_match.group(1))
                        logging.info(f"âœ… EXTRACTION: height = {extracted_values['height']}")
                        break

            # Fallback: use first numbers found for parallel sides
            if 'parallel_side1' not in extracted_values and len(numbers) >= 2:
                # Typically first two numbers are the parallel sides
                extracted_values['parallel_side1'] = numbers[0]
                extracted_values['parallel_side2'] = numbers[1]
                extracted_values['base'] = numbers[0]
                extracted_values['top'] = numbers[1]
                logging.info(f"âš ï¸ FALLBACK: parallel_side1={numbers[0]}, parallel_side2={numbers[1]}")

            # Calculate height from area if needed (Area = 0.5 * (a+b) * h)
            if 'height' not in extracted_values and len(numbers) >= 3:
                extracted_values['height'] = numbers[2]
                logging.info(f"âš ï¸ FALLBACK: height={numbers[2]}")
        
        # ==================== RECTANGLE ====================
        elif shape_type == 'rectangle' or 'rectangle' in shape_type.lower():
            logging.info(f"ðŸ“ EXTRACTION: Processing RECTANGLE")

            # Pattern: "length of X cm and width of Y cm" or "length X cm, width Y cm"
            length_pattern = r'length\s+(?:of\s+)?(\d+(?:\.\d+)?)\s*(?:cm|m|mm|inches?|in|ft|feet)?'
            width_pattern = r'width\s+(?:of\s+)?(\d+(?:\.\d+)?)\s*(?:cm|m|mm|inches?|in|ft|feet)?'

            length_match = re.search(length_pattern, text_lower)
            width_match = re.search(width_pattern, text_lower)

            if length_match:
                extracted_values['length'] = float(length_match.group(1))
                logging.info(f"âœ… EXTRACTION: length = {extracted_values['length']}")

            if width_match:
                extracted_values['width'] = float(width_match.group(1))
                logging.info(f"âœ… EXTRACTION: width = {extracted_values['width']}")

            # Fallback: try dimension patterns like "12 cm by 8 cm" or "12 x 8"
            if not extracted_values:
                dimension_pattern = r'(\d+(?:\.\d+)?)\s*(?:cm|m|mm|inches?|in|ft|feet)?\s*(?:by|x|Ã—)\s*(\d+(?:\.\d+)?)'
                dim_match = re.search(dimension_pattern, text_lower)
                if dim_match:
                    extracted_values['length'] = float(dim_match.group(1))
                    extracted_values['width'] = float(dim_match.group(2))
                    logging.info(f"âœ… EXTRACTION: dimensions {extracted_values['length']} x {extracted_values['width']}")

            # Final fallback: use first two numbers
            if not extracted_values and len(numbers) >= 2:
                extracted_values['length'] = numbers[0]
                extracted_values['width'] = numbers[1]
                logging.info(f"âš ï¸ FALLBACK: length={numbers[0]}, width={numbers[1]}")

        # ==================== SQUARE ====================
        elif shape_type == 'square' or 'square' in shape_type.lower():
            logging.info(f"â¬œ EXTRACTION: Processing SQUARE")

            # Pattern: "side length of X" or "side of X" or "sides of X"
            side_pattern = r'(?:side(?:s)?|side length)\s+(?:of\s+)?(\d+(?:\.\d+)?)\s*(?:cm|m|mm|inches?|in|ft|feet)?'
            side_match = re.search(side_pattern, text_lower)

            if side_match:
                extracted_values['side'] = float(side_match.group(1))
                logging.info(f"âœ… EXTRACTION: side = {extracted_values['side']}")

            # Fallback: use first number
            if not extracted_values and numbers:
                extracted_values['side'] = numbers[0]
                logging.info(f"âš ï¸ FALLBACK: side={numbers[0]}")

        # ==================== POLYGONS (Pentagon, Hexagon, etc.) ====================
        elif shape_type in ['polygon', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'nonagon', 'decagon', 'dodecagon']:
            logging.info(f"ðŸ”· EXTRACTION: Processing POLYGON ({shape_type})")

            # Map shape names to number of sides
            shape_to_sides = {
                'pentagon': 5,
                'hexagon': 6,
                'heptagon': 7,
                'octagon': 8,
                'nonagon': 9,
                'decagon': 10,
                'dodecagon': 12
            }

            # Set number of sides based on shape type
            if shape_type in shape_to_sides:
                extracted_values['sides'] = shape_to_sides[shape_type]
                extracted_values['num_sides'] = shape_to_sides[shape_type]
                logging.info(f"âœ… EXTRACTION: sides = {extracted_values['sides']} (from shape type)")

            # Pattern: "side length of X" or "sides of X cm each" or "each side is X"
            side_length_patterns = [
                r'side\s+length\s+(?:of\s+)?(\d+(?:\.\d+)?)',
                r'sides?\s+(?:of\s+)?(\d+(?:\.\d+)?)\s*(?:cm|m|mm|inches?|in|ft|feet)',
                r'each\s+side\s+(?:is\s+)?(\d+(?:\.\d+)?)',
                r'(\d+(?:\.\d+)?)\s*(?:cm|m|mm|inches?|in|ft|feet)?\s*(?:sides?|long)'
            ]

            for pattern in side_length_patterns:
                if 'side_length' not in extracted_values:
                    match = re.search(pattern, text_lower)
                    if match:
                        extracted_values['side_length'] = float(match.group(1))
                        extracted_values['side'] = float(match.group(1))
                        logging.info(f"âœ… EXTRACTION: side_length = {extracted_values['side_length']}")
                        break

            # Extract unit if present
            unit_match = re.search(r'(\d+(?:\.\d+)?)\s*(cm|m|mm|inches?|in|ft|feet)', text_lower)
            if unit_match:
                unit = unit_match.group(2)
                # Normalize unit
                if unit in ['inch', 'inches', 'in']:
                    unit = 'inches'
                elif unit in ['ft', 'feet']:
                    unit = 'feet'
                extracted_values['unit'] = unit

            # Fallback: use first number as side_length
            if 'side_length' not in extracted_values and numbers:
                extracted_values['side_length'] = numbers[0]
                extracted_values['side'] = numbers[0]
                logging.info(f"âš ï¸ FALLBACK: side_length={numbers[0]}")

            # If sides not determined from shape_type, try to extract from question
            if 'sides' not in extracted_values:
                # Pattern: "X-sided polygon" or "polygon with X sides"
                sides_pattern = r'(\d+)[- ]sided|(\d+)\s+sides'
                sides_match = re.search(sides_pattern, text_lower)
                if sides_match:
                    sides_val = sides_match.group(1) or sides_match.group(2)
                    extracted_values['sides'] = int(sides_val)
                    extracted_values['num_sides'] = int(sides_val)
                    logging.info(f"âœ… EXTRACTION: sides = {extracted_values['sides']} (from pattern)")

        # ==================== GENERIC FALLBACK ====================
        else:
            logging.info(f"â“ Generic extraction for {shape_type}")

            if numbers:
                if len(numbers) >= 1:
                    extracted_values['value1'] = numbers[0]
                if len(numbers) >= 2:
                    extracted_values['value2'] = numbers[1]
                if len(numbers) >= 3:
                    extracted_values['value3'] = numbers[2]
                logging.info(f"âš ï¸ Generic: {extracted_values}")
        
        logging.info(f"ðŸŽ¯ FINAL EXTRACTED VALUES: {extracted_values}")
        logging.info(f"{'='*80}\n")
        
        return extracted_values
        
# Replace the original value assignment system
value_assignment_system = EnhancedGeometryValueAssignmentSystem()

# TRANSFORMATION RENDERING SYSTEM
class TransformationRenderer:
    """Renders transformation visualizations"""
    
    def __init__(self):
        self.colors = {
            'original': '#3B82F6',    # Blue
            'transformed': '#10B981', # Green
            'grid': '#E5E7EB',       # Light gray
            'axis': '#6B7280'        # Gray
        }
    
    def render_transformation(self, transformation_data, hide_answer=True):
        """Render a transformation visualization"""
        try:
            import matplotlib.pyplot as plt
            import matplotlib.patches as patches
            import numpy as np
            
            fig, ax = plt.subplots(figsize=(10, 8), dpi=100)
            fig.patch.set_facecolor('white')
            ax.set_facecolor('white')
            
            # Get transformation details
            transform_type = transformation_data.get('transformation_type')
            original_coords = transformation_data.get('original_coordinates', [])
            transformed_coords = transformation_data.get('transformed_coordinates', [])
            
            if not original_coords or not transformed_coords:
                return self._create_error_image("Invalid transformation data")
            
            # Set up coordinate system
            self._setup_coordinate_grid(ax, original_coords + transformed_coords)
            
            # Draw original shape
            self._draw_shape(ax, original_coords, self.colors['original'], 'Original', alpha=0.7)
            
            # Draw transformed shape
            self._draw_shape(ax, transformed_coords, self.colors['transformed'], 'Transformed', alpha=0.7)
            
            # Add transformation-specific elements
            if transform_type == 'reflection':
                self._add_reflection_line(ax, transformation_data)
            elif transform_type == 'rotation':
                self._add_rotation_indicators(ax, transformation_data)
            elif transform_type == 'translation':
                self._add_translation_vector(ax, transformation_data)
            elif transform_type == 'dilation':
                self._add_dilation_center(ax, transformation_data)
            
            # Add title and labels
            description = transformation_data.get('description', f'{transform_type.title()} Transformation')
            ax.set_title(description, fontsize=16, fontweight='bold', pad=20)
            
            # Add legend
            ax.legend(loc='upper right', fontsize=12)
            
            # Set equal aspect ratio and grid
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.3)
            
            return self._figure_to_base64(fig)
            
        except Exception as e:
            logging.error(f"Error rendering transformation: {e}")
            return self._create_error_image(f"Rendering error: {str(e)}")
    
    def _setup_coordinate_grid(self, ax, all_coords):
        """Set up coordinate grid based on shape coordinates"""
        # Find bounds
        x_coords = [coord[0] for coord in all_coords]
        y_coords = [coord[1] for coord in all_coords]
        
        min_x, max_x = min(x_coords), max(x_coords)
        min_y, max_y = min(y_coords), max(y_coords)
        
        # Add padding
        padding = 2
        ax.set_xlim(min_x - padding, max_x + padding)
        ax.set_ylim(min_y - padding, max_y + padding)
        
        # Draw axes
        ax.axhline(y=0, color=self.colors['axis'], linewidth=1.5, alpha=0.8)
        ax.axvline(x=0, color=self.colors['axis'], linewidth=1.5, alpha=0.8)
        
        # Set integer ticks
        ax.set_xticks(range(int(min_x) - padding, int(max_x) + padding + 1))
        ax.set_yticks(range(int(min_y) - padding, int(max_y) + padding + 1))
    
    def _draw_shape(self, ax, coordinates, color, label, alpha=0.7):
        """Draw a shape given its coordinates"""
        if len(coordinates) < 2:
            return
        
        # Close the shape by adding the first point at the end
        closed_coords = coordinates + [coordinates[0]]
        x_coords = [coord[0] for coord in closed_coords]
        y_coords = [coord[1] for coord in closed_coords]
        
        # Draw filled shape
        ax.fill(x_coords, y_coords, color=color, alpha=alpha*0.3, label=label)
        
        # Draw outline
        ax.plot(x_coords, y_coords, color=color, linewidth=3, alpha=alpha)
        
        # Draw vertices
        for i, (x, y) in enumerate(coordinates):
            ax.plot(x, y, 'o', color=color, markersize=8, alpha=alpha)
            # Add coordinate labels
            ax.text(x + 0.2, y + 0.2, f'({x}, {y})', fontsize=9, 
                   color=color, fontweight='bold')
    
    def _add_reflection_line(self, ax, transformation_data):
        """Add reflection line to the plot"""
        reflection_axis = transformation_data.get('reflection_axis', '')
        
        xlim = ax.get_xlim()
        ylim = ax.get_ylim()
        
        if reflection_axis == 'x-axis':
            ax.axhline(y=0, color='red', linewidth=2, linestyle='--', alpha=0.8, label='Reflection Line')
        elif reflection_axis == 'y-axis':
            ax.axvline(x=0, color='red', linewidth=2, linestyle='--', alpha=0.8, label='Reflection Line')
        elif reflection_axis == 'line y=x':
            x_vals = np.linspace(min(xlim[0], ylim[0]), max(xlim[1], ylim[1]), 100)
            y_vals = x_vals
            ax.plot(x_vals, y_vals, color='red', linewidth=2, linestyle='--', alpha=0.8, label='y = x')
        elif reflection_axis == 'line y=-x':
            x_vals = np.linspace(min(xlim[0], -ylim[1]), max(xlim[1], -ylim[0]), 100)
            y_vals = -x_vals
            ax.plot(x_vals, y_vals, color='red', linewidth=2, linestyle='--', alpha=0.8, label='y = -x')
    
    def _add_rotation_indicators(self, ax, transformation_data):
        """Add rotation indicators to the plot"""
        center = transformation_data.get('center_of_rotation', (0, 0))
        angle = transformation_data.get('rotation_angle', 0)
        
        # Draw center of rotation
        ax.plot(center[0], center[1], 'ro', markersize=10, label='Center of Rotation')
        
        # Draw rotation arc (simplified)
        if angle != 0:
            from matplotlib.patches import Arc
            arc = Arc(center, 2, 2, angle=0, theta1=0, theta2=angle, 
                     color='red', linewidth=2, alpha=0.8)
            ax.add_patch(arc)
            
            # Add angle label
            ax.text(center[0] + 1.5, center[1] + 0.5, f'{angle}Â°', 
                   fontsize=12, fontweight='bold', color='red')
    
    def _add_translation_vector(self, ax, transformation_data):
        """Add translation vector to the plot"""
        original_coords = transformation_data.get('original_coordinates', [])
        translation_vector = transformation_data.get('translation_vector', (0, 0))
        
        if original_coords:
            # Calculate centroid of original shape
            centroid_x = sum(coord[0] for coord in original_coords) / len(original_coords)
            centroid_y = sum(coord[1] for coord in original_coords) / len(original_coords)
            
            # Draw translation vector
            dx, dy = translation_vector
            ax.annotate('', xy=(centroid_x + dx, centroid_y + dy), 
                       xytext=(centroid_x, centroid_y),
                       arrowprops=dict(arrowstyle='->', color='red', lw=3, alpha=0.8),
                       label='Translation Vector')
            
            # Add vector label
            ax.text(centroid_x + dx/2, centroid_y + dy/2 + 0.5, 
                   f'({dx}, {dy})', fontsize=12, fontweight='bold', 
                   color='red', ha='center')
    
    def _add_dilation_center(self, ax, transformation_data):
        """Add dilation center to the plot"""
        center = transformation_data.get('center_of_dilation', (0, 0))
        scale_factor = transformation_data.get('scale_factor', 1)
        
        # Draw center of dilation
        ax.plot(center[0], center[1], 'ro', markersize=10, label='Center of Dilation')
        
        # Add scale factor label
        ax.text(center[0] + 0.5, center[1] + 0.5, f'Scale: {scale_factor}', 
               fontsize=12, fontweight='bold', color='red')
    
    def _figure_to_base64(self, fig):
        """Convert matplotlib figure to base64 string"""
        try:
            import io
            import base64
            import matplotlib.pyplot as plt
            
            buffer = io.BytesIO()
            fig.savefig(buffer, format='png', bbox_inches='tight', 
                       dpi=100, facecolor='white', edgecolor='none')
            buffer.seek(0)
            image_png = buffer.getvalue()
            buffer.close()
            plt.close(fig)
            
            graphic = base64.b64encode(image_png)
            graphic = graphic.decode('utf-8')
            return f"data:image/png;base64,{graphic}"
        except Exception as e:
            logging.error(f"âŒ Error converting figure to base64: {e}")
            try:
                plt.close(fig)
            except:
                pass
            return "data:image/png;base64,"
    
    def _create_error_image(self, error_message):
        """Create an error image with the error message"""
        try:
            import matplotlib.pyplot as plt
            
            fig, ax = plt.subplots(figsize=(8, 6), dpi=100)
            fig.patch.set_facecolor('white')
            ax.set_facecolor('white')
            
            ax.text(0.5, 0.5, f"âš ï¸ Error\n\n{error_message}", 
                   fontsize=14, ha='center', va='center',
                   bbox=dict(boxstyle='round', facecolor='#FEE2E2', alpha=0.8))
            
            ax.set_xlim(0, 1)
            ax.set_ylim(0, 1)
            ax.axis('off')
            
            return self._figure_to_base64(fig)
        except Exception as e:
            logging.error(f"âŒ Error creating error image: {e}")
            return "data:image/png;base64,"

# Initialize transformation renderer
transformation_renderer = TransformationRenderer()

# ENHANCED BACKEND ENDPOINTS FOR TRANSFORMATIONS
@app.route('/api/geometry/render-transformation', methods=['POST'])
def render_transformation_endpoint():
    """Render geometric transformations"""
    try:
        data = request.get_json() or {}
        logging.info(f"ðŸ”„ TRANSFORMATION RENDER: Request: {data}")
        
        transformation_data = data.get('transformation_data') or data.get('shape_data')
        hide_answer = data.get('hide_answer', True)
        
        if not transformation_data:
            return jsonify({
                'success': False,
                'error': 'No transformation data provided'
            }), 400
        
        if not transformation_data.get('transformation_type'):
            return jsonify({
                'success': False,
                'error': 'No transformation type specified'
            }), 400
        
        # Render the transformation
        image_base64 = transformation_renderer.render_transformation(transformation_data, hide_answer)
        
        if image_base64 and len(image_base64) > 50:  # Valid base64 should be longer
            return jsonify({
                'success': True,
                'image': image_base64,
                'transformation_type': transformation_data.get('transformation_type'),
                'description': transformation_data.get('description', '')
            })
        else:
            return jsonify({
                'success': False,
                'error': 'Failed to generate transformation image'
            }), 500
        
    except Exception as e:
        logging.error(f"âŒ Transformation rendering error: {str(e)}")
        return jsonify({
            'success': False,
            'error': f'Transformation rendering failed: {str(e)}'
        }), 500


# Enhanced shape rendering to handle transformations
def render_shape_correctly_with_transformations(data):
    """Enhanced shape rendering that handles transformations"""
    try:
        shape_type = data.get('type')
        measurements = data.get('measurements', {})
        transformation_data = measurements if measurements.get('transformation_type') else None
        
        # If it's a transformation, use transformation renderer
        if transformation_data and transformation_data.get('transformation_type'):
            logging.info(f"ðŸ”„ TRANSFORMATION DETECTED: {transformation_data['transformation_type']}")
            
            image_base64 = transformation_renderer.render_transformation(
                transformation_data, 
                data.get('question_context', {}).get('hide_answer', True)
            )
            
            return {
                'success': True,
                'image': image_base64,
                'transformation_type': transformation_data['transformation_type'],
                'is_transformation': True
            }
        
        # Otherwise, use regular shape rendering
        else:
            # Use existing shape renderer
            if 'GEOMETRY_RENDERER' in app.config:
                renderer = app.config['GEOMETRY_RENDERER']
                return renderer.render_shape_correctly(data)
            else:
                return {
                    'success': False,
                    'error': 'No geometry renderer available'
                }
            
    except Exception as e:
        logging.error(f"âŒ Enhanced shape rendering error: {e}")
        return {
            'success': False,
            'error': str(e)
        }

@app.route('/api/geometry/render-shape', methods=['POST'])
def render_geometry_shape_unified():
    """UNIFIED shape rendering endpoint - handles ALL shape types"""
    try:
        data = request.get_json() or {}
        logging.info(f"ðŸŽ¯ UNIFIED RENDER: Request: {data}")
        
        # Extract data
        question_context = data.get('question_context', {})
        question_text = question_context.get('text', '') or data.get('question_text', '')
        measurements = data.get('measurements', {})
        dimensions = data.get('dimensions', {})
        shape_type = data.get('type') or measurements.get('shape_type')
        hide_answer = question_context.get('hide_answer', True)
        
        # Merge measurements
        all_measurements = {**measurements, **dimensions}
        
        # Auto-detect shape type if missing
        if not shape_type and question_text:
            detected_type = detect_shape_type_from_question(question_text)
            if detected_type != 'unknown':
                shape_type = detected_type
                logging.info(f"âœ… Auto-detected shape type: {shape_type}")
        
        if not shape_type:
            return jsonify({
                'success': False,
                'error': 'No geometry shape type detected'
            }), 400
        
        # ====== QUALITY ASSURANCE: Prevent shape-transformation conflicts ======
        explicit_shapes = [
            'triangle', 'right_triangle', 'equilateral_triangle', 'isosceles_triangle',
            'scalene_triangle', 'obtuse_triangle', 'acute_triangle',
            'circle', 'sector', 'rectangle', 'square', 'trapezium',
            'cylinder', 'cone', 'sphere', 'cube', 'pentagon', 'hexagon', 'polygon'
        ]

        has_explicit_shape = shape_type in explicit_shapes
        has_transformation_data = all_measurements.get('transformation_type') is not None

        if has_explicit_shape and has_transformation_data:
            # CONFLICT RESOLUTION: Explicit shape takes precedence
            logging.warning(
                f"âš ï¸  QA ALERT: Question mentions '{shape_type}' but also has transformation_type='{all_measurements.get('transformation_type')}'. "
                f"Resolution: Rendering as '{shape_type}' (explicit shape priority)"
            )
            logging.warning(f"   Question: {question_text}")
            # Remove transformation data to prevent incorrect rendering
            all_measurements.pop('transformation_type', None)
            has_transformation_data = False

        # Check for transformation - FIXED: Only render transformation if NO explicit shape conflict
        # Only treat as transformation if BOTH conditions are met:
        # 1. shape_type indicates transformation OR transformation_type exists in measurements
        # 2. transformation_type data is present in measurements
        # 3. NO explicit shape type detected (quality assurance)
        is_transformation = (
            (shape_type == 'transformation' or has_transformation_data)
            and has_transformation_data
            and not has_explicit_shape
        )

        if is_transformation:
            logging.info(f"ðŸ”„ TRANSFORMATION: {all_measurements['transformation_type']}")
            logging.info(f"   Shape type: {shape_type}")
            logging.info(f"   Question: {question_text[:100]}...")

            try:
                image_base64 = transformation_renderer.render_transformation(all_measurements, hide_answer)

                return jsonify({
                    'success': True,
                    'image': image_base64,
                    'shape_type': 'transformation',
                    'transformation_type': all_measurements['transformation_type'],
                    'is_transformation': True
                })
            except Exception as trans_error:
                logging.error(f"âŒ Transformation rendering failed: {trans_error}")
                return jsonify({
                    'success': False,
                    'error': f'Transformation rendering failed: {str(trans_error)}'
                }), 500
        
        # Handle regular shapes
        logging.info(f"ðŸ“ REGULAR SHAPE: {shape_type}")
        logging.info(f"   Question: {question_text[:100]}...")
        logging.info(f"   Measurements: {all_measurements}")
        
        # Get renderer - UPDATED TO USE UNIFIED RENDERER
        if 'GEOMETRY_RENDERER' not in app.config:
            app.config['GEOMETRY_RENDERER'] = create_renderer_for_app()
            logging.info("âœ… Initialized UnifiedShapeRenderer (via BackwardCompatibleRenderer)")

        renderer = app.config['GEOMETRY_RENDERER']
        
        # Prepare render data
        render_data = {
            'type': shape_type,
            'measurements': all_measurements,
            'question_context': {
                'text': question_text,
                'hide_answer': hide_answer
            }
        }
        
        # Render
        result = renderer.render_shape_correctly(render_data)
        
        if result.get('success'):
            return jsonify({
                'success': True,
                'image': result['image'],
                'shape_type': shape_type,
                'is_transformation': result.get('is_transformation', False),
                'answer_hidden': result.get('answer_hidden', hide_answer)
            })
        else:
            logging.error(f"âŒ Rendering failed: {result.get('error')}")
            return jsonify({
                'success': False,
                'error': result.get('error', 'Shape rendering failed')
            }), 500
        
    except Exception as e:
        logging.error(f"âŒ Unified rendering error: {str(e)}")
        import traceback
        logging.error(traceback.format_exc())
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

# TRANSFORMATION QUESTION GENERATION PROMPTS
def generate_transformation_prompt(data, selected_geometry_types):
    """Generate prompts specifically for transformation questions"""
    
    topic = data.get('topic', 'transformations')
    grade_level = data.get('grade_level', 'high')
    numQuestions = int(data.get('numQuestions', 5))
    
    # Check if transformations are selected
    has_transformations = 'transformations' in selected_geometry_types
    
    if not has_transformations:
        return generate_geometry_prompt_with_ai_support(data, selected_geometry_types)
    
    prompt = f"""Create {numQuestions} geometry questions about {topic} for {grade_level} students.

CRITICAL TRANSFORMATION REQUIREMENTS:
- Focus on geometric transformations: reflection, rotation, translation, and dilation
- Each question must include specific coordinates and transformation details
- Use coordinate geometry with clear before/after positions
- Include realistic coordinate values appropriate for {grade_level} level

TRANSFORMATION TYPES TO INCLUDE:
{_get_transformation_guidelines(grade_level)}

COORDINATE SYSTEM REQUIREMENTS:
- Use integer coordinates when possible
- Keep coordinates within reasonable range (-15 to 15)
- Ensure transformations result in clear, visible changes
- Include specific transformation parameters (angles, distances, scale factors)

SELECTED GEOMETRY TYPES:
{', '.join(selected_geometry_types)}

QUESTION FORMAT EXAMPLES:

REFLECTION EXAMPLE:
"A triangle has vertices at (2, 3), (6, 3), and (4, 7). What are the coordinates of the vertices after reflection across the y-axis?"

ROTATION EXAMPLE:
"A square with vertices at (1, 1), (4, 1), (4, 4), and (1, 4) is rotated 90Â° clockwise around the origin. What are the new coordinates?"

TRANSLATION EXAMPLE:
"A pentagon is translated 3 units right and 2 units down. If one vertex was originally at (2, 5), what is its new position?"

DILATION EXAMPLE:
"A triangle is dilated by a scale factor of 2 from the origin. If one vertex was at (3, 4), what is its new position?"

FORMAT YOUR RESPONSE AS JSON:
{{
  "questions": [
    {{
      "id": "unique-id-1",
      "text": "Transformation question with specific coordinates and parameters",
      "type": "multiple_choice",
      "options": [
        {{"text": "Correct transformed coordinates", "isCorrect": true}},
        {{"text": "Incorrect coordinates option 1", "isCorrect": false}},
        {{"text": "Incorrect coordinates option 2", "isCorrect": false}},
        {{"text": "Incorrect coordinates option 3", "isCorrect": false}}
      ]
    }}
  ]
}}

CRITICAL SUCCESS CRITERIA:
1. Every question must involve coordinate transformations
2. Include specific before and after coordinates
3. Use proper transformation terminology
4. Ensure mathematically accurate transformations
5. Make questions visually representable
6. Include variety in transformation types
7. Appropriate difficulty for {grade_level} level"""

    return prompt


def _get_transformation_guidelines(grade_level):
    """Get transformation guidelines based on grade level"""
    guidelines = {
        'elementary': """
- Simple reflections across x-axis and y-axis
- 90Â° and 180Â° rotations around origin
- Basic translations with small integer values
- Scale factors of 2, 3, or 1/2 for dilations
""",
        'middle': """
- Reflections across x-axis, y-axis, and y=x
- 90Â°, 180Â°, 270Â° rotations around origin
- Translations with integer vectors
- Scale factors including 1.5, 2, 3, 0.5, 0.25
""",
        'high': """
- Reflections across various lines including y=x and y=-x
- Rotations of 45Â°, 90Â°, 135Â°, 180Â°, 270Â° around origin
- Complex translations and combinations
- Various scale factors including decimals and fractions
""",
        'college': """
- Reflections across any line
- Rotations at any angle around any point
- Complex translation vectors
- Non-integer scale factors and negative scales
- Combined transformations
"""
    }
    
    return guidelines.get(grade_level, guidelines['high'])


# ENHANCED QUIZ GENERATION WITH TRANSFORMATIONS
@app.route('/api/generate-geometry-quiz-atomic', methods=['POST'])
@token_required
def generate_geometry_quiz_atomic_with_transformations(current_user):
    """Enhanced atomic endpoint with transformation support"""
    try:
        data = request.get_json()
        logging.info(f"ðŸ”§ ATOMIC ENDPOINT (Transformations): Starting quiz generation with data: {data}")
        
        # Initialize geometry lockout manager
        lockout_manager = GeometryLockoutManager()
        
        # Get parameters
        numQuestions = int(data.get('numQuestions', 5))
        question_types = data.get('types', ['multiple_choice'])
        selected_geometry_types = data.get('geometry_types', [])
        ai_value_assignment = data.get('ai_value_assignment', True)
        
        # Check if transformations are included
        has_transformations = 'transformations' in selected_geometry_types
        
        # Validate selected geometry types
        validation = lockout_manager.validate_selected_types(selected_geometry_types)
        if not validation.get('valid', True):
            logging.error(f"Invalid geometry types: {validation.get('message')}")
            return jsonify({'error': validation.get('message')}), 400
        
        logging.info(f"ðŸ”’ GEOMETRY LOCKOUT: Selected types: {selected_geometry_types}")
        if has_transformations:
            logging.info("ðŸ”„ TRANSFORMATIONS: Enabled in this quiz")
        
        # Generate quiz ID
        quiz_id = str(uuid.uuid4())
        
        # Build prompt (use transformation prompt if transformations are selected)
        if has_transformations:
            prompt = generate_transformation_prompt(data, selected_geometry_types)
        else:
            prompt = generate_geometry_prompt_with_ai_support(data, selected_geometry_types)
        
        # Call Claude API
        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=4000,
                temperature=0.7,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            content = response.content[0].text
            logging.info(f"Received response from Claude: {len(content)} characters")
            
        except Exception as claude_error:
            logging.error(f"Claude API error: {str(claude_error)}")
            return jsonify({'error': 'Failed to generate geometry questions'}), 500
        
        # Parse questions
        questions = []
        try:
            content = content.strip()
            if content.startswith('```json'):
                content = content[7:]
            if content.endswith('```'):
                content = content[:-3]
            content = content.strip()
            
            parsed_data = json.loads(content)
            if isinstance(parsed_data, dict) and 'questions' in parsed_data:
                questions = parsed_data['questions']
            else:
                raise ValueError("Invalid JSON format")
                
        except json.JSONDecodeError as json_error:
            logging.warning(f"JSON parsing error: {str(json_error)}")
            return jsonify({'error': 'Failed to parse AI response'}), 500
        
        # Apply lockout and AI value assignment
        questions = lockout_manager.processQuestionsWithLockout(questions, selected_geometry_types)
        
        # Apply enhanced AI value assignment (includes transformations)
        if ai_value_assignment:
            questions = apply_enhanced_ai_value_assignment_to_questions(questions, data.get('grade_level', 'high'))
        
        # Validate final questions
        for i, question in enumerate(questions):
            if not question.get('id'):
                question['id'] = str(uuid.uuid4())
            
            if 'text' in question:
                question['text'] = clean_mathematical_notation(question['text'])
            
            if 'options' in question:
                for option in question['options']:
                    if 'text' in option:
                        option['text'] = clean_mathematical_notation(option['text'])
        
        # Create the quiz object
        quiz = GeometryQuiz(
            id=quiz_id,
            user_id=current_user.id,
            title=data.get('title', f"{data['topic']} Geometry Quiz"),
            topic=data['topic'],
            grade_level=data['grade_level'],
            time_limit=data.get('time_limit', 30),
            mode=data.get('mode', 'list'),
            questions_json=json.dumps(questions),
            geometry_types=json.dumps(selected_geometry_types)
        )
        
        # Save the quiz to the database
        db.session.add(quiz)
        db.session.commit()
        
        logging.info(f"Successfully created transformation-enhanced geometry quiz with ID: {quiz_id}")
        
        return jsonify({
            'quiz_id': quiz_id,
            'message': f'Transformation-enhanced geometry quiz created successfully',
            'quiz_data': {
                'title': quiz.title,
                'topic': quiz.topic,
                'grade_level': quiz.grade_level,
                'time_limit': quiz.time_limit,
                'mode': quiz.mode,
                'questions': questions,
                'selected_geometry_types': selected_geometry_types,
                'ai_value_assignment': ai_value_assignment,
                'has_transformations': has_transformations,
                'method': 'backend_ai_assignment_with_transformations',
                'lockout_applied': True
            }
        }), 201
        
    except Exception as e:
        logging.error(f"Transformation-enhanced geometry quiz generation error: {str(e)}")
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


def apply_enhanced_ai_value_assignment_to_questions(questions, grade_level='high'):
    """Enhanced AI value assignment that includes transformations"""
    processed_questions = []
    
    for question in questions:
        question_copy = question.copy()
        
        # Use enhanced value assignment system (includes transformations)
        ai_values = value_assignment_system.process_question_for_ai_values(question['text'], grade_level)
        
        if ai_values.get('ai_assigned'):
            question_copy['shape_data'] = ai_values
            question_copy['requires_geometry'] = True
            
            # Set geometry type based on whether it's a transformation or regular shape
            if ai_values.get('transformation_type'):
                question_copy['geometry_type'] = 'transformations'
                question_copy['is_transformation'] = True
                logging.info(f"âœ… TRANSFORMATION: Assigned {ai_values['transformation_type']} to question: {question['text'][:50]}...")
            else:
                question_copy['geometry_type'] = ai_values['shape_type']
                question_copy['is_transformation'] = False
                logging.info(f"âœ… SHAPE: Assigned {ai_values['shape_type']} to question: {question['text'][:50]}...")
        else:
            question_copy['requires_geometry'] = False
            question_copy['is_transformation'] = False
            logging.info(f"â„¹ï¸  NO GEOMETRY: No shape detected for: {question['text'][:50]}...")
        
        processed_questions.append(question_copy)
    
    return processed_questions


# FRONTEND INTEGRATION ENDPOINTS

@app.route('/api/geometry/get-transformation-types', methods=['GET'])
def get_transformation_types():
    """Get available transformation types for frontend"""
    try:
        grade_level = request.args.get('grade_level', 'high')
        
        available_transformations = {
            'reflection': {
                'name': 'Reflection',
                'description': 'Mirror image across a line',
                'icon': 'ðŸªž',
                'difficulty': 'Easy to Medium'
            },
            'rotation': {
                'name': 'Rotation', 
                'description': 'Turning a shape around a point',
                'icon': 'ðŸ”„',
                'difficulty': 'Medium'
            },
            'translation': {
                'name': 'Translation',
                'description': 'Sliding a shape to a new position', 
                'icon': 'âž¡ï¸',
                'difficulty': 'Easy'
            },
            'dilation': {
                'name': 'Dilation',
                'description': 'Resizing a shape by a scale factor',
                'icon': 'ðŸ”',
                'difficulty': 'Medium to Hard'
            }
        }
        
        return jsonify({
            'success': True,
            'transformations': available_transformations,
            'grade_level': grade_level,
            'total_types': len(available_transformations)
        })
        
    except Exception as e:
        logging.error(f"Error getting transformation types: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/geometry/preview-transformation', methods=['POST'])
def preview_transformation():
    """Preview a transformation without creating a full quiz"""
    try:
        data = request.get_json()
        transformation_type = data.get('transformation_type', 'reflection')
        grade_level = data.get('grade_level', 'high')
        shape_type = data.get('shape_type', 'triangle')
        
        # Generate transformation data
        if transformation_type == 'reflection':
            transform_data = transformations_system.generate_reflection_data(grade_level, shape_type)
        elif transformation_type == 'rotation':
            transform_data = transformations_system.generate_rotation_data(grade_level, shape_type)
        elif transformation_type == 'translation':
            transform_data = transformations_system.generate_translation_data(grade_level, shape_type)
        elif transformation_type == 'dilation':
            transform_data = transformations_system.generate_dilation_data(grade_level, shape_type)
        else:
            return jsonify({
                'success': False,
                'error': f'Unsupported transformation type: {transformation_type}'
            }), 400
        
        if not transform_data or not transform_data.get('ai_assigned'):
            return jsonify({
                'success': False,
                'error': 'Failed to generate transformation data'
            }), 500
        
        # Render the transformation
        image_base64 = transformation_renderer.render_transformation(transform_data, hide_answer=False)
        
        return jsonify({
            'success': True,
            'transformation_data': transform_data,
            'image': image_base64,
            'preview': True
        })
        
    except Exception as e:
        logging.error(f"Error previewing transformation: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


# LOGGING AND SYSTEM STATUS
def log_transformation_system_status():
    """Log the transformation system status"""
    logging.info("ðŸ”„ TRANSFORMATION SYSTEM STATUS:")
    logging.info(f"   âœ… Reflection: Active")
    logging.info(f"   ðŸ”„ Rotation: Active") 
    logging.info(f"   âž¡ï¸ Translation: Active")
    logging.info(f"   ðŸ” Dilation: Active")
    logging.info(f"   ðŸŽ¨ Visualization: Active")
    logging.info(f"   ðŸ“ Shape Types: {len(transformations_system.base_shapes)}")
    logging.info(f"   ðŸŽ¯ Grade Levels: elementary, middle, high, college")


# Initialize transformation system
try:
    log_transformation_system_status()
    logging.info("âœ… Transformation system initialized and ready")
except Exception as e:
    logging.error(f"âŒ Error initializing transformation system: {e}")


print("ðŸ”„ GEOMETRIC TRANSFORMATIONS SYSTEM LOADED!")
print("âœ… TRANSFORMATION TYPES:")
print("   ðŸªž Reflection (across x-axis, y-axis, y=x, y=-x)")
print("   ðŸ”„ Rotation (90Â°, 180Â°, 270Â°, 45Â°, etc. around origin)")
print("   âž¡ï¸ Translation (horizontal, vertical, diagonal movements)")
print("   ðŸ” Dilation (scale factors: 0.5, 1.5, 2, 3, etc.)")
print("")
print("ðŸŽ¯ FEATURES:")
print("   ðŸ“ Coordinate geometry with before/after positions")
print("   ðŸŽ¨ Visual transformation rendering")
print("   ðŸ“Š Grade-level appropriate complexity")
print("   ðŸ”’ Integration with geometry lockout system")
print("   ðŸ¤– AI-enhanced value assignment")
print("   ðŸ“‹ Frontend-compatible endpoints")
print("")
print("ðŸš€ NEW ENDPOINTS:")
print("   ðŸ“ /api/geometry/render-transformation")
print("   ðŸ”„ /api/geometry/preview-transformation") 
print("   ðŸ“Š /api/geometry/get-transformation-types")
print("   ðŸŽ¨ Enhanced /api/geometry/render-shape-ai")
print("")
print("ðŸ”§ USAGE: Add 'transformations' to geometry_types in quiz creation!")

# Add this at the top of your file
@app.route('/api/generate-quiz', methods=['POST'])
@token_required
def generate_quiz(current_user):
    try:
        data = request.get_json()
        logger.debug(f"Received quiz generation request: {data}")
        
        # Get the number of questions and question types
        numQuestions = int(data.get('numQuestions', 5))
        question_types = data.get('types', ['multiple_choice'])
        
        # Generate a quiz ID first
        quiz_id = str(uuid.uuid4())
        
        # Define grade level text mapping for more professional prompting
        grade_level_map = {
            'elementary': 'elementary school (grades 1-5)',
            'middle': 'middle school (grades 6-8)',
            'high': 'high school (grades 9-12)',
            'college': 'college/university level'
        }
        grade_level_text = grade_level_map.get(data['grade_level'], data['grade_level'])
        
        # Content source handling
        content_context = ""
        if data.get('source_type') == 'text' and data.get('content_text'):
            content_context = f"\nUse the following content to create questions:\n\n{data['content_text']}\n\n"
        
        # Build sophisticated prompt with clear structure and JSON response format
        prompt = f"""Create a professional academic quiz about {data['topic']} for {grade_level_text} students with {numQuestions} questions.
{content_context}
The quiz should include the following question types:
"""
        
        if 'multiple_choice' in question_types:
            prompt += "- Multiple choice questions with 4 options (A, B, C, D) and exactly one correct answer\n"
        
        if 'true_false' in question_types:
            prompt += "- True/False questions where the answer is clearly True or False\n"
            
        if 'paragraph' in question_types:
            prompt += "- Paragraph questions that require written responses\n"

        if 'select_all' in question_types:
            prompt += "- Select All That Apply questions with 4-6 options where MULTIPLE options can be correct (at least 2 correct answers)\n"

        prompt += "\nQuality requirements:\n"
        prompt += "- Make the questions diverse and conversational - don't just start with \"What\" or \"Which\"\n"
        prompt += "- Use embedded interrogatives where appropriate to make questions feel more natural\n"
        prompt += "- Include a variety of question styles - use \"how\", \"why\", \"when\", \"where\", along with \"what\" and \"which\" occasionally\n"
        prompt += "- Avoid using \"What is\" or \"Which of the following\" for more than 25% of the questions\n"
        prompt += "- Make the questions challenging but appropriate for the grade level\n"
        prompt += "- Ensure questions are academically rigorous and test meaningful understanding\n"
        
        # Add explicit JSON format instructions
        prompt += """
Format your response as a JSON object with this exact structure:

{
  "questions": [
    {
      "id": "1",
      "text": "Question text goes here?",
      "type": "multiple_choice",
      "options": [
        {"text": "Option A text", "isCorrect": false},
        {"text": "Option B text", "isCorrect": true},
        {"text": "Option C text", "isCorrect": false},
        {"text": "Option D text", "isCorrect": false}
      ]
    },
    {
      "id": "2",
      "text": "True/false question text goes here?",
      "type": "true_false",
      "options": [
        {"text": "True", "isCorrect": false},
        {"text": "False", "isCorrect": true}
      ]
    },
    {
      "id": "3",
      "text": "Paragraph question text goes here?",
      "type": "paragraph"
    },
    {
      "id": "4",
      "text": "Select all that apply question text goes here?",
      "type": "select_all",
      "options": [
        {"text": "Option A text", "isCorrect": true},
        {"text": "Option B text", "isCorrect": true},
        {"text": "Option C text", "isCorrect": false},
        {"text": "Option D text", "isCorrect": false}
      ]
    }
  ]
}

IMPORTANT:
1. Return ONLY the JSON object - do not include any additional text, explanations, or markdown formatting
2. Ensure the response is valid JSON
3. Each question must have a unique ID
4. Each multiple_choice question must have exactly 4 options
5. Each true_false question must have exactly 2 options (True and False)
6. For multiple_choice and true_false questions, exactly ONE option should have isCorrect: true
7. For select_all questions, MULTIPLE options should have isCorrect: true (at least 2)
8. Each select_all question must have 4-6 options
"""

        # Add the original format examples as a fallback
        prompt += "\nIf you cannot generate valid JSON, use the following format instead:\n"
        
        if 'multiple_choice' in question_types:
            prompt += """
Multiple Choice:
Question: [question text]
A) [first option]
B) [second option]
C) [third option]
D) [fourth option]
Correct: [A, B, C, or D]
"""
        
        if 'true_false' in question_types:
            prompt += """
True/False:
Question: [question text]
A) True
B) False
Correct: [A or B]
"""
            
        if 'paragraph' in question_types:
            prompt += """
Paragraph:
Question: [question text]
"""

        # Call Claude API
        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=4000,
                temperature=0.7,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            content = response.content[0].text
            logger.info(f"Received response from Claude: {len(content)} characters")
            
        except Exception as claude_error:
            logger.error(f"Claude API error: {str(claude_error)}")
            return jsonify({'error': 'Failed to generate questions'}), 500
        
        # Try to parse the response as JSON first
        questions = []
        try:
            # First, try to parse the whole response as JSON
            parsed_data = json.loads(content)
            if isinstance(parsed_data, dict) and 'questions' in parsed_data and isinstance(parsed_data['questions'], list):
                logger.info("Successfully parsed Claude response as JSON")
                questions = parsed_data['questions']
                
                # Validate and fix questions if needed
                questions = validate_and_fix_questions(questions, question_types, numQuestions)
            else:
                # If not in expected format, try to extract JSON
                logger.warning("Response is valid JSON but missing 'questions' array, falling back to text parsing")
                raise ValueError("Invalid JSON format")
                
        except (json.JSONDecodeError, ValueError) as json_error:
            logger.warning(f"Could not parse as JSON: {str(json_error)}, attempting to extract JSON portion")
            
            # Try to extract JSON portion if there's any surrounding text
            try:
                json_start = content.find('{')
                json_end = content.rfind('}') + 1
                
                if json_start >= 0 and json_end > json_start:
                    json_content = content[json_start:json_end]
                    parsed_data = json.loads(json_content)
                    
                    if isinstance(parsed_data, dict) and 'questions' in parsed_data and isinstance(parsed_data['questions'], list):
                        logger.info("Successfully extracted and parsed JSON portion")
                        questions = parsed_data['questions']
                        
                        # Validate and fix questions if needed
                        questions = validate_and_fix_questions(questions, question_types, numQuestions)
                    else:
                        # If still not in expected format, fall back to text parsing
                        logger.warning("Extracted JSON is missing 'questions' array, falling back to text parsing")
                        raise ValueError("Invalid extracted JSON format")
                else:
                    # If no JSON braces found, fall back to text parsing
                    logger.warning("No JSON braces found in response, falling back to text parsing")
                    raise ValueError("No JSON found in response")
                    
            except (json.JSONDecodeError, ValueError):
                # Fall back to the original text parsing approach
                logger.warning("JSON extraction failed, falling back to original text parsing")
                questions = parse_text_format(content, question_types)
        
        # Ensure we have the requested number of questions
        if len(questions) < numQuestions:
            logger.warning(f"Only {len(questions)} questions were generated, expected {numQuestions}")
            # Fill with placeholder questions if needed
            questions = fill_missing_questions(questions, numQuestions, question_types)
        elif len(questions) > numQuestions:
            # Trim excess questions
            logger.info(f"Trimming excess questions ({len(questions)} generated, {numQuestions} requested)")
            questions = questions[:numQuestions]
        
        # Create the quiz object with the generated questions
        quiz = Quiz(
            id=quiz_id,
            user_id=current_user.id,
            title=data.get('title', f"{data['topic']} Quiz"),
            topic=data['topic'],
            grade_level=data['grade_level'],
            time_limit=data.get('time_limit', 30),
            mode=data.get('mode', 'list'),
            questions_json=json.dumps(questions)  # Store the questions in the database
        )
        
        # Save the quiz to the database 
        db.session.add(quiz)
        db.session.commit()
        
        return jsonify({
            'quiz_id': quiz_id,
            'message': 'Quiz created successfully',
            'quiz_data': {
                'title': quiz.title,
                'topic': quiz.topic,
                'grade_level': quiz.grade_level,
                'time_limit': quiz.time_limit,
                'mode': quiz.mode,
                'questions': questions
            }
        }), 201
        
    except Exception as e:
        logger.error(f"Quiz generation error: {str(e)}")
        db.session.rollback()  # Roll back any database changes if there was an error
        return jsonify({'error': str(e)}), 500


def validate_and_fix_questions(questions, allowed_types, expected_count):
    """
    Validate and fix any issues with the questions to ensure they meet the requirements.
    """
    validated_questions = []
    
    for q in questions:
        if not isinstance(q, dict) or 'text' not in q:
            logger.warning("Skipping invalid question without text")
            continue
            
        # Ensure each question has an ID
        if 'id' not in q:
            q['id'] = str(uuid.uuid4())
            
        # Normalize question type
        if 'type' not in q:
            # Try to infer type from options
            if 'options' in q and len(q.get('options', [])) == 2:
                option_texts = [opt.get('text', '').lower() for opt in q.get('options', [])]
                if 'true' in option_texts and 'false' in option_texts:
                    q['type'] = 'true_false'
                else:
                    q['type'] = 'multiple_choice'
            elif 'options' in q:
                q['type'] = 'multiple_choice'
            else:
                q['type'] = 'paragraph'
        
        # Ensure question type is lowercase and valid
        if isinstance(q.get('type'), str):
            q['type'] = q['type'].lower()
            
        # Skip question types that weren't requested
        if q['type'] not in allowed_types:
            logger.warning(f"Skipping question with type {q['type']} which wasn't requested")
            continue
            
        # Handle options for multiple choice, true/false, and select_all types
        if q['type'] in ['multiple_choice', 'true_false', 'select_all'] and 'options' in q:
            # Ensure true/false has exactly 2 options
            if q['type'] == 'true_false':
                # Normalize true/false options
                normalized_options = []
                has_true = False
                has_false = False
                
                for opt in q.get('options', []):
                    if not isinstance(opt, dict):
                        continue
                        
                    opt_text = opt.get('text', '').strip()
                    if opt_text.lower() == 'true':
                        has_true = True
                        normalized_options.append({
                            'text': 'True',
                            'isCorrect': opt.get('isCorrect', False)
                        })
                    elif opt_text.lower() == 'false':
                        has_false = True
                        normalized_options.append({
                            'text': 'False',
                            'isCorrect': opt.get('isCorrect', False)
                        })
                
                # If missing true or false options, add them
                if not has_true:
                    normalized_options.append({
                        'text': 'True',
                        'isCorrect': False
                    })
                if not has_false:
                    normalized_options.append({
                        'text': 'False',
                        'isCorrect': False
                    })
                    
                q['options'] = normalized_options
                
            # Ensure multiple choice has 4 options
            elif q['type'] == 'multiple_choice':
                if len(q.get('options', [])) < 4:
                    # Add dummy options if needed
                    current_options = q.get('options', [])
                    while len(current_options) < 4:
                        current_options.append({
                            'text': f'Option {chr(65 + len(current_options))}',
                            'isCorrect': False
                        })
                    q['options'] = current_options
                elif len(q.get('options', [])) > 4:
                    # Trim excess options
                    q['options'] = q['options'][:4]
                
                # Ensure exactly one correct answer for multiple choice
                correct_count = sum(1 for opt in q.get('options', []) if opt.get('isCorrect'))
                
                if correct_count == 0:
                    # If no correct answers, make the first one correct
                    if q['options']:
                        q['options'][0]['isCorrect'] = True
                elif correct_count > 1:
                    # If multiple correct answers, keep only the first one
                    found_correct = False
                    for opt in q['options']:
                        if opt.get('isCorrect'):
                            if found_correct:
                                opt['isCorrect'] = False
                            else:
                                found_correct = True
            
            # For select_all, ensure at least one option is correct and has at least 3 options
            elif q['type'] == 'select_all':
                # Ensure at least 3 options for select_all
                if len(q.get('options', [])) < 3:
                    # Add dummy options if needed
                    current_options = q.get('options', [])
                    while len(current_options) < 3:
                        current_options.append({
                            'text': f'Option {chr(65 + len(current_options))}',
                            'isCorrect': False
                        })
                    q['options'] = current_options
                
                # Ensure at least one correct answer
                correct_count = sum(1 for opt in q.get('options', []) if opt.get('isCorrect'))
                
                if correct_count == 0:
                    # If no correct answers, make the first one correct
                    if q['options']:
                        q['options'][0]['isCorrect'] = True
        
        # For paragraph questions, ensure no options
        elif q['type'] == 'paragraph':
            if 'options' in q:
                del q['options']
                
        validated_questions.append(q)
    
    return validated_questions


def fill_missing_questions(questions, expected_count, allowed_types):
    """
    Fill any missing questions up to the expected count.
    """
    while len(questions) < expected_count:
        # Determine which question type to add
        if 'multiple_choice' in allowed_types:
            q_type = 'multiple_choice'
        elif 'true_false' in allowed_types:
            q_type = 'true_false'
        elif 'paragraph' in allowed_types:
            q_type = 'paragraph'
        else:
            q_type = 'multiple_choice'  # Default
            
        # Create a placeholder question
        q_num = len(questions) + 1
        placeholder = {
            'id': str(uuid.uuid4()),
            'text': f"Question {q_num}: This is an automatically generated placeholder question.",
            'type': q_type
        }
        
        # Add options if needed
        if q_type == 'multiple_choice':
            placeholder['options'] = [
                {'text': 'Option A', 'isCorrect': True},
                {'text': 'Option B', 'isCorrect': False},
                {'text': 'Option C', 'isCorrect': False},
                {'text': 'Option D', 'isCorrect': False}
            ]
        elif q_type == 'true_false':
            placeholder['options'] = [
                {'text': 'True', 'isCorrect': True},
                {'text': 'False', 'isCorrect': False}
            ]
            
        questions.append(placeholder)
    
    return questions


def parse_text_format(content, question_types):
    """
    Parse the original text format response from Claude.
    This is a fallback if JSON parsing fails.
    """
    questions = []
    current_type = None
    current_question = None
    options = []
    
    for line in content.strip().split('\n'):
        line = line.strip()
        if not line:
            continue
        
        # Detect question type
        if line.startswith("Multiple Choice:"):
            current_type = "multiple_choice"
            continue
        elif line.startswith("True/False:"):
            current_type = "true_false"
            continue
        elif line.startswith("Paragraph:"):
            current_type = "paragraph"
            continue
            
        if line.startswith("Question:"):
            # Save previous question if exists
            if current_question:
                if current_type == "paragraph":
                    questions.append({
                        "text": current_question,
                        "type": "paragraph",
                        "id": str(uuid.uuid4())
                    })
                elif options:
                    questions.append({
                        "text": current_question,
                        "type": current_type or "multiple_choice",
                        "options": options.copy(),
                        "id": str(uuid.uuid4())
                    })
                
            # Start new question
            current_question = line.replace("Question:", "").strip()
            options = []
            
        elif line[0:2] in ["A)", "B)", "C)", "D)"]:
            option_text = line[2:].strip()
            options.append({
                "text": option_text,
                "isCorrect": False
            })
            
        elif line.startswith("Correct:"):
            correct_letter = line.replace("Correct:", "").strip()
            if correct_letter in ["A", "B", "C", "D"]:
                correct_index = ord(correct_letter) - ord("A")
                if 0 <= correct_index < len(options):
                    options[correct_index]["isCorrect"] = True
    
    # Add the last question
    if current_question:
        if current_type == "paragraph":
            questions.append({
                "text": current_question,
                "type": "paragraph",
                "id": str(uuid.uuid4())
            })
        elif options:
            questions.append({
                "text": current_question,
                "type": current_type or "multiple_choice",
                "options": options.copy(),
                "id": str(uuid.uuid4())
            })
    
    return questions


def get_grade_level_text(grade_level):
    grade_level_map = {
        'elementary-lower': 'elementary school (grades 1-2)',
        'elementary-upper': 'elementary school (grades 3-5)',
        'middle': 'middle school (grades 6-8)',
        'high': 'high school (grades 9-12)',
        'college': 'college level'
    }
    
    return grade_level_map.get(grade_level, grade_level)

# Add this to your Flask app file

from flask import jsonify, render_template_string
from datetime import datetime

@app.route('/api/quiz/<quiz_id>/print', methods=['GET'])
@token_required
def get_printable_quiz(current_user, quiz_id):
    """
    Generate a printable version of the quiz
    Returns HTML formatted for printing
    """
    try:
        # Fetch quiz from database
        quiz = Quiz.query.filter_by(id=quiz_id, user_id=current_user.id).first()
        
        if not quiz:
            return jsonify({'error': 'Quiz not found'}), 404
        
        # Parse questions if stored as JSON
        import json
        questions = json.loads(quiz.questions) if isinstance(quiz.questions, str) else quiz.questions
        
        # Generate HTML for printing
        html = generate_printable_html(quiz, questions)
        
        return html, 200, {'Content-Type': 'text/html; charset=utf-8'}
        
    except Exception as e:
        logger.error(f"Error generating printable quiz: {str(e)}")
        return jsonify({'error': 'Failed to generate printable quiz'}), 500


@app.route('/api/quiz/<quiz_id>/print-data', methods=['GET'])
@token_required
def get_quiz_print_data(current_user, quiz_id):
    """
    Get quiz data formatted for printing (JSON response)
    """
    try:
        # Fetch quiz from database
        quiz = Quiz.query.filter_by(id=quiz_id, user_id=current_user.id).first()
        
        if not quiz:
            return jsonify({'error': 'Quiz not found'}), 404
        
        # Parse questions if stored as JSON
        import json
        questions = json.loads(quiz.questions) if isinstance(quiz.questions, str) else quiz.questions
        
        # Format data for printing
        print_data = {
            'title': quiz.title or 'Quiz',
            'topic': quiz.topic,
            'grade_level': quiz.grade_level,
            'created_at': quiz.created_at.strftime('%B %d, %Y'),
            'questions': questions,
            'total_questions': len(questions)
        }
        
        return jsonify(print_data), 200
        
    except Exception as e:
        logger.error(f"Error getting quiz print data: {str(e)}")
        return jsonify({'error': 'Failed to get quiz data'}), 500


def generate_printable_html(quiz, questions):
    """
    Generate print-friendly HTML for the quiz
    """
    
    html_template = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }} - Printable Quiz</title>
    <style>
        @media print {
            @page {
                margin: 0.75in;
                size: letter;
            }
            
            body {
                margin: 0;
                padding: 0;
            }
            
            .no-print {
                display: none !important;
            }
            
            .page-break {
                page-break-after: always;
            }
            
            .question {
                page-break-inside: avoid;
            }
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Times New Roman', Times, serif;
            line-height: 1.6;
            color: #000;
            background: #fff;
            padding: 20px;
            max-width: 8.5in;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #000;
            padding-bottom: 15px;
        }
        
        .header h1 {
            font-size: 24pt;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .header .metadata {
            font-size: 11pt;
            color: #333;
            margin-top: 5px;
        }
        
        .student-info {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid #000;
        }
        
        .student-info table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .student-info td {
            padding: 8px;
            font-size: 11pt;
        }
        
        .student-info .label {
            font-weight: bold;
            width: 120px;
        }
        
        .student-info .fill-in {
            border-bottom: 1px solid #000;
            min-width: 200px;
        }
        
        .instructions {
            margin-bottom: 25px;
            padding: 12px;
            background: #f5f5f5;
            border-left: 4px solid #000;
        }
        
        .instructions h2 {
            font-size: 13pt;
            margin-bottom: 8px;
        }
        
        .instructions p {
            font-size: 11pt;
            margin-bottom: 5px;
        }
        
        .question {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        
        .question-header {
            display: flex;
            align-items: flex-start;
            margin-bottom: 10px;
        }
        
        .question-number {
            font-weight: bold;
            font-size: 12pt;
            margin-right: 10px;
            min-width: 30px;
        }
        
        .question-text {
            font-size: 12pt;
            flex: 1;
            line-height: 1.5;
        }
        
        .options {
            margin-left: 40px;
            margin-top: 10px;
        }
        
        .option {
            margin-bottom: 8px;
            display: flex;
            align-items: flex-start;
        }
        
        .option-checkbox {
            width: 16px;
            height: 16px;
            border: 1.5px solid #000;
            margin-right: 10px;
            margin-top: 3px;
            flex-shrink: 0;
        }
        
        .option-radio {
            width: 16px;
            height: 16px;
            border: 1.5px solid #000;
            border-radius: 50%;
            margin-right: 10px;
            margin-top: 3px;
            flex-shrink: 0;
        }
        
        .option-text {
            font-size: 11pt;
            flex: 1;
        }
        
        .answer-space {
            margin-left: 40px;
            margin-top: 10px;
            border: 1px solid #ccc;
            min-height: 80px;
            padding: 8px;
        }
        
        .answer-space.large {
            min-height: 150px;
        }
        
        .answer-lines {
            margin-left: 40px;
            margin-top: 10px;
        }
        
        .answer-line {
            border-bottom: 1px solid #000;
            height: 25px;
            margin-bottom: 5px;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 15px;
            border-top: 1px solid #ccc;
            text-align: center;
            font-size: 9pt;
            color: #666;
        }
        
        .print-button {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14pt;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        
        .print-button:hover {
            background: #0056b3;
        }
        
        @media screen {
            body {
                background: #f0f0f0;
                padding: 40px 20px;
            }
            
            .quiz-container {
                background: white;
                padding: 40px;
                box-shadow: 0 0 10px rgba(0,0,0,0.1);
            }
        }
    </style>
</head>
<body>
    <button class="print-button no-print" onclick="window.print()">ðŸ–¨ï¸ Print Quiz</button>
    
    <div class="quiz-container">
        <div class="header">
            <h1>{{ title }}</h1>
            <div class="metadata">
                <div><strong>Topic:</strong> {{ topic }}</div>
                <div><strong>Grade Level:</strong> {{ grade_level }}</div>
                <div><strong>Date Created:</strong> {{ date }}</div>
                <div><strong>Total Questions:</strong> {{ total_questions }}</div>
            </div>
        </div>
        
        <div class="student-info">
            <table>
                <tr>
                    <td class="label">Name:</td>
                    <td class="fill-in"></td>
                    <td class="label">Date:</td>
                    <td class="fill-in" style="width: 150px;"></td>
                </tr>
                <tr>
                    <td class="label">Class/Period:</td>
                    <td class="fill-in"></td>
                    <td class="label">Score:</td>
                    <td class="fill-in" style="width: 150px;"></td>
                </tr>
            </table>
        </div>
        
        <div class="instructions">
            <h2>Instructions</h2>
            <p>â€¢ Read each question carefully before answering.</p>
            <p>â€¢ For multiple choice and true/false questions, mark your answer clearly.</p>
            <p>â€¢ For written response questions, write your answer in the space provided.</p>
            <p>â€¢ Show all work where applicable.</p>
        </div>
        
        <div class="questions">
            {% for question in questions %}
            <div class="question">
                <div class="question-header">
                    <div class="question-number">{{ loop.index }}.</div>
                    <div class="question-text">{{ question.text }}</div>
                </div>
                
                {% if question.type == 'multiple_choice' or question.type == 'true_false' %}
                <div class="options">
                    {% for option in question.options %}
                    <div class="option">
                        <div class="option-radio"></div>
                        <div class="option-text">{{ option.text }}</div>
                    </div>
                    {% endfor %}
                </div>
                
                {% elif question.type == 'select_all' %}
                <div class="options">
                    <p style="margin-left: 0; margin-bottom: 8px; font-style: italic; font-size: 10pt;">Select all that apply:</p>
                    {% for option in question.options %}
                    <div class="option">
                        <div class="option-checkbox"></div>
                        <div class="option-text">{{ option.text }}</div>
                    </div>
                    {% endfor %}
                </div>
                
                {% elif question.type == 'paragraph' %}
                <div class="answer-lines">
                    <div class="answer-line"></div>
                    <div class="answer-line"></div>
                    <div class="answer-line"></div>
                    <div class="answer-line"></div>
                    <div class="answer-line"></div>
                </div>
                {% endif %}
            </div>
            {% endfor %}
        </div>
        
        <div class="footer">
            <p>End of Quiz</p>
            <p style="margin-top: 5px;">Generated on {{ date }}</p>
        </div>
    </div>
    
    <script>
        // Auto-print option (commented out by default)
        // window.onload = function() {
        //     setTimeout(function() {
        //         window.print();
        //     }, 500);
        // };
    </script>
</body>
</html>
    """
    
    # Use Jinja2 template engine
    from jinja2 import Template
    
    template = Template(html_template)
    
    return template.render(
        title=quiz.title or 'Quiz',
        topic=quiz.topic or 'General',
        grade_level=quiz.grade_level or 'Not specified',
        date=quiz.created_at.strftime('%B %d, %Y') if quiz.created_at else datetime.now().strftime('%B %d, %Y'),
        total_questions=len(questions),
        questions=questions
    )

@app.route('/debug/test-s3', methods=['GET'])
@token_required
def test_s3_connection(current_user):
    """Test S3 connection and permissions"""
    try:
        # List buckets (tests credentials)
        response = s3_client.list_buckets()
        buckets = [bucket['Name'] for bucket in response['Buckets']]
        
        # Try to list objects in your bucket
        try:
            objects = s3_client.list_objects_v2(Bucket=S3_BUCKET, MaxKeys=5)
            object_count = objects.get('KeyCount', 0)
        except ClientError as e:
            object_count = f"Error: {e.response['Error']['Code']}"
        
        return jsonify({
            'credentials': 'Valid',
            'accessible_buckets': buckets,
            'target_bucket': S3_BUCKET,
            'target_region': S3_REGION,
            'objects_in_bucket': object_count
        }), 200
        
    except ClientError as e:
        return jsonify({
            'error': e.response['Error']['Code'],
            'message': e.response['Error']['Message'],
            'credentials': 'Invalid or insufficient permissions'
        }), 500

# Add these new endpoints to your Flask app for the Homework Help AI

import json
import random
from datetime import datetime

# Homework AI Chat endpoint
@app.route('/api/homework-ai/chat', methods=['POST', 'OPTIONS'])
def homework_ai_chat():
    """
    Main chat endpoint for homework help AI
    Handles general questions, explanations, and conversation
    """
    if request.method == 'OPTIONS':
        return '', 204
    
    try:
        data = request.get_json()
        logger.debug(f"Received homework AI chat request: {data}")
        
        # Required fields
        if not data.get('message'):
            return jsonify({'error': 'Message is required'}), 400
        
        message = data['message']
        student_grade = data.get('grade_level', 'high school')
        conversation_history = data.get('conversation_history', [])
        session_id = data.get('session_id', f"session_{datetime.now().timestamp()}")
        
        # Build context-aware prompt
        prompt = build_chat_prompt(message, student_grade, conversation_history)
        
        # Call Claude API
        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=1500,
                temperature=0.7,
                messages=[{"role": "user", "content": prompt}]
            )
            ai_response = response.content[0].text
            logger.info(f"Received homework AI response: {len(ai_response)} characters")
            
        except Exception as claude_error:
            logger.error(f"Claude API error in homework chat: {str(claude_error)}")
            return jsonify({'error': 'AI service temporarily unavailable'}), 500
        
        # Parse and format response
        formatted_response = format_ai_response(ai_response)
        
        return jsonify({
            'response': formatted_response,
            'session_id': session_id,
            'timestamp': datetime.now().isoformat(),
            'should_quiz': should_generate_quiz(message, conversation_history)
        }), 200
        
    except Exception as e:
        logger.error(f"Homework AI chat error: {str(e)}")
        return jsonify({'error': 'Chat service error', 'details': str(e)}), 500

def build_chat_prompt(message, grade_level, conversation_history):
    """Build context-aware prompt for the AI"""
    
    # Check if this is a greeting or first message
    is_greeting = any(word in message.lower() for word in ['hello', 'hi', 'hey', 'good morning', 'good afternoon'])
    
    if is_greeting and len(conversation_history) <= 1:
        return f"""You are StudyBot, a helpful AI homework tutor for Grade {grade_level} students.

The student just greeted you with: "{message}"

Respond warmly and explain how you can help them with their homework. Keep it brief (2-3 sentences) and ask what subject or topic they need help with."""

    # Build conversation context
    context = ""
    if conversation_history:
        context = "\nRecent conversation:\n"
        for item in conversation_history[-3:]:  # Last 3 exchanges
            context += f"Student: {item.get('student', '')}\n"
            context += f"You: {item.get('ai', '')}\n"
    
    prompt = f"""You are StudyBot, a helpful AI homework tutor for Grade {grade_level} students.

{context}

Current student message: "{message}"

Please provide a helpful, educational response that:
1. Directly addresses their question or request
2. Explains concepts clearly for a Grade {grade_level} level
3. Uses examples and analogies they can relate to
4. Is encouraging and supportive
5. Stays focused on education and learning
6. Keeps responses concise but thorough (150-250 words max)

If they're asking about a specific homework problem, help them understand the concept rather than just giving the answer.

If they're off-topic or asking non-educational questions, gently redirect them back to homework help.

IMPORTANT: Respond directly as StudyBot. Do not include any stage directions, tone instructions, or meta-commentary in your response."""

    return prompt

def format_ai_response(response):
    """Format the AI response for better presentation"""
    # Clean up the response
    response = response.strip()
    
    # Remove any unwanted prefixes
    prefixes_to_remove = ["StudyBot:", "AI:", "Assistant:"]
    for prefix in prefixes_to_remove:
        if response.startswith(prefix):
            response = response[len(prefix):].strip()
    
    # Remove tone instructions that might bleed through
    tone_patterns = [
        r'\*in a [^*]+\*',  # *in a friendly tone*
        r'\*[^*]*tone[^*]*\*',  # any *something tone something*
        r'\([^)]*tone[^)]*\)',  # (in any tone)
        r'\[[^\]]*tone[^\]]*\]'  # [in any tone]
    ]
    
    import re
    for pattern in tone_patterns:
        response = re.sub(pattern, '', response, flags=re.IGNORECASE)
    
    # Clean up extra whitespace
    response = ' '.join(response.split())
    
    return response

def should_generate_quiz(message, conversation_history):
    """Determine if we should generate a quiz after this response"""
    # Don't quiz on greetings or very short messages
    if len(message.split()) < 3:
        return False
    
    # Don't quiz if we just did one recently
    if len(conversation_history) > 0:
        last_exchange = conversation_history[-1]
        if 'quiz' in str(last_exchange).lower():
            return False
    
    # Quiz if the message seems like a substantial question
    question_indicators = ['what', 'how', 'why', 'explain', 'help', 'understand', 'solve']
    if any(indicator in message.lower() for indicator in question_indicators):
        return True
    
    return False

@app.route('/api/generate-hash/<password>')
def generate_hash(password):
    from werkzeug.security import generate_password_hash
    hash_result = generate_password_hash(password)
    return jsonify({
        'password': password,
        'hash': hash_result,
        'length': len(hash_result),
        'sql': f"UPDATE `admins` SET `password_hash` = '{hash_result}' WHERE `email` = 'admin@deciph.ai';"
    })

# Quiz Generation endpoint
@app.route('/api/homework-ai/generate-quiz', methods=['POST'])
def generate_homework_quiz():
    """
    Generate a quiz question based on the recent conversation
    """
    try:
        data = request.get_json()
        logger.debug(f"Received quiz generation request: {data}")
        
        if not all(key in data for key in ['topic', 'explanation']):
            return jsonify({'error': 'Topic and explanation are required'}), 400
        
        topic = data['topic']
        explanation = data['explanation']
        grade_level = data.get('grade_level', 'high school')
        quiz_type = data.get('quiz_type', random.choice(['multiple_choice', 'short_answer']))
        
        # Build quiz generation prompt
        prompt = build_quiz_prompt(topic, explanation, grade_level, quiz_type)
        
        # Call Claude API
        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=1000,
                temperature=0.8,
                messages=[{"role": "user", "content": prompt}]
            )
            quiz_content = response.content[0].text
            logger.info(f"Generated quiz content: {len(quiz_content)} characters")
            
        except Exception as claude_error:
            logger.error(f"Claude API error in quiz generation: {str(claude_error)}")
            return fallback_quiz(quiz_type, grade_level)
        
        # Parse quiz from response
        quiz_data = parse_quiz_response(quiz_content, quiz_type)
        
        return jsonify({
            'quiz': quiz_data,
            'type': quiz_type,
            'timestamp': datetime.now().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"Quiz generation error: {str(e)}")
        return fallback_quiz(data.get('quiz_type', 'multiple_choice'), 
                           data.get('grade_level', 'high school'))

def parse_quiz_response(response, quiz_type):
    """Parse the AI response to extract quiz data"""
    try:
        # Try to find JSON in the response
        json_start = response.find('{')
        json_end = response.rfind('}') + 1
        
        if json_start >= 0 and json_end > json_start:
            json_str = response[json_start:json_end]
            return json.loads(json_str)
        else:
            raise ValueError("No valid JSON found")
            
    except Exception as e:
        logger.error(f"Error parsing quiz response: {str(e)}")
        # Return fallback quiz
        return get_fallback_quiz_data(quiz_type)

def get_fallback_quiz_data(quiz_type):
    """Return fallback quiz data when parsing fails"""
    if quiz_type == 'multiple_choice':
        return {
            "question": "Did you understand the explanation I just gave?",
            "options": [
                "A) Yes, I understand it completely",
                "B) I understand most of it",
                "C) I understand some of it",
                "D) I need more clarification"
            ],
            "correct_answer": "A",
            "explanation": "Great! Understanding the concept is the goal."
        }
    else:
        return {
            "question": "In your own words, explain what you learned from my explanation.",
            "key_points": ["Understanding of main concept", "Ability to explain in own words"],
            "sample_answer": "I learned about the main concept and can explain how it works."
        }

def fallback_quiz(quiz_type, grade_level):
    """Return fallback response when quiz generation fails"""
    return jsonify({
        'quiz': get_fallback_quiz_data(quiz_type),
        'type': quiz_type,
        'timestamp': datetime.now().isoformat(),
        'fallback': True
    }), 200

# Quiz Evaluation endpoint (for short answers)
@app.route('/api/homework-ai/evaluate-quiz', methods=['POST'])
def evaluate_quiz_answer():
    """
    Evaluate a student's quiz answer and provide feedback
    """
    try:
        data = request.get_json()
        logger.debug(f"Received quiz evaluation request: {data}")
        
        if not all(key in data for key in ['question', 'student_answer']):
            return jsonify({'error': 'Question and student answer are required'}), 400
        
        question = data['question']
        student_answer = data['student_answer']
        expected_answer = data.get('expected_answer', '')
        key_points = data.get('key_points', [])
        grade_level = data.get('grade_level', 'high school')
        
        # Build evaluation prompt
        prompt = f"""Evaluate this Grade {grade_level} student's answer to a homework help quiz question.

Question: {question}
Student's Answer: {student_answer}
Expected Answer: {expected_answer}
Key Points to Look For: {key_points}

Please evaluate the answer on a scale of 0-100% with 70% being passing.

Provide your evaluation as JSON:
{{
  "score": 85,
  "passed": true,
  "feedback": "Encouraging feedback for the student",
  "strengths": ["What they did well"],
  "improvements": ["What they could improve"],
  "needs_clarification": false
}}

Be encouraging and constructive in your feedback."""

        # Call Claude API
        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=800,
                temperature=0.6,
                messages=[{"role": "user", "content": prompt}]
            )
            evaluation_content = response.content[0].text
            
        except Exception as claude_error:
            logger.error(f"Claude API error in quiz evaluation: {str(claude_error)}")
            # Fallback evaluation
            return jsonify({
                'score': 75,
                'passed': True,
                'feedback': "Good effort! Keep practicing to improve your understanding.",
                'strengths': ["You attempted the question"],
                'improvements': ["Try to be more specific in your explanation"],
                'needs_clarification': False
            }), 200
        
        # Parse evaluation
        try:
            json_start = evaluation_content.find('{')
            json_end = evaluation_content.rfind('}') + 1
            
            if json_start >= 0 and json_end > json_start:
                json_str = evaluation_content[json_start:json_end]
                evaluation = json.loads(json_str)
                
                # Ensure required fields
                evaluation.setdefault('score', 70)
                evaluation.setdefault('passed', evaluation['score'] >= 70)
                evaluation.setdefault('feedback', 'Good effort!')
                evaluation.setdefault('strengths', [])
                evaluation.setdefault('improvements', [])
                evaluation.setdefault('needs_clarification', evaluation['score'] < 70)
                
                return jsonify(evaluation), 200
            else:
                raise ValueError("No valid JSON found")
                
        except Exception as parse_error:
            logger.error(f"Error parsing evaluation: {str(parse_error)}")
            return jsonify({
                'score': 70,
                'passed': True,
                'feedback': "Your answer shows understanding. Keep up the good work!",
                'strengths': ["Shows effort and engagement"],
                'improvements': ["Try to be more detailed"],
                'needs_clarification': False
            }), 200
        
    except Exception as e:
        logger.error(f"Quiz evaluation error: {str(e)}")
        return jsonify({'error': 'Evaluation service error', 'details': str(e)}), 500

# Get clarification/re-explanation endpoint
@app.route('/api/homework-ai/clarify', methods=['POST'])
def get_clarification():
    """
    Provide additional explanation with analogies when student needs clarification
    """
    try:
        data = request.get_json()
        
        if not data.get('original_topic'):
            return jsonify({'error': 'Original topic is required'}), 400
        
        original_topic = data['original_topic']
        original_explanation = data.get('original_explanation', '')
        grade_level = data.get('grade_level', 'high school')
        confusion_area = data.get('confusion_area', '')
        
        prompt = f"""A Grade {grade_level} student didn't fully understand my explanation and needs clarification.

Original topic: {original_topic}
My previous explanation: {original_explanation}
Area of confusion: {confusion_area}

Please provide a clearer re-explanation that:
1. Uses simple, relatable analogies
2. Includes real-world examples they'd know
3. Breaks the concept into smaller steps
4. Uses more visual/concrete language
5. Is encouraging and supportive
6. Addresses their specific confusion

Keep it conversational and at their grade level. End by checking if they understand better now."""

        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=1200,
                temperature=0.8,
                messages=[{"role": "user", "content": prompt}]
            )
            clarification = response.content[0].text.strip()
            
        except Exception as claude_error:
            logger.error(f"Claude API error in clarification: {str(claude_error)}")
            clarification = f"Let me try to explain {original_topic} in a simpler way. Think of it like something you use every day - it works step by step. Would you like me to break down any specific part?"
        
        return jsonify({
            'clarification': clarification,
            'timestamp': datetime.now().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"Clarification error: {str(e)}")
        return jsonify({'error': 'Clarification service error'}), 500

# Health check endpoint
@app.route('/api/homework-ai/health', methods=['GET'])
def homework_ai_health():
    """Health check for homework AI service"""
    return jsonify({
        'status': 'healthy',
        'service': 'homework-ai',
        'timestamp': datetime.now().isoformat()
    }), 200

# Learn and Earn Mode endpoint
@app.route('/api/homework-ai/learn-earn', methods=['POST', 'OPTIONS'])
def learn_earn_mode():
    """
    Generate a learning statement (25-30 words) with a keyword question
    for Learn and Earn mode
    """
    if request.method == 'OPTIONS':
        return '', 204

    try:
        data = request.get_json()
        logger.debug(f"Received learn-earn request: {data}")

        if not data.get('topic'):
            return jsonify({'error': 'Topic is required'}), 400

        topic = data['topic']
        grade_level = data.get('grade_level', 'high school')

        # Use Anthropic API to generate educational statement with keyword
        try:
            client = Anthropic(api_key=ANTHROPIC_API_KEY)

            prompt = f"""You are an educational AI helping students learn. Create a brief educational statement about "{topic}" that is appropriate for {grade_level} level.

Requirements:
1. Write a statement that is EXACTLY 25-30 words long
2. Include one KEY CONCEPT or KEYWORD that is central to understanding the topic
3. After the statement, create a follow-up question asking the student to identify and type this keyword
4. The keyword should be a single word or short phrase (2-3 words max) that appears in or is directly related to the statement
5. Make it educational and engaging

Format your response as JSON:
{{
    "statement": "Your 25-30 word educational statement here",
    "question": "What is the key term/concept in this statement?",
    "keyword": "the_correct_keyword",
    "explanation": "Brief explanation of why this keyword is important (1-2 sentences)"
}}

Remember: The keyword must be validatable - it should be a specific term that the student can identify from the statement."""

            message = client.messages.create(
                model="claude-3-5-sonnet-20241022",
                max_tokens=500,
                temperature=0.7,
                messages=[{
                    "role": "user",
                    "content": prompt
                }]
            )

            response_text = message.content[0].text.strip()

            # Try to parse JSON from the response
            import re
            json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if json_match:
                result = json.loads(json_match.group())

                # Validate that we have all required fields
                if all(key in result for key in ['statement', 'question', 'keyword', 'explanation']):
                    # Validate word count (25-30 words)
                    word_count = len(result['statement'].split())
                    if 25 <= word_count <= 30:
                        return jsonify({
                            'statement': result['statement'],
                            'question': result['question'],
                            'keyword': result['keyword'].lower().strip(),
                            'explanation': result['explanation'],
                            'topic': topic,
                            'timestamp': datetime.now().isoformat()
                        }), 200
                    else:
                        logger.warning(f"Statement word count {word_count} not in range 25-30")

            # Fallback if parsing fails
            raise ValueError("Could not generate proper learn-earn content")

        except Exception as api_error:
            logger.error(f"Anthropic API error in learn-earn: {str(api_error)}")

            # Fallback response
            return jsonify({
                'statement': f"Learning about {topic} helps us understand important concepts that apply to our everyday life and future studies.",
                'question': "What is the main subject we are learning about?",
                'keyword': topic.lower(),
                'explanation': f"Understanding {topic} is fundamental to building knowledge in this subject area.",
                'topic': topic,
                'timestamp': datetime.now().isoformat(),
                'fallback': True
            }), 200

    except Exception as e:
        logger.error(f"Learn-earn mode error: {str(e)}")
        return jsonify({'error': 'Learn-earn service error', 'details': str(e)}), 500

# Validate keyword and award points/a-cards
@app.route('/api/homework-ai/validate-keyword', methods=['POST', 'OPTIONS'])
def validate_keyword():
    """
    Validate student's keyword answer and award points/a-cards if correct
    """
    if request.method == 'OPTIONS':
        return '', 204

    try:
        data = request.get_json()
        logger.debug(f"Received keyword validation request: {data}")

        if not all(key in data for key in ['user_answer', 'correct_keyword', 'student_id']):
            return jsonify({'error': 'Missing required fields'}), 400

        user_answer = data['user_answer'].lower().strip()
        correct_keyword = data['correct_keyword'].lower().strip()
        student_id = data['student_id']

        # Check if answer is correct (case-insensitive, flexible matching)
        is_correct = False

        # Direct match
        if user_answer == correct_keyword:
            is_correct = True
        # Check if user answer contains the keyword or vice versa
        elif correct_keyword in user_answer or user_answer in correct_keyword:
            is_correct = True
        # Check for common variations (plurals, etc.)
        elif user_answer.rstrip('s') == correct_keyword.rstrip('s'):
            is_correct = True

        if is_correct and student_id:
            try:
                # Get student from database
                student = Student.query.get(student_id)

                if student:
                    # Award points and a-cards
                    points_to_award = 5
                    acards_to_award = 5.00

                    # Update student points
                    student.total_points = (student.total_points or 0) + points_to_award

                    # Update student a-card balance
                    old_balance = float(student.acard_balance or 0)
                    new_balance = old_balance + acards_to_award
                    student.acard_balance = new_balance

                    # Create a-card transaction record
                    transaction = ACardTransaction(
                        student_id=student_id,
                        transaction_type='learn_earn_reward',
                        amount=acards_to_award,
                        description=f'Learn and Earn reward - correct keyword answer',
                        balance_after=new_balance
                    )

                    db.session.add(transaction)
                    db.session.commit()

                    logger.info(f"Awarded {points_to_award} points and {acards_to_award} a-cards to student {student_id}")

                    return jsonify({
                        'is_correct': True,
                        'correct_keyword': correct_keyword,
                        'points_earned': points_to_award,
                        'acards_earned': acards_to_award,
                        'new_points_total': student.total_points,
                        'new_acard_balance': float(new_balance),
                        'message': 'Congratulations! You earned rewards!'
                    }), 200
                else:
                    logger.warning(f"Student {student_id} not found for reward")
                    # Still return correct status even if student not found
                    return jsonify({
                        'is_correct': True,
                        'correct_keyword': correct_keyword,
                        'points_earned': 0,
                        'acards_earned': 0,
                        'message': 'Correct answer!'
                    }), 200

            except Exception as db_error:
                logger.error(f"Database error awarding points: {str(db_error)}")
                db.session.rollback()
                # Still return correct status even if DB update fails
                return jsonify({
                    'is_correct': True,
                    'correct_keyword': correct_keyword,
                    'points_earned': 0,
                    'acards_earned': 0,
                    'message': 'Correct answer! (Rewards pending)'
                }), 200
        else:
            # Incorrect answer
            return jsonify({
                'is_correct': False,
                'correct_keyword': correct_keyword,
                'user_answer': user_answer,
                'message': 'Not quite right. Try again!'
            }), 200

    except Exception as e:
        logger.error(f"Keyword validation error: {str(e)}")
        return jsonify({'error': 'Validation service error', 'details': str(e)}), 500

# Enhanced Learn and Earn - Generate expanded 35-50 word statements
@app.route('/api/homework-ai/learn-earn-enhanced', methods=['POST', 'OPTIONS'])
def learn_earn_enhanced():
    """
    Generate an expanded learning statement (35-50 words) using the new method:
    Transform concise concepts into descriptive, inferential narratives with context, synonyms, and analogies
    """
    if request.method == 'OPTIONS':
        return '', 204

    try:
        data = request.get_json()
        logger.debug(f"Received learn-earn-enhanced request: {data}")

        if not data.get('topic'):
            return jsonify({'error': 'Topic is required'}), 400

        topic = data['topic']
        student_id = data.get('student_id', 'test')

        # Get configuration parameters
        min_words = data.get('min_words', 35)
        max_words = data.get('max_words', 50)
        grade_level = data.get('grade_level', 'middle')
        complexity = data.get('complexity', 'moderate')

        # Map grade level to description
        grade_descriptions = {
            'elementary': 'elementary school students (ages 6-11)',
            'middle': 'middle school students (ages 11-14)',
            'senior': 'high school students (ages 14-18)'
        }
        grade_desc = grade_descriptions.get(grade_level, 'middle school students')

        # Map complexity to temperature and instruction
        complexity_settings = {
            'basic': (0.6, 'simple and straightforward'),
            'moderate': (0.8, 'moderately complex with some analogies'),
            'advanced': (0.9, 'highly descriptive with metaphors and nuanced details')
        }
        temperature, complexity_desc = complexity_settings.get(complexity, (0.8, 'moderately complex'))

        # Use Anthropic API to generate expanded educational statement
        try:
            client = Anthropic(api_key=ANTHROPIC_API_KEY)

            prompt = f"""Create an expanded educational statement about "{topic}" using this method:

CORE METHOD:
1. Identify the Core Idea about {topic}
2. Expand with Context and Synonyms or analogies
3. Include subtle details that force "reading between the lines"
4. Transform concise, declarative statements into descriptive, inferential narratives that require reflection to distill

REQUIREMENTS:
- Statement must be EXACTLY {min_words}-{max_words} words
- Target audience: {grade_desc}
- Complexity level: {complexity_desc}
- DO NOT include any greeting like "Hello! I'm StudyBot"
- DO NOT include any closing like "Let me know if you need help"
- ONLY provide the educational statement itself
- Make it descriptive and rich with context
- Include synonyms, analogies, or metaphors appropriate for the grade level
- Add subtle nuances that require thoughtful comprehension
- The statement should be something a student needs to "distill" back to its core meaning

Example format for a different topic (Photosynthesis):
"Photosynthesis, the biochemical symphony orchestrated by chloroplasts, harnesses electromagnetic radiation from our star, transforming carbon dioxide and water molecules into glucose through an intricate cascade of light-dependent and Calvin cycle reactions, essentially converting luminous energy into chemical sustenance."

Now create a similar expanded statement for: {topic}

Provide ONLY the statement text, nothing else."""

            message = client.messages.create(
                model="claude-3-5-sonnet-20241022",
                max_tokens=300,
                temperature=temperature,
                messages=[{
                    "role": "user",
                    "content": prompt
                }]
            )

            statement = message.content[0].text.strip()

            # Validate word count
            word_count = len(statement.split())

            if word_count < min_words or word_count > max_words:
                logger.warning(f"Statement word count {word_count} not in range {min_words}-{max_words}, regenerating...")
                # Try once more with stricter instruction
                prompt_strict = f"{prompt}\n\nIMPORTANT: Your response must be between {min_words}-{max_words} words. Current attempt had {word_count} words."
                message = client.messages.create(
                    model="claude-3-5-sonnet-20241022",
                    max_tokens=300,
                    temperature=temperature - 0.1,
                    messages=[{
                        "role": "user",
                        "content": prompt_strict
                    }]
                )
                statement = message.content[0].text.strip()
                word_count = len(statement.split())

            return jsonify({
                'statement': statement,
                'topic': topic,
                'word_count': word_count,
                'timestamp': datetime.now().isoformat()
            }), 200

        except Exception as api_error:
            logger.error(f"Anthropic API error in learn-earn-enhanced: {str(api_error)}")

            # Fallback response for testing (about Cell)
            fallback_statements = {
                'cell': "The cell membrane, a selectively permeable phospholipid bilayer, orchestrates molecular traffic through protein channels and pumps, maintaining homeostasis by controlling what substances enter or exit the cellular environment, functioning as the gatekeeper of life's fundamental unit.",
                'photosynthesis': "Photosynthesis, nature's solar-powered factory, converts electromagnetic radiation into chemical energy through chloroplast-mediated reactions, where carbon dioxide and water molecules undergo transformation into glucose, essentially capturing starlight and binding it into the molecular architecture of sugars.",
                'mitosis': "Mitosis represents cellular reproduction's elegant choreography, where duplicated chromosomes align along the metaphase plate before sister chromatids separate, ensuring genetic continuity through precise distribution of hereditary material into two genetically identical daughter cells.",
            }

            fallback_statement = fallback_statements.get(topic.lower(),
                f"The concept of {topic} encompasses interconnected principles and mechanisms that operate through systematic processes, involving multiple components that interact dynamically to achieve specific outcomes, demonstrating the intricate relationships between structure and function in this domain.")

            return jsonify({
                'statement': fallback_statement,
                'topic': topic,
                'word_count': len(fallback_statement.split()),
                'timestamp': datetime.now().isoformat(),
                'fallback': True
            }), 200

    except Exception as e:
        logger.error(f"Learn-earn-enhanced error: {str(e)}")
        return jsonify({'error': 'Learn-earn-enhanced service error', 'details': str(e)}), 500

# Evaluate student's 15-word summary with AI scoring
@app.route('/api/homework-ai/evaluate-summary', methods=['POST', 'OPTIONS'])
def evaluate_summary():
    """
    Evaluate a student's 15-word summary against the original statement
    Returns a score (0-100) and detailed feedback
    """
    if request.method == 'OPTIONS':
        return '', 204

    try:
        data = request.get_json()
        logger.debug(f"Received summary evaluation request: {data}")

        if not all(key in data for key in ['original_statement', 'student_summary']):
            return jsonify({'error': 'Missing required fields'}), 400

        original_statement = data['original_statement']
        student_summary = data['student_summary']
        student_id = data.get('student_id', 'test')

        # Use Anthropic API to evaluate the summary
        try:
            client = Anthropic(api_key=ANTHROPIC_API_KEY)

            prompt = f"""You are an educational AI evaluating a student's comprehension.

ORIGINAL STATEMENT (35-50 words):
"{original_statement}"

STUDENT'S 15-WORD SUMMARY:
"{student_summary}"

EVALUATION CRITERIA:
1. Core Concept Capture (40 points): Did the student identify the main idea?
2. Key Details (30 points): Did they include essential elements or mechanisms?
3. Accuracy (20 points): Is the summary factually correct?
4. Clarity (10 points): Is the summary coherent and well-expressed?

Provide a score from 0-100 and constructive feedback.

Respond in this EXACT JSON format:
{{
    "score": 85,
    "feedback": "Your summary captured the main concept well and included key mechanisms. You could improve by mentioning the specific outcome or purpose.",
    "strengths": ["Identified core concept", "Accurate terminology"],
    "improvements": ["Could mention the purpose or outcome"]
}}

Be fair but rigorous in your evaluation. A perfect score should be rare."""

            message = client.messages.create(
                model="claude-3-5-sonnet-20241022",
                max_tokens=500,
                temperature=0.3,
                messages=[{
                    "role": "user",
                    "content": prompt
                }]
            )

            response_text = message.content[0].text.strip()

            # Try to parse JSON from the response
            import re
            json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if json_match:
                result = json.loads(json_match.group())

                # Validate that we have required fields
                if 'score' in result and 'feedback' in result:
                    score = int(result['score'])

                    # Ensure score is in valid range
                    score = max(0, min(100, score))

                    return jsonify({
                        'score': score,
                        'feedback': result['feedback'],
                        'strengths': result.get('strengths', []),
                        'improvements': result.get('improvements', []),
                        'timestamp': datetime.now().isoformat()
                    }), 200

            # Fallback if parsing fails
            raise ValueError("Could not parse evaluation result")

        except Exception as api_error:
            logger.error(f"Anthropic API error in evaluate-summary: {str(api_error)}")

            # Fallback evaluation - simple word matching
            original_words = set(original_statement.lower().split())
            summary_words = set(student_summary.lower().split())

            # Calculate overlap
            overlap = len(original_words & summary_words)
            overlap_ratio = overlap / len(original_words) if original_words else 0

            # Simple scoring based on word overlap
            base_score = int(overlap_ratio * 100)

            # Adjust based on summary length (should be around 15 words)
            summary_word_count = len(student_summary.split())
            if summary_word_count < 10 or summary_word_count > 20:
                base_score = int(base_score * 0.8)

            score = max(0, min(100, base_score))

            return jsonify({
                'score': score,
                'feedback': f"Your summary shows {['limited', 'basic', 'good', 'excellent'][min(3, score//25)]} understanding. Keep practicing to improve your ability to distill complex concepts!",
                'strengths': ["Attempted the summary"],
                'improvements': ["Try to capture more key concepts from the original statement"],
                'timestamp': datetime.now().isoformat(),
                'fallback': True
            }), 200

    except Exception as e:
        logger.error(f"Summary evaluation error: {str(e)}")
        return jsonify({'error': 'Evaluation service error', 'details': str(e)}), 500

# Award points and a-cards based on score
@app.route('/api/student/award-learn-earn', methods=['POST', 'OPTIONS'])
def award_learn_earn():
    """
    Award points and a-cards to student based on their learn-earn performance
    Scoring tiers:
    - Below 50%: 0 points, 0 a-cards
    - 50-75%: 2.5 points, 2.5 a-cards (half rewards)
    - 76-100%: 5 points, 5 a-cards (full rewards)
    """
    if request.method == 'OPTIONS':
        return '', 204

    try:
        data = request.get_json()
        logger.debug(f"Received award-learn-earn request: {data}")

        student_id = data.get('student_id')
        points = data.get('points', 0)
        acard = data.get('acard', 0)
        topic = data.get('topic', 'Unknown')

        if not student_id:
            return jsonify({'error': 'Student ID is required'}), 400

        if points == 0 and acard == 0:
            return jsonify({
                'success': True,
                'message': 'No rewards to award',
                'points_awarded': 0,
                'acard_awarded': 0
            }), 200

        try:
            # Get student from database
            student = Student.query.get(student_id)

            if student:
                # Update student points
                student.total_points = (student.total_points or 0) + points

                # Update student a-card balance
                old_balance = float(student.acard_balance or 0)
                new_balance = old_balance + acard
                student.acard_balance = new_balance

                # Create a-card transaction record
                transaction = ACardTransaction(
                    student_id=student_id,
                    transaction_type='learn_earn_summary',
                    amount=acard,
                    description=f'Learn and Earn - {topic} summary',
                    balance_after=new_balance
                )

                db.session.add(transaction)
                db.session.commit()

                logger.info(f"Awarded {points} points and {acard} a-cards to student {student_id} for {topic}")

                return jsonify({
                    'success': True,
                    'points_awarded': points,
                    'acard_awarded': acard,
                    'new_points_total': student.total_points,
                    'new_acard_balance': float(new_balance),
                    'message': 'Rewards awarded successfully!'
                }), 200
            else:
                logger.warning(f"Student {student_id} not found for learn-earn reward")
                return jsonify({
                    'success': False,
                    'error': 'Student not found'
                }), 404

        except Exception as db_error:
            logger.error(f"Database error awarding learn-earn points: {str(db_error)}")
            db.session.rollback()
            return jsonify({
                'success': False,
                'error': 'Failed to award rewards',
                'details': str(db_error)
            }), 500

    except Exception as e:
        logger.error(f"Award learn-earn error: {str(e)}")
        return jsonify({'error': 'Award service error', 'details': str(e)}), 500

# Admin Configuration Endpoints
@app.route('/api/admin/learn-earn-config', methods=['GET', 'OPTIONS'])
def get_learn_earn_config():
    """
    Get Learn and Earn configuration for a specific grade/category
    Query params: grade_level, category_type, category_name
    """
    if request.method == 'OPTIONS':
        return '', 204

    try:
        grade_level = request.args.get('grade_level')
        category_type = request.args.get('category_type')
        category_name = request.args.get('category_name')

        # If parameters provided, get specific config
        if grade_level and category_type and category_name:
            config = LearnEarnConfig.query.filter_by(
                grade_level=grade_level,
                category_type=category_type,
                category_name=category_name,
                is_active=True
            ).first()

            if config:
                return jsonify(config.to_dict()), 200
            else:
                # Return default for this combination
                default = LearnEarnConfig.get_default_config(grade_level, category_type, category_name)
                return jsonify(default), 200

        # Otherwise return all active configs
        configs = LearnEarnConfig.query.filter_by(is_active=True).all()
        return jsonify([c.to_dict() for c in configs]), 200

    except Exception as e:
        logger.error(f"Error fetching learn-earn config: {str(e)}")
        return jsonify({'error': 'Failed to fetch configuration', 'details': str(e)}), 500

@app.route('/api/admin/learn-earn-config', methods=['POST'])
def save_learn_earn_config():
    """
    Save or update Learn and Earn configuration for a specific grade/category
    """
    try:
        data = request.get_json()
        logger.debug(f"Received config save request: {data}")

        # Validate required fields
        required = ['grade_level', 'category_type', 'category_name', 'topics']
        for field in required:
            if field not in data:
                return jsonify({'error': f'{field} is required'}), 400

        if not isinstance(data['topics'], list):
            return jsonify({'error': 'Topics must be an array'}), 400

        # Check if config exists for this combination
        existing = LearnEarnConfig.query.filter_by(
            grade_level=data['grade_level'],
            category_type=data['category_type'],
            category_name=data['category_name']
        ).first()

        if existing:
            # Update existing
            existing.num_topics = data.get('num_topics', 5)
            existing.countdown_minutes = data.get('countdown_minutes', 2.5)
            existing.daily_limit = data.get('daily_limit', 5)
            existing.min_words = data.get('min_words', 35)
            existing.max_words = data.get('max_words', 50)
            existing.summary_words = data.get('summary_words', 15)
            existing.complexity_level = data.get('complexity_level', 'moderate')
            existing.set_topics(data['topics'])
            existing.set_rewards(data.get('rewards', existing.default_rewards()))
            existing.is_active = True
            existing.updated_at = datetime.now()
            config = existing
        else:
            # Create new
            config = LearnEarnConfig(
                grade_level=data['grade_level'],
                category_type=data['category_type'],
                category_name=data['category_name'],
                num_topics=data.get('num_topics', 5),
                countdown_minutes=data.get('countdown_minutes', 2.5),
                daily_limit=data.get('daily_limit', 5),
                min_words=data.get('min_words', 35),
                max_words=data.get('max_words', 50),
                summary_words=data.get('summary_words', 15),
                complexity_level=data.get('complexity_level', 'moderate'),
                is_active=True
            )
            config.set_topics(data['topics'])
            config.set_rewards(data.get('rewards', config.default_rewards()))
            db.session.add(config)

        db.session.commit()
        logger.info(f"Learn-earn configuration saved: {config.id}")

        return jsonify({
            'success': True,
            'message': 'Configuration saved successfully',
            'config': config.to_dict()
        }), 200

    except Exception as e:
        logger.error(f"Error saving learn-earn config: {str(e)}")
        db.session.rollback()
        return jsonify({'error': 'Failed to save configuration', 'details': str(e)}), 500

@app.route('/api/learn-earn/get-topic', methods=['POST', 'OPTIONS'])
def get_learn_earn_topic():
    """
    Get topic for a specific grade/category combination
    """
    if request.method == 'OPTIONS':
        return '', 204

    try:
        data = request.get_json()
        student_id = data.get('student_id')
        topic_index = data.get('topic_index', 0)
        grade_level = data.get('grade_level', 'middle')
        category_type = data.get('category_type', 'subject')
        category_name = data.get('category_name', 'science')

        # Get configuration for this specific combination
        config = LearnEarnConfig.query.filter_by(
            grade_level=grade_level,
            category_type=category_type,
            category_name=category_name,
            is_active=True
        ).first()

        if not config:
            # Return default for this combination
            default = LearnEarnConfig.get_default_config(grade_level, category_type, category_name)
            topics = default['topics']
            topic = topics[topic_index % len(topics)] if topics else 'Topic'

            return jsonify({
                'topic': topic,
                'config': {
                    'countdown_minutes': default['countdown_minutes'],
                    'daily_limit': default['daily_limit'],
                    'summary_words': default['summary_words'],
                    'min_words': default['min_words'],
                    'max_words': default['max_words'],
                    'grade_level': grade_level,
                    'category_type': category_type,
                    'category_name': category_name,
                    'complexity_level': default['complexity_level'],
                    'rewards': default['rewards']
                }
            }), 200

        topics = config.get_topics()
        if not topics:
            topics = ['Topic 1']

        # Get topic for the day (rotate through topics)
        topic = topics[topic_index % len(topics)]

        return jsonify({
            'topic': topic,
            'config': {
                'countdown_minutes': float(config.countdown_minutes),
                'daily_limit': config.daily_limit,
                'summary_words': config.summary_words,
                'min_words': config.min_words,
                'max_words': config.max_words,
                'grade_level': config.grade_level,
                'category_type': config.category_type,
                'category_name': config.category_name,
                'complexity_level': config.complexity_level,
                'rewards': config.get_rewards()
            }
        }), 200

    except Exception as e:
        logger.error(f"Error getting topic: {str(e)}")
        return jsonify({'error': 'Failed to get topic', 'details': str(e)}), 500

@app.route('/api/admin/learn-earn-defaults', methods=['POST', 'OPTIONS'])
def initialize_learn_earn_defaults():
    """
    Initialize default configurations for all grade/subject/skill combinations
    """
    if request.method == 'OPTIONS':
        return '', 204

    try:
        grades = ['elementary', 'middle', 'senior']
        subjects = ['mathematics', 'english', 'science']
        skills = ['graphics', 'coding', 'video-editing']

        created_count = 0

        for grade in grades:
            # Create subject configs
            for subject in subjects:
                existing = LearnEarnConfig.query.filter_by(
                    grade_level=grade,
                    category_type='subject',
                    category_name=subject
                ).first()

                if not existing:
                    default = LearnEarnConfig.get_default_config(grade, 'subject', subject)
                    config = LearnEarnConfig(
                        grade_level=grade,
                        category_type='subject',
                        category_name=subject,
                        num_topics=default['num_topics'],
                        countdown_minutes=default['countdown_minutes'],
                        daily_limit=default['daily_limit'],
                        min_words=default['min_words'],
                        max_words=default['max_words'],
                        summary_words=default['summary_words'],
                        complexity_level=default['complexity_level'],
                        is_active=True
                    )
                    config.set_topics(default['topics'])
                    config.set_rewards(default['rewards'])
                    db.session.add(config)
                    created_count += 1

            # Create skill configs
            for skill in skills:
                existing = LearnEarnConfig.query.filter_by(
                    grade_level=grade,
                    category_type='skill',
                    category_name=skill
                ).first()

                if not existing:
                    default = LearnEarnConfig.get_default_config(grade, 'skill', skill)
                    config = LearnEarnConfig(
                        grade_level=grade,
                        category_type='skill',
                        category_name=skill,
                        num_topics=default['num_topics'],
                        countdown_minutes=default['countdown_minutes'],
                        daily_limit=default['daily_limit'],
                        min_words=default['min_words'],
                        max_words=default['max_words'],
                        summary_words=default['summary_words'],
                        complexity_level=default['complexity_level'],
                        is_active=True
                    )
                    config.set_topics(default['topics'])
                    config.set_rewards(default['rewards'])
                    db.session.add(config)
                    created_count += 1

        db.session.commit()
        logger.info(f"Created {created_count} default learn-earn configurations")

        return jsonify({
            'success': True,
            'message': f'Created {created_count} default configurations',
            'created_count': created_count
        }), 200

    except Exception as e:
        logger.error(f"Error creating defaults: {str(e)}")
        db.session.rollback()
        return jsonify({'error': 'Failed to create defaults', 'details': str(e)}), 500


from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
# Enhanced location/currency endpoint
@app.route('/api/get-pricing', methods=['POST'])
def get_localized_pricing():
    try:
        data = request.get_json()
        country_code = data.get('country_code', 'US')
        currency = data.get('currency', 'USD')
        
        # Your currency conversion logic here
        base_prices = {
            'digital_monthly': 29,
            'digital_3month': 79,
            'digital_6month': 149,
            'dvc_term': 199,
            'dvc_annual': 599,
            'dvc_multi': 1499
        }
        
        # Apply regional pricing adjustments
        regional_multipliers = {
            'NG': 0.3,  # Nigeria
            'KE': 0.4,  # Kenya
            'GH': 0.35, # Ghana
            'ZA': 0.5,  # South Africa
            'IN': 0.25, # India
            'BD': 0.2,  # Bangladesh
            'PK': 0.25, # Pakistan
            'EG': 0.3,  # Egypt
            'US': 1.0,  # United States
            'GB': 1.0,  # United Kingdom
            'CA': 0.9,  # Canada
            'AU': 0.9,  # Australia
            'DE': 0.95, # Germany
            'FR': 0.95, # France
        }
        
        multiplier = regional_multipliers.get(country_code, 0.8)  # Default for unlisted countries
        
        adjusted_prices = {}
        for key, price in base_prices.items():
            adjusted_prices[key] = round(price * multiplier, 2)
        
        return jsonify({
            'prices': adjusted_prices,
            'currency': currency,
            'country_code': country_code,
            'multiplier': multiplier
        }), 200
        
    except Exception as e:
        logger.error(f"Pricing error: {str(e)}")
        return jsonify({'error': 'Could not fetch pricing'}), 500

    # Your existing code...
    
# Input validation and sanitization
def sanitize_input(text):
    """Clean user input to prevent XSS and injection attacks"""
    import re
    # Remove HTML tags and suspicious patterns
    clean_text = re.sub(r'<[^>]*>', '', text)
    clean_text = re.sub(r'javascript:', '', clean_text, flags=re.IGNORECASE)
    clean_text = clean_text.strip()[:500]  # Limit length
    return clean_text

@app.route('/api/chatbot-analytics', methods=['GET'])
def get_chatbot_analytics():
    try:
        # Query your database for conversation metrics
        analytics = {
            'total_conversations': 1250,
            'avg_response_time': 2.3,
            'satisfaction_rate': 0.87,
            'top_inquiries': [
                {'topic': 'pricing', 'count': 450},
                {'topic': 'digital_skills', 'count': 320},
                {'topic': 'demo_requests', 'count': 280},
                {'topic': 'technical_support', 'count': 200}
            ],
            'resolution_rate': 0.74
        }
        
        return jsonify(analytics), 200
        
    except Exception as e:
        logger.error(f"Analytics error: {str(e)}")
        return jsonify({'error': 'Could not fetch analytics'}), 500

# Lead generation from chatbot
@app.route('/api/chatbot-lead', methods=['POST'])
def capture_chatbot_lead():
    try:
        data = request.get_json()
        
        # Capture lead information
        lead_data = {
            'email': data.get('email'),
            'service_interest': data.get('service'),
            'location': data.get('location'),
            'conversation_summary': data.get('summary'),
            'created_at': datetime.utcnow(),
            'source': 'chatbot'
        }
        
        # Save to database
        # save_lead_to_db(lead_data)
        
        # Send notification email to sales team
        # send_sales_notification(lead_data)
        
        return jsonify({'status': 'success', 'message': 'Thank you! Our team will contact you soon.'}), 200
        
    except Exception as e:
        logger.error(f"Lead capture error: {str(e)}")
        return jsonify({'error': 'Could not save lead information'}), 500

@app.route('/api/admin/messages/send', methods=['POST'])
@admin_required
def send_admin_message():
    """Send message from admin to students or other admins"""
    try:
        data = request.get_json()
        
        required_fields = ['recipients', 'subject', 'message_body']
        if not all(field in data for field in required_fields):
            return jsonify({'error': 'Missing required fields: recipients, subject, message_body'}), 400
        
        recipients = data['recipients']  # List of {id, type} objects
        subject = data['subject']
        message_body = data['message_body']
        message_type = data.get('message_type', 'general')
        priority = data.get('priority', 'normal')
        
        if not recipients or len(recipients) == 0:
            return jsonify({'error': 'At least one recipient is required'}), 400
        
        # Generate broadcast group ID if multiple recipients
        broadcast_group_id = None
        is_broadcast = len(recipients) > 1
        if is_broadcast:
            import uuid
            broadcast_group_id = str(uuid.uuid4())
        
        sent_messages = []
        failed_recipients = []
        
        # Send message to each recipient
        for recipient in recipients:
            try:
                recipient_id = recipient['id']
                recipient_type = recipient['type']
                
                # Validate recipient exists
                if recipient_type == 'student':
                    recipient_obj = Student.query.get(recipient_id)
                elif recipient_type in ['admin', 'super_admin']:
                    recipient_obj = Admin.query.get(recipient_id)
                else:
                    failed_recipients.append({'id': recipient_id, 'type': recipient_type, 'error': 'Invalid recipient type'})
                    continue
                
                if not recipient_obj:
                    failed_recipients.append({'id': recipient_id, 'type': recipient_type, 'error': 'Recipient not found'})
                    continue
                
                # Create message
                message = MailMessage(
                    sender_id=request.current_admin.id,
                    sender_type=request.current_admin.role,
                    recipient_id=recipient_id,
                    recipient_type=recipient_type,
                    subject=subject,
                    message_body=message_body,
                    message_type=message_type,
                    priority=priority,
                    is_broadcast=is_broadcast,
                    broadcast_group_id=broadcast_group_id
                )
                
                db.session.add(message)
                db.session.flush()
                
                sent_messages.append({
                    'message_id': message.id,
                    'recipient_id': recipient_id,
                    'recipient_type': recipient_type,
                    'recipient_name': message.get_recipient_name()
                })
                
            except Exception as e:
                logger.error(f"Error sending message to recipient {recipient}: {str(e)}")
                failed_recipients.append({'id': recipient.get('id'), 'type': recipient.get('type'), 'error': str(e)})
        
        db.session.commit()
        
        logger.info(f"Admin {request.current_admin.id} sent {len(sent_messages)} messages")
        
        return jsonify({
            'message': f'Message sent successfully to {len(sent_messages)} recipients',
            'sent_messages': sent_messages,
            'failed_recipients': failed_recipients,
            'broadcast_group_id': broadcast_group_id,
            'total_sent': len(sent_messages),
            'total_failed': len(failed_recipients)
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Send message error: {str(e)}")
        return jsonify({'error': f'Failed to send message: {str(e)}'}), 500

@app.route('/api/admin/messages/inbox', methods=['GET'])
@admin_required
def get_admin_inbox():
    """Get inbox messages for admin"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = min(request.args.get('per_page', 20, type=int), 100)
        message_type = request.args.get('type', '')
        is_read = request.args.get('is_read', '')
        
        # Build query
        query = Message.query.filter(
            Message.recipient_id == request.current_admin.id,
            Message.recipient_type.in_(['admin', 'super_admin'])
        )
        
        # Apply filters
        if message_type:
            query = query.filter(Message.message_type == message_type)
        
        if is_read:
            read_status = is_read.lower() == 'true'
            query = query.filter(Message.is_read == read_status)
        
        # Order by most recent first
        query = query.order_by(Message.created_at.desc())
        
        # Paginate
        pagination = query.paginate(
            page=page, 
            per_page=per_page, 
            error_out=False
        )
        
        messages = [message.to_dict() for message in pagination.items]
        
        # Get unread count
        unread_count = Message.query.filter(
            Message.recipient_id == request.current_admin.id,
            Message.recipient_type.in_(['admin', 'super_admin']),
            Message.is_read == False
        ).count()
        
        return jsonify({
            'messages': messages,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': pagination.total,
                'pages': pagination.pages,
                'has_next': pagination.has_next,
                'has_prev': pagination.has_prev
            },
            'unread_count': unread_count
        }), 200
        
    except Exception as e:
        logger.error(f"Get admin inbox error: {str(e)}")
        return jsonify({'error': 'Failed to load inbox'}), 500

@app.route('/api/admin/messages/<int:message_id>/read', methods=['POST'])
@admin_required
def mark_admin_message_read(message_id):
    """Mark admin message as read"""
    try:
        message = Message.query.filter(
            Message.id == message_id,
            Message.recipient_id == request.current_admin.id,
            Message.recipient_type.in_(['admin', 'super_admin'])
        ).first()
        
        if not message:
            return jsonify({'error': 'Message not found'}), 404
        
        if not message.is_read:
            message.is_read = True
            message.read_at = datetime.utcnow()
            db.session.commit()
        
        return jsonify({
            'message': 'Message marked as read',
            'message_id': message_id
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Mark message read error: {str(e)}")
        return jsonify({'error': 'Failed to mark message as read'}), 500

@app.route('/api/admin/messages/unread-count', methods=['GET'])
@admin_required
def get_admin_unread_count():
    """Get unread message count for admin"""
    try:
        unread_count = Message.query.filter(
            Message.recipient_id == request.current_admin.id,
            Message.recipient_type.in_(['admin', 'super_admin']),
            Message.is_read == False
        ).count()
        
        return jsonify({
            'unread_count': unread_count
        }), 200
        
    except Exception as e:
        logger.error(f"Get unread count error: {str(e)}")
        return jsonify({'error': 'Failed to get unread count'}), 500

@app.route('/api/student/messages/inbox', methods=['GET'])
@student_required
def get_student_inbox():
    """Get inbox messages for student"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = min(request.args.get('per_page', 20, type=int), 100)
        message_type = request.args.get('type', '')
        is_read = request.args.get('is_read', '')
        
        # Build query
        query = Message.query.filter(
            Message.recipient_id == request.current_student.id,
            Message.recipient_type == 'student'
        )
        
        # Apply filters
        if message_type:
            query = query.filter(Message.message_type == message_type)
        
        if is_read:
            read_status = is_read.lower() == 'true'
            query = query.filter(Message.is_read == read_status)
        
        # Order by most recent first
        query = query.order_by(Message.created_at.desc())
        
        # Paginate
        pagination = query.paginate(
            page=page, 
            per_page=per_page, 
            error_out=False
        )
        
        messages = [message.to_dict() for message in pagination.items]
        
        # Get unread count
        unread_count = Message.query.filter(
            Message.recipient_id == request.current_student.id,
            Message.recipient_type == 'student',
            Message.is_read == False
        ).count()
        
        return jsonify({
            'messages': messages,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': pagination.total,
                'pages': pagination.pages,
                'has_next': pagination.has_next,
                'has_prev': pagination.has_prev
            },
            'unread_count': unread_count
        }), 200
        
    except Exception as e:
        logger.error(f"Get student inbox error: {str(e)}")
        return jsonify({'error': 'Failed to load inbox'}), 500

@app.route('/api/student/messages/<int:message_id>/read', methods=['POST'])
@student_required
def mark_student_message_read(message_id):
    """Mark student message as read"""
    try:
        message = Message.query.filter(
            Message.id == message_id,
            Message.recipient_id == request.current_student.id,
            Message.recipient_type == 'student'
        ).first()
        
        if not message:
            return jsonify({'error': 'Message not found'}), 404
        
        if not message.is_read:
            message.is_read = True
            message.read_at = datetime.utcnow()
            db.session.commit()
        
        return jsonify({
            'message': 'Message marked as read',
            'message_id': message_id
        }), 200
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Mark student message read error: {str(e)}")
        return jsonify({'error': 'Failed to mark message as read'}), 500

@app.route('/api/student/messages/unread-count', methods=['GET'])
@student_required
def get_student_unread_count():
    """Get unread message count for student"""
    try:
        unread_count = Message.query.filter(
            Message.recipient_id == request.current_student.id,
            Message.recipient_type == 'student',
            Message.is_read == False
        ).count()
        
        return jsonify({
            'unread_count': unread_count
        }), 200
        
    except Exception as e:
        logger.error(f"Get student unread count error: {str(e)}")
        return jsonify({'error': 'Failed to get unread count'}), 500

@app.route('/api/admin/students/for-messaging', methods=['GET'])
@admin_required
def get_students_for_messaging():
    """Get students that admin can send messages to"""
    try:
        grade_filter = request.args.get('grade', '')
        school_filter = request.args.get('school', '')
        search_query = request.args.get('search', '')
        
        # Build query based on admin role
        if request.current_admin.role == 'super_admin':
            # Super admin can message all students
            query = Student.query
        else:
            # Regular admin can only message their assigned students
            query = Student.query.filter(Student.admin_id == request.current_admin.id)
        
        # Apply filters
        if grade_filter:
            query = query.filter(Student.grade_level == grade_filter)
        
        if school_filter:
            query = query.filter(Student.school_name.ilike(f'%{school_filter}%'))
        
        if search_query:
            query = query.filter(
                db.or_(
                    Student.name.ilike(f'%{search_query}%'),
                    Student.email.ilike(f'%{search_query}%')
                )
            )
        
        students = query.order_by(Student.name).all()
        
        students_data = []
        for student in students:
            students_data.append({
                'id': student.id,
                'name': student.name,
                'email': student.email,
                'grade_level': student.grade_level,
                'school_name': student.school_name,
                'type': 'student'
            })
        
        return jsonify({
            'students': students_data,
            'total_count': len(students_data)
        }), 200
        
    except Exception as e:
        logger.error(f"Get students for messaging error: {str(e)}")
        return jsonify({'error': 'Failed to load students'}), 500

@app.route('/api/admin/admins/for-messaging', methods=['GET'])
@admin_required
def get_admins_for_messaging():
    """Get other admins that can receive messages"""
    try:
        search_query = request.args.get('search', '')
        
        # Get all admins except current one
        query = Admin.query.filter(Admin.id != request.current_admin.id)
        
        if search_query:
            query = query.filter(
                db.or_(
                    Admin.name.ilike(f'%{search_query}%'),
                    Admin.email.ilike(f'%{search_query}%')
                )
            )
        
        admins = query.order_by(Admin.name).all()
        
        admins_data = []
        for admin in admins:
            admins_data.append({
                'id': admin.id,
                'name': admin.name,
                'email': admin.email,
                'role': admin.role,
                'grade_section': getattr(admin, 'grade_section', 'N/A'),
                'type': admin.role
            })
        
        return jsonify({
            'admins': admins_data,
            'total_count': len(admins_data)
        }), 200
        
    except Exception as e:
        logger.error(f"Get admins for messaging error: {str(e)}")
        return jsonify({'error': 'Failed to load admins'}), 500


# ============================================
# CUSTOMER SUPPORT CHAT ENDPOINTS
# ============================================

def generate_ai_welcome_message():
    """
    Generate AI welcome message with inquiry options for new customers
    """
    welcome_message = """Hello! ðŸ‘‹ Welcome to Decipher Academy Support!

I'm here to help you get started. A customer support representative will join you shortly.

To help us serve you better, please select what you'd like to inquire about:

1ï¸âƒ£ Enrollment & Registration
2ï¸âƒ£ Course Information & Curriculum
3ï¸âƒ£ Payment & Billing
4ï¸âƒ£ Technical Support
5ï¸âƒ£ Tutoring Services
6ï¸âƒ£ Certificates & Progress
7ï¸âƒ£ Other Inquiries

Please type the number of your choice (1-7), and I'll connect you with the right specialist!"""

    return welcome_message


def generate_ai_acknowledgment(inquiry_type):
    """
    Generate AI acknowledgment message after customer selects inquiry type
    """
    inquiry_map = {
        '1': 'Enrollment & Registration',
        '2': 'Course Information & Curriculum',
        '3': 'Payment & Billing',
        '4': 'Technical Support',
        '5': 'Tutoring Services',
        '6': 'Certificates & Progress',
        '7': 'Other Inquiries'
    }

    topic = inquiry_map.get(inquiry_type, 'General')

    acknowledgment = f"""Thank you! I've noted that you need help with: **{topic}**

A customer support representative has been notified and will be with you shortly.

Feel free to describe your question or concern in detail, and our team will assist you as soon as possible!"""

    return acknowledgment


def send_whatsapp_notification(message_text, session_info=None, inquiry_type=None):
    """
    Send WhatsApp notification to support team when a customer sends a message
    """
    try:
        # Get Twilio credentials from environment
        account_sid = os.getenv('TWILIO_ACCOUNT_SID')
        auth_token = os.getenv('TWILIO_AUTH_TOKEN')
        from_whatsapp = os.getenv('TWILIO_WHATSAPP_FROM', 'whatsapp:+14155238886')
        to_whatsapp = os.getenv('SUPPORT_WHATSAPP_NUMBER', 'whatsapp:+447979145157')

        if not account_sid or not auth_token:
            logger.warning("Twilio credentials not configured. Skipping WhatsApp notification.")
            return False

        # Initialize Twilio client
        twilio_client = TwilioClient(account_sid, auth_token)

        # Prepare notification message
        inquiry_map = {
            '1': 'Enrollment & Registration',
            '2': 'Course Information & Curriculum',
            '3': 'Payment & Billing',
            '4': 'Technical Support',
            '5': 'Tutoring Services',
            '6': 'Certificates & Progress',
            '7': 'Other Inquiries'
        }

        customer_name = session_info.get('customer_name', 'A customer') if session_info else 'A customer'
        notification_message = f"ðŸ”” New Customer Support Request\n\n"
        notification_message += f"From: {customer_name}\n"
        if session_info and session_info.get('customer_email'):
            notification_message += f"Email: {session_info['customer_email']}\n"
        if inquiry_type:
            topic = inquiry_map.get(inquiry_type, 'General')
            notification_message += f"Topic: {topic}\n"
        notification_message += f"\nMessage: {message_text[:200]}"
        if len(message_text) > 200:
            notification_message += "..."

        # Send WhatsApp message
        message = twilio_client.messages.create(
            from_=from_whatsapp,
            body=notification_message,
            to=to_whatsapp
        )

        logger.info(f"WhatsApp notification sent successfully. SID: {message.sid}")
        return True

    except Exception as e:
        logger.error(f"Failed to send WhatsApp notification: {str(e)}")
        return False


def send_email_notification(message_text, session_info=None, inquiry_type=None):
    """
    Send email notification to support team when a customer sends a message
    """
    try:
        # Prepare notification content
        inquiry_map = {
            '1': 'Enrollment & Registration',
            '2': 'Course Information & Curriculum',
            '3': 'Payment & Billing',
            '4': 'Technical Support',
            '5': 'Tutoring Services',
            '6': 'Certificates & Progress',
            '7': 'Other Inquiries'
        }

        customer_name = session_info.get('customer_name', 'Anonymous Customer') if session_info else 'Anonymous Customer'
        customer_email = session_info.get('customer_email', 'Not provided') if session_info else 'Not provided'
        customer_phone = session_info.get('customer_phone', 'Not provided') if session_info else 'Not provided'
        topic = inquiry_map.get(inquiry_type, 'Not selected yet') if inquiry_type else 'Not selected yet'

        # Create email subject
        subject = f"ðŸ”” New Customer Support Request - {topic}"

        # Create HTML email body
        html_body = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px 10px 0 0; }}
                .header h1 {{ margin: 0; font-size: 24px; }}
                .content {{ background: #f9f9f9; padding: 20px; border-radius: 0 0 10px 10px; }}
                .info-row {{ margin: 10px 0; padding: 10px; background: white; border-radius: 5px; }}
                .label {{ font-weight: bold; color: #667eea; }}
                .message-box {{ background: white; padding: 15px; border-left: 4px solid #667eea; margin-top: 15px; border-radius: 5px; }}
                .footer {{ margin-top: 20px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 12px; color: #999; text-align: center; }}
                .btn {{ display: inline-block; padding: 12px 24px; background: #667eea; color: white; text-decoration: none; border-radius: 5px; margin-top: 15px; }}
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>ðŸ”” New Customer Support Request</h1>
                </div>
                <div class="content">
                    <div class="info-row">
                        <span class="label">Customer Name:</span> {customer_name}
                    </div>
                    <div class="info-row">
                        <span class="label">Email:</span> {customer_email}
                    </div>
                    <div class="info-row">
                        <span class="label">Phone:</span> {customer_phone}
                    </div>
                    <div class="info-row">
                        <span class="label">Inquiry Topic:</span> {topic}
                    </div>
                    <div class="message-box">
                        <strong>Message:</strong><br><br>
                        {message_text}
                    </div>
                    <a href="https://deciph.ai.deciphersacad.online/support-dashboard" class="btn">
                        Go to Support Dashboard
                    </a>
                </div>
                <div class="footer">
                    This is an automated notification from Decipher Academy Support System.<br>
                    Please respond to the customer through the support dashboard.
                </div>
            </div>
        </body>
        </html>
        """

        # Create plain text version
        text_body = f"""
        New Customer Support Request

        Customer Name: {customer_name}
        Email: {customer_email}
        Phone: {customer_phone}
        Inquiry Topic: {topic}

        Message:
        {message_text}

        Please respond to the customer through the support dashboard at:
        https://deciph.ai.deciphersacad.online/support-dashboard
        """

        # Send email
        msg = MailMessage(
            subject=subject,
            sender=app.config['MAIL_DEFAULT_SENDER'],
            recipients=['decipheracad140@gmail.com'],
            body=text_body,
            html=html_body
        )

        mail.send(msg)
        logger.info(f"Email notification sent successfully to decipheracad140@gmail.com")
        return True

    except Exception as e:
        logger.error(f"Failed to send email notification: {str(e)}")
        return False


@app.route('/api/support-chat/send-message', methods=['POST'])
def send_support_message():
    """
    Customer sends a message to support.
    Creates or updates a chat session and sends AI welcome or acknowledgment.
    """
    try:
        data = request.get_json()

        # Extract message data
        session_id = data.get('session_id')
        message_text = data.get('message')
        customer_name = data.get('customer_name')
        customer_email = data.get('customer_email')
        customer_phone = data.get('customer_phone')

        # Validate required fields
        if not message_text:
            return jsonify({'error': 'Message text is required'}), 400

        # Find or create session
        if session_id:
            session = SupportChatSession.query.filter_by(session_id=session_id).first()
        else:
            session = None

        is_new_session = session is None
        ai_response = None

        if not session:
            # Create new session
            session_id = str(uuid.uuid4())
            session = SupportChatSession(
                session_id=session_id,
                customer_name=customer_name,
                customer_email=customer_email,
                customer_phone=customer_phone,
                status='active'
            )
            db.session.add(session)
            db.session.flush()

            # Send AI welcome message
            ai_response = generate_ai_welcome_message()
        else:
            # Update session info if provided
            if customer_name:
                session.customer_name = customer_name
            if customer_email:
                session.customer_email = customer_email
            if customer_phone:
                session.customer_phone = customer_phone
            session.last_message_at = datetime.utcnow()

        # Create customer message
        chat_message = SupportChatMessage(
            session_id=session.id,
            message_text=message_text,
            sender_type='customer',
            sender_name=customer_name or 'Customer'
        )
        db.session.add(chat_message)

        # Check if this is an inquiry type selection (1-7)
        inquiry_map = {
            '1': 'Enrollment & Registration',
            '2': 'Course Information & Curriculum',
            '3': 'Payment & Billing',
            '4': 'Technical Support',
            '5': 'Tutoring Services',
            '6': 'Certificates & Progress',
            '7': 'Other Inquiries'
        }

        # If message is a number 1-7 and session doesn't have inquiry type yet
        if message_text.strip() in inquiry_map and not session.inquiry_type:
            session.inquiry_type = message_text.strip()
            session.inquiry_topic = inquiry_map[message_text.strip()]

            # Send AI acknowledgment
            ai_response = generate_ai_acknowledgment(message_text.strip())

            # Send notifications to support team now
            session_info = {
                'customer_name': session.customer_name,
                'customer_email': session.customer_email,
                'customer_phone': session.customer_phone
            }
            send_whatsapp_notification(message_text, session_info, message_text.strip())
            send_email_notification(message_text, session_info, message_text.strip())

        # Create AI response message if applicable
        ai_message = None
        if ai_response:
            ai_message = SupportChatMessage(
                session_id=session.id,
                message_text=ai_response,
                sender_type='support',
                sender_name='Decipher Support Bot',
                is_system_message=True
            )
            db.session.add(ai_message)

        db.session.commit()

        response_data = {
            'success': True,
            'session_id': session.session_id,
            'message': chat_message.to_dict(),
            'is_new_session': is_new_session
        }

        if ai_message:
            response_data['ai_response'] = ai_message.to_dict()

        return jsonify(response_data), 200

    except Exception as e:
        db.session.rollback()
        logger.error(f"Send support message error: {str(e)}")
        return jsonify({'error': 'Failed to send message'}), 500


@app.route('/api/support-chat/get-messages', methods=['GET'])
def get_support_messages():
    """
    Get all messages for a customer's chat session
    """
    try:
        session_id = request.args.get('session_id')

        if not session_id:
            return jsonify({'error': 'Session ID is required'}), 400

        # Find session
        session = SupportChatSession.query.filter_by(session_id=session_id).first()

        if not session:
            return jsonify({'error': 'Session not found'}), 404

        # Get messages
        messages = SupportChatMessage.query.filter_by(
            session_id=session.id
        ).order_by(SupportChatMessage.created_at.asc()).all()

        return jsonify({
            'session': session.to_dict(),
            'messages': [msg.to_dict() for msg in messages]
        }), 200

    except Exception as e:
        logger.error(f"Get support messages error: {str(e)}")
        return jsonify({'error': 'Failed to retrieve messages'}), 500


@app.route('/api/admin/support-chats', methods=['GET'])
@admin_required
def get_admin_support_chats():
    """
    Get all support chat sessions for admin dashboard
    Requires admin authentication
    """
    try:
        current_user = request.current_admin

        # Get filter parameters
        status = request.args.get('status', 'active')
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 20))

        # Build query
        query = SupportChatSession.query

        if status and status != 'all':
            query = query.filter_by(status=status)

        # Order by last message (most recent first)
        query = query.order_by(SupportChatSession.last_message_at.desc())

        # Paginate
        pagination = query.paginate(page=page, per_page=per_page, error_out=False)

        sessions = [session.to_dict() for session in pagination.items]

        # Add time_ago to each session
        for session_dict in sessions:
            session_obj = SupportChatSession.query.get(session_dict['id'])
            session_dict['time_ago'] = session_obj.get_time_ago()

        return jsonify({
            'sessions': sessions,
            'total': pagination.total,
            'pages': pagination.pages,
            'current_page': page,
            'per_page': per_page
        }), 200

    except Exception as e:
        logger.error(f"Get admin support chats error: {str(e)}")
        return jsonify({'error': 'Failed to load support chats'}), 500


@app.route('/api/admin/support-chat/<session_id>', methods=['GET'])
@admin_required
def get_admin_support_chat_messages(session_id):
    """
    Get messages for a specific support chat session
    Requires admin authentication
    """
    try:
        current_user = request.current_admin

        # Find session
        session = SupportChatSession.query.filter_by(session_id=session_id).first()

        if not session:
            return jsonify({'error': 'Session not found'}), 404

        # Get messages
        messages = SupportChatMessage.query.filter_by(
            session_id=session.id
        ).order_by(SupportChatMessage.created_at.asc()).all()

        # Mark customer messages as read
        for msg in messages:
            if msg.sender_type == 'customer' and not msg.is_read:
                msg.mark_as_read()

        return jsonify({
            'session': session.to_dict(),
            'messages': [msg.to_dict() for msg in messages]
        }), 200

    except Exception as e:
        logger.error(f"Get admin support chat messages error: {str(e)}")
        return jsonify({'error': 'Failed to load messages'}), 500


@app.route('/api/admin/support-chat/reply', methods=['POST'])
@admin_required
def admin_reply_support_chat():
    """
    Admin sends a reply to a customer support chat
    Requires admin authentication
    """
    try:
        current_user = request.current_admin

        data = request.get_json()

        # Extract data
        session_id = data.get('session_id')
        message_text = data.get('message')

        # Validate required fields
        if not session_id or not message_text:
            return jsonify({'error': 'Session ID and message are required'}), 400

        # Find session
        session = SupportChatSession.query.filter_by(session_id=session_id).first()

        if not session:
            return jsonify({'error': 'Session not found'}), 404

        # Create message
        chat_message = SupportChatMessage(
            session_id=session.id,
            message_text=message_text,
            sender_type='support',
            sender_name=current_user.name,
            support_agent_id=current_user.id
        )
        db.session.add(chat_message)

        # Update session
        session.last_message_at = datetime.utcnow()
        if not session.assigned_to_id:
            session.assigned_to_id = current_user.id

        db.session.commit()

        return jsonify({
            'success': True,
            'message': chat_message.to_dict()
        }), 200

    except Exception as e:
        db.session.rollback()
        logger.error(f"Admin reply support chat error: {str(e)}")
        return jsonify({'error': 'Failed to send reply'}), 500


@app.route('/api/admin/support-chat/update-status', methods=['POST'])
@admin_required
def update_support_chat_status():
    """
    Update status of a support chat session (active, closed, waiting)
    Requires admin authentication
    """
    try:
        current_user = request.current_admin

        data = request.get_json()

        # Extract data
        session_id = data.get('session_id')
        status = data.get('status')

        # Validate required fields
        if not session_id or not status:
            return jsonify({'error': 'Session ID and status are required'}), 400

        if status not in ['active', 'closed', 'waiting']:
            return jsonify({'error': 'Invalid status'}), 400

        # Find session
        session = SupportChatSession.query.filter_by(session_id=session_id).first()

        if not session:
            return jsonify({'error': 'Session not found'}), 404

        # Update status
        session.status = status
        if status == 'closed':
            session.closed_at = datetime.utcnow()

        db.session.commit()

        return jsonify({
            'success': True,
            'session': session.to_dict()
        }), 200

    except Exception as e:
        db.session.rollback()
        logger.error(f"Update support chat status error: {str(e)}")
        return jsonify({'error': 'Failed to update status'}), 500


@app.route('/api/admin/support-chat/stats', methods=['GET'])
@admin_required
def get_support_chat_stats():
    """
    Get statistics for support chat dashboard
    Requires admin authentication
    """
    try:
        current_user = request.current_admin

        # Count active chats
        active_count = SupportChatSession.query.filter_by(status='active').count()

        # Count total chats
        total_count = SupportChatSession.query.count()

        # Count unread messages (customer messages not read by admin)
        unread_count = SupportChatMessage.query.filter_by(
            sender_type='customer',
            is_read=False
        ).count()

        # Count chats assigned to current admin
        assigned_count = SupportChatSession.query.filter_by(
            assigned_to_id=current_user.id,
            status='active'
        ).count()

        return jsonify({
            'active_chats': active_count,
            'total_chats': total_count,
            'unread_messages': unread_count,
            'assigned_to_me': assigned_count
        }), 200

    except Exception as e:
        logger.error(f"Get support chat stats error: {str(e)}")
        return jsonify({'error': 'Failed to load statistics'}), 500


@app.route('/api/generate-subtopic-suggestions', methods=['POST'])
@token_required
def generate_subtopic_suggestions(current_user):
    """
    Generate subtopic suggestions for a lesson plan topic.
    This endpoint uses Claude to generate contextually relevant subtopic suggestions.
    """
    try:
        data = request.get_json()
        
        # Extract required data
        topic = data.get('topic', '')
        grade_level = data.get('grade_level', '')
        subject = data.get('subject', '')
        prompt = data.get('prompt', '')
        
        # Validate required fields
        if not topic:
            return jsonify({'error': 'Topic is required'}), 400
        
        # Log the request
        logger.debug(f"Generating subtopic suggestions for topic: {topic}")
        
        # Call Claude API to generate content
        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=200,
                temperature=0.7,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            # Extract the response text
            suggestions = response.content[0].text.strip()
            logger.info(f"Generated subtopic suggestions for {topic}")
            
            return jsonify({
                'suggestions': suggestions,
                'topic': topic
            }), 200
            
        except Exception as claude_error:
            logger.error(f"Claude API error: {str(claude_error)}")
            
            # Provide fallback suggestions based on topic and subject
            fallback_suggestions = generate_fallback_suggestions(topic, subject, grade_level)
            
            return jsonify({
                'suggestions': fallback_suggestions,
                'topic': topic,
                'note': 'These are fallback suggestions due to API error'
            }), 200
            
    except Exception as e:
        logger.error(f"Subtopic suggestions error: {str(e)}")
        return jsonify({'error': str(e)}), 500


    # Convert subject to lowercase for matching
    subject_lower = subject.lower() if subject else ""
    
    # Find matching templates or use default
    templates = default_templates
    for key, value in subject_templates.items():
        if key in subject_lower:
            templates = value
            break
    
    # Join with the pipe character as expected by the frontend
    return "|".join(templates)

# Add this endpoint to your Flask app for generating additional content

@app.route('/api/generate-additional-content', methods=['POST'])
@token_required
def generate_additional_content(current_user):
    try:
        data = request.get_json()
        
        # Extract data from request
        prompt = data.get('prompt', '')
        content_type = data.get('content_type', '')
        topic = data.get('topic', '')
        subject = data.get('subject', '')
        grade_level = data.get('grade_level', '')
        selected_category_index = data.get('selected_category_index', None)
        
        # Validate required fields
        if not prompt:
            return jsonify({'error': 'Missing prompt in request'}), 400
        
        if not content_type in ['subtopic', 'category']:
            return jsonify({'error': 'Invalid content type'}), 400
            
        try:
            # Generate content with Claude API
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=2000,
                temperature=0.7,
                messages=[{"role": "user", "content": prompt}]
            )
            
            generated_content = response.content[0].text
            logger.info(f"Generated additional {content_type} content: {len(generated_content)} characters")
            
            # Process and format the content based on type
            if content_type == 'subtopic':
                # Make sure output has proper formatting
                if 'SUBTOPIC:' not in generated_content:
                    generated_content = 'SUBTOPIC:\n' + generated_content
                
                if 'CATEGORY:' not in generated_content:
                    # Extract a potential category title
                    category_title_match = re.search(r'\*\*(.*?)\*\*', generated_content)
                    category_title = category_title_match.group(1) if category_title_match else "Additional Information"
                    
                    # Add category marker
                    if "SUBTOPIC:" in generated_content:
                        subtopic_parts = generated_content.split("SUBTOPIC:", 1)
                        generated_content = "SUBTOPIC:" + subtopic_parts[1] + "\n\nCATEGORY:\n**" + category_title + "**\n"
            
            # Return the generated content
            return jsonify({
                'message': 'Additional content generated successfully',
                'content': generated_content,
                'content_type': content_type,
                'selected_category_index': selected_category_index
            }), 200
            
        except Exception as claude_error:
            logger.error(f"Claude API error: {str(claude_error)}")
            return jsonify({'error': f'Failed to generate additional content: {str(claude_error)}'}), 500
        
    except Exception as e:
        logger.error(f"Additional content generation error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/generate-example-steps', methods=['POST'])
@token_required
def generate_example_steps(current_user):
    try:
        data = request.get_json()
        example_text = data.get('example_text', '')
        topic = data.get('topic', '')
        
        prompt = f"""
Analyze this mathematical example and create a detailed step-by-step solution:

Example: {example_text}
Topic: {topic}

Generate a step-by-step solution showing the complete mathematical process. Each step should have:
1. A clear description of what's being done
2. The actual mathematical work
3. The result of that step

Format as JSON:
{{
  "steps": [
    {{
      "description": "What we're doing in this step",
      "work": "The actual mathematical calculations and reasoning", 
      "answer": "The result of this step"
    }}
  ]
}}

Make the steps realistic and based on the actual mathematical content in the example.
"""

        response = anthropic_client.messages.create(
            model="claude-3-haiku-20240307",
            max_tokens=2000,
            temperature=0.3,
            messages=[{"role": "user", "content": prompt}]
        )
        
        content = response.content[0].text.strip()
        
        # Clean JSON response
        if content.startswith('```json'):
            content = content[7:]
        if content.endswith('```'):
            content = content[:-3]
        
        try:
            step_data = json.loads(content.strip())
            return jsonify(step_data), 200
        except:
            return jsonify({
                "steps": [
                    {
                        "description": "Solution analysis",
                        "work": example_text,
                        "answer": "Mathematical solution"
                    }
                ]
            }), 200
            
    except Exception as e:
        logger.error(f"Error generating example steps: {str(e)}")
        return jsonify({'error': str(e)}), 500
    
# Evaluation Submission and Feedback
@app.route('/api/submit-evaluation', methods=['POST'])
@token_required
def submit_evaluation(current_user):
    try:
        data = request.get_json()
        evaluation_id = data.get('evaluation_id')
        answers = data.get('answers', {})
        
        # Get evaluation
        evaluation = LessonPlanEvaluation.query.get(evaluation_id)
        if not evaluation:
            return jsonify({'error': 'Evaluation not found'}), 404
        
        questions = json.loads(evaluation.questions_json)['questions']
        
        # Score and provide feedback
        score, feedback = score_evaluation(questions, answers)
        
        # Save attempt
        attempt = StudentEvaluationAttempt(
            evaluation_id=evaluation_id,
            user_id=current_user.id,
            answers_json=json.dumps(answers),
            score=score,
            feedback_json=json.dumps(feedback)
        )
        
        db.session.add(attempt)
        db.session.commit()
        
        return jsonify({
            'score': score,
            'feedback': feedback,
            'attempt_id': attempt.id
        }), 200
        
    except Exception as e:
        logger.error(f"Error submitting evaluation: {str(e)}")
        return jsonify({'error': str(e)}), 500


def score_evaluation(questions, answers):
    """Score evaluation and provide AI-powered feedback"""
    total_questions = len(questions)
    correct_answers = 0
    feedback = {}
    
    for question in questions:
        q_id = question['id']
        q_type = question['type']
        user_answer = answers.get(q_id)
        
        if q_type == 'multiple_choice':
            correct_option = next((opt for opt in question['options'] if opt['correct']), None)
            if user_answer == correct_option['text']:
                correct_answers += 1
                feedback[q_id] = {
                    'correct': True,
                    'explanation': correct_option['explanation']
                }
            else:
                # Find user's selected option for explanation
                selected_option = next((opt for opt in question['options'] if opt['text'] == user_answer), None)
                feedback[q_id] = {
                    'correct': False,
                    'explanation': selected_option['explanation'] if selected_option else 'Incorrect answer',
                    'correct_answer': correct_option['text']
                }
                
        elif q_type == 'drag_drop_matching':
            user_pairs = user_answer if isinstance(user_answer, dict) else {}
            correct_pairs = {pair['term']: pair['definition'] for pair in question['pairs']}
            
            correct_matches = sum(1 for term, definition in user_pairs.items() 
                                if correct_pairs.get(term) == definition)
            
            if correct_matches == len(correct_pairs):
                correct_answers += 1
                feedback[q_id] = {'correct': True, 'explanation': 'All matches are correct!'}
            else:
                feedback[q_id] = {
                    'correct': False,
                    'explanation': f'You got {correct_matches}/{len(correct_pairs)} matches correct',
                    'correct_pairs': correct_pairs
                }
                
        elif q_type == 'drag_drop_ordering':
            user_order = user_answer if isinstance(user_answer, list) else []
            correct_order = sorted(question['items'], key=lambda x: x['order'])
            correct_steps = [item['step'] for item in correct_order]
            
            if user_order == correct_steps:
                correct_answers += 1
                feedback[q_id] = {'correct': True, 'explanation': 'Perfect ordering!'}
            else:
                feedback[q_id] = {
                    'correct': False,
                    'explanation': 'The order is incorrect',
                    'correct_order': correct_steps
                }
                
        elif q_type == 'paragraph':
            # Use AI to evaluate paragraph response
            ai_feedback = evaluate_paragraph_response(question, user_answer)
            feedback[q_id] = ai_feedback
            if ai_feedback.get('score', 0) >= 0.7:  # 70% threshold
                correct_answers += 1
    
    score = (correct_answers / total_questions) * 100
    return score, feedback


def evaluate_paragraph_response(question, user_answer):
    """Use AI to evaluate paragraph responses"""
    if not user_answer or len(user_answer.strip()) < 10:
        return {
            'correct': False,
            'score': 0,
            'explanation': 'Response is too short or missing',
            'suggestions': 'Please provide a more detailed explanation'
        }
    
    prompt = f"""
Evaluate this student's response to a math question:

Question: {question['question']}
Sample Answer: {question['sample_answer']}
Rubric: {question['rubric']}

Student Response: {user_answer}

Provide evaluation as JSON:
{{
  "score": 0.0-1.0,
  "correct": true/false,
  "explanation": "Brief feedback",
  "suggestions": "Specific improvement suggestions",
  "strengths": "What the student did well",
  "areas_for_improvement": "What needs work"
}}
"""

    try:
        response = anthropic_client.messages.create(
            model="claude-3-haiku-20240307",
            max_tokens=1000,
            temperature=0.3,
            messages=[{"role": "user", "content": prompt}]
        )
        
        content = response.content[0].text.strip()
        if content.startswith('```json'):
            content = content[7:]
        if content.endswith('```'):
            content = content[:-3]
            
        return json.loads(content.strip())
        
    except Exception as e:
        logger.error(f"Error evaluating paragraph: {str(e)}")
        return {
            'score': 0.5,
            'correct': True,
            'explanation': 'Response received and recorded',
            'suggestions': 'Keep practicing mathematical explanations'
        }

@app.route('/api/generate-more-examples', methods=['POST'])
@token_required
def generate_more_examples(current_user):
    """Generate additional examples for existing lesson plan"""
    try:
        data = request.get_json()
        subject = data.get('subject', 'mathematics')
        topic = data.get('topic', '')
        count = data.get('count', 3)
        
        if not topic:
            return jsonify({'error': 'Topic is required'}), 400
        
        # Build prompt for additional examples
        prompt = f"""
Generate {count} additional worked examples for {topic} in {subject}.

Each example should include:
1. A clear problem statement with specific numbers
2. Step-by-step solution showing all work
3. Final answer with proper units/notation
4. Brief explanation of the method used

Make examples progressively more challenging and cover different aspects of {topic}.
Use proper mathematical notation with symbols like x^2, Ï€, Â±, etc.

Format each example as:
Example N: [Problem statement]
Solution: [Step-by-step work]
Answer: [Final result]
"""
        
        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=2000,
                temperature=0.7,
                messages=[{"role": "user", "content": prompt}]
            )
            
            content = response.content[0].text
            examples = extract_worked_examples(content)
            
            return jsonify({
                'message': 'Additional examples generated successfully',
                'examples': examples
            }), 200
            
        except Exception as claude_error:
            logger.error(f"Claude API error: {str(claude_error)}")
            return jsonify({'error': 'Failed to generate additional examples'}), 500
        
    except Exception as e:
        logger.error(f"Additional examples generation error: {str(e)}")
        return jsonify({'error': str(e)}), 500

# Helper function for grade level text (if not already exists)
def get_grade_level_text(grade_level):
    """Convert grade level code to readable text"""
    grade_level_map = {
        'elementary-lower': 'Elementary School (Grades 1-2)',
        'elementary-upper': 'Elementary School (Grades 3-5)', 
        'middle': 'Middle School (Grades 6-8)',
        'high': 'High School (Grades 9-12)',
        'college': 'College/University Level'
    }
    return grade_level_map.get(grade_level, grade_level)


@app.route('/favicon.ico')
def favicon():
    """Serve favicon"""
    return send_from_directory(os.path.join(app.root_path, 'static', 'img'),
                             'favicon.svg', mimetype='image/svg+xml')

@app.route('/portfolio/<portfolio_link>')
def view_public_portfolio(portfolio_link):
    """Serve public portfolio view page"""
    # For now, we'll create a simple HTML page that loads the portfolio via API
    # In production, you might want to serve a dedicated React component or static page
    return render_template_string('''
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio - ULAUNCH</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.ico">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .portfolio-header {
            background: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
        }

        .profile-picture {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 20px;
            border: 5px solid #667eea;
        }

        .portfolio-header h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .portfolio-header p {
            color: #666;
            margin-bottom: 5px;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
        }

        .stat {
            text-align: center;
        }

        .stat strong {
            display: block;
            font-size: 24px;
            color: #667eea;
        }

        .stat span {
            font-size: 14px;
            color: #666;
        }

        .section {
            background: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
        }

        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }

        .item-card {
            border: 1px solid #e0e0e0;
            padding: 20px;
            border-radius: 8px;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .item-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .item-card h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .item-card p {
            color: #666;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .tech-tag {
            background: #e7f5ff;
            color: #1971c2;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            display: inline-block;
            margin: 5px 5px 5px 0;
        }

        .featured-badge {
            background: #ffd43b;
            color: #333;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }

        .btn-link {
            display: inline-block;
            margin-top: 10px;
            padding: 8px 16px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 14px;
        }

        .btn-link:hover {
            background: #5568d3;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: white;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .empty-message {
            text-align: center;
            color: #999;
            padding: 40px;
            font-style: italic;
        }

        .rating {
            color: #ffd43b;
            font-size: 18px;
        }

        @media (max-width: 768px) {
            .items-grid {
                grid-template-columns: 1fr;
            }
            .stats {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <p>Loading portfolio...</p>
        </div>
        <div id="portfolio-content" style="display: none;"></div>
        <div id="error-content" style="display: none; text-align: center; color: white; padding: 40px;">
            <h2>Portfolio Not Found</h2>
            <p>This portfolio link is invalid or has been removed.</p>
        </div>
    </div>

    <script>
        const portfolioLink = '{{ portfolio_link }}';

        async function loadPortfolio() {
            try {
                const response = await fetch(`https://deciph.ai.deciphersacad.online/api/student/portfolio/view/${portfolioLink}`);

                if (!response.ok) {
                    throw new Error('Portfolio not found');
                }

                const data = await response.json();
                displayPortfolio(data);
            } catch (error) {
                console.error('Error loading portfolio:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error-content').style.display = 'block';
            }
        }

        function displayPortfolio(data) {
            const student = data.student;
            const portfolioItems = data.portfolio_items || {};
            const projects = data.projects || {};
            const reviews = data.reviews || [];

            let html = `
                <div class="portfolio-header">
                    <img src="${student.profile_picture_url || 'https://via.placeholder.com/150?text=No+Photo'}"
                         alt="${student.name}" class="profile-picture">
                    <h1>${student.name}</h1>
                    <p>@${student.username || 'student'}</p>
                    ${student.bio ? `<p style="margin-top: 15px; color: #555;">${student.bio}</p>` : ''}
                    ${student.workshop ? `<p style="margin-top: 10px;"><strong>Workshop:</strong> ${student.workshop}</p>` : ''}
                    <div class="stats">
                        <div class="stat">
                            <strong>${student.total_points || 0}</strong>
                            <span>Points</span>
                        </div>
                        <div class="stat">
                            <strong>Level ${student.current_level || 1}</strong>
                            <span>Current Level</span>
                        </div>
                        ${data.completed_tasks_count ? `
                        <div class="stat">
                            <strong>${data.completed_tasks_count}</strong>
                            <span>Tasks Completed</span>
                        </div>
                        ` : ''}
                    </div>
                </div>
            `;

            // Certificates
            if (portfolioItems.certificates && portfolioItems.certificates.length > 0) {
                html += renderSection('ðŸ“œ Certificates', portfolioItems.certificates, 'certificate');
            }

            // Awards
            if (portfolioItems.awards && portfolioItems.awards.length > 0) {
                html += renderSection('ðŸ† Awards', portfolioItems.awards, 'award');
            }

            // Achievements
            if (portfolioItems.achievements && portfolioItems.achievements.length > 0) {
                html += renderSection('â­ Achievements', portfolioItems.achievements, 'achievement');
            }

            // Projects
            const allProjects = [
                ...(projects.top_projects || []),
                ...(projects.in_class_projects || []),
                ...(projects.personal_projects || [])
            ];
            if (allProjects.length > 0) {
                html += renderProjectsSection('ðŸ’» Projects', allProjects);
            }

            // Reviews
            if (reviews.length > 0) {
                html += renderReviewsSection('ðŸ’¬ Reviews & Testimonials', reviews);
            }

            document.getElementById('loading').style.display = 'none';
            document.getElementById('portfolio-content').style.display = 'block';
            document.getElementById('portfolio-content').innerHTML = html;
        }

        function renderSection(title, items, type) {
            let html = `<div class="section"><h2>${title}</h2><div class="items-grid">`;

            items.forEach(item => {
                html += `
                    <div class="item-card">
                        <h3>${item.title}</h3>
                        ${item.issuer ? `<p><strong>Issued by:</strong> ${item.issuer}</p>` : ''}
                        ${item.issue_date ? `<p><strong>Date:</strong> ${new Date(item.issue_date).toLocaleDateString()}</p>` : ''}
                        ${item.description ? `<p style="margin-top: 10px;">${item.description}</p>` : ''}
                        ${item.file_url ? `<a href="${item.file_url}" target="_blank" class="btn-link">View File</a>` : ''}
                    </div>
                `;
            });

            html += '</div></div>';
            return html;
        }

        function renderProjectsSection(title, projects) {
            let html = `<div class="section"><h2>${title}</h2><div class="items-grid">`;

            projects.forEach(project => {
                html += `
                    <div class="item-card">
                        ${project.is_featured ? '<span class="featured-badge">â­ Featured</span>' : ''}
                        <h3 style="margin-top: 10px;">${project.title}</h3>
                        ${project.description ? `<p style="margin: 10px 0;">${project.description}</p>` : ''}
                        ${project.technologies && project.technologies.length > 0 ? `
                            <div style="margin: 10px 0;">
                                ${project.technologies.map(tech => `<span class="tech-tag">${tech}</span>`).join('')}
                            </div>
                        ` : ''}
                        <div style="margin-top: 10px;">
                            ${project.project_url ? `<a href="${project.project_url}" target="_blank" class="btn-link">View Project</a>` : ''}
                            ${project.github_url ? `<a href="${project.github_url}" target="_blank" class="btn-link" style="background: #333; margin-left: 10px;">GitHub</a>` : ''}
                        </div>
                    </div>
                `;
            });

            html += '</div></div>';
            return html;
        }

        function renderReviewsSection(title, reviews) {
            let html = `<div class="section"><h2>${title}</h2><div class="items-grid">`;

            reviews.forEach(review => {
                html += `
                    <div class="item-card">
                        <h3>${review.reviewer_name}</h3>
                        ${review.reviewer_title ? `<p>${review.reviewer_title}</p>` : ''}
                        ${review.reviewer_organization ? `<p>${review.reviewer_organization}</p>` : ''}
                        ${review.rating ? `<div class="rating">${'â­'.repeat(review.rating)}</div>` : ''}
                        <p style="margin-top: 15px; font-style: italic;">"${review.review_text}"</p>
                    </div>
                `;
            });

            html += '</div></div>';
            return html;
        }

        // Load portfolio on page load
        loadPortfolio();
    </script>
</body>
</html>
    ''', portfolio_link=portfolio_link)

@app.route('/static/<path:filename>')
def serve_static(filename):
    """Serve static files"""
    return send_from_directory('static', filename)

@app.route('/static/lesson_images/<path:filename>')
def serve_lesson_image_public(filename):
    """Serve lesson plan images - PUBLIC, NO AUTH REQUIRED"""
    try:
        # Use absolute path
        if os.path.exists('/workspace/Decipher'):
            app_root = '/workspace/Decipher'
        else:
            app_root = os.path.dirname(os.path.abspath(__file__))

        images_path = os.path.join(app_root, 'static', 'lesson_images')
        full_path = os.path.join(images_path, filename)

        logger.info(f"ðŸ“¸ Image request: {filename}")
        logger.info(f"ðŸ“‚ Looking in: {images_path}")
        logger.info(f"ðŸ“ Full path: {full_path}")
        logger.info(f"âœ… Exists locally: {os.path.exists(full_path)}")

        # If file exists locally, serve it
        if os.path.exists(full_path):
            response = send_from_directory(
                images_path,
                filename,
                mimetype='image/png',
                as_attachment=False
            )

            # Add cache headers for better performance
            response.headers['Cache-Control'] = 'public, max-age=31536000'  # Cache for 1 year
            response.headers['Access-Control-Allow-Origin'] = '*'  # Allow CORS

            logger.info(f"âœ… Image served successfully from local: {filename}")

            return response

        # If not found locally, try to redirect to S3
        logger.info(f"ðŸŒ Image not found locally, redirecting to S3")
        try:
            # S3 Configuration
            s3_bucket = os.getenv('S3_BUCKET_NAME')
            s3_region = os.getenv('S3_REGION', 'eu-north-1')

            if s3_bucket:
                # Construct S3 URL - the filename might already include 'lesson_images/' prefix or not
                s3_key = f"lesson_images/{filename}" if not filename.startswith('lesson_images/') else filename
                s3_url = f"https://{s3_bucket}.s3.{s3_region}.amazonaws.com/{s3_key}"

                logger.info(f"ðŸ”— Redirecting to S3: {s3_url}")

                # Redirect to S3 URL
                return redirect(s3_url, code=302)
            else:
                logger.error(f"âŒ S3 bucket not configured and image not found locally")
                return jsonify({'error': 'Image not found'}), 404

        except Exception as s3_error:
            logger.error(f"âŒ S3 redirect error: {str(s3_error)}")
            return jsonify({'error': 'Image not found'}), 404

    except Exception as e:
        logger.error(f"âŒ Error serving image {filename}: {str(e)}", exc_info=True)
        return jsonify({'error': str(e)}), 500


@app.route('/api/generate-htw-section', methods=['POST'])
def generate_htw_section():
    """Generate How Things Work section content using AI"""
    try:
        data = request.get_json()
        topic = data.get('topic', '')
        context = data.get('context', '')

        if not topic:
            return jsonify({"error": "Topic is required"}), 400

        prompt = f"""Generate educational content explaining how {topic} works.
Context: {context}
Provide the response in the following format:
1. Simple Explanation: (2-3 sentences for a child)
2. Technical Explanation: (detailed explanation with scientific concepts)
3. Real-World Example: (practical example from everyday life)
Keep it educational, accurate, and engaging."""

        response = co.chat(
            message=prompt,
            model="command"
        )

        return jsonify({"content": response.text}), 200

    except Exception as e:
        logger.error(f"Error generating HTW section: {str(e)}")
        return jsonify({"error": f"Failed to generate content: {str(e)}"}), 500


@app.route('/api/generate-future-tech-section', methods=['POST'])
def generate_future_tech_section():
    """Generate Future Technology section content using AI"""
    try:
        data = request.get_json()
        topic = data.get('topic', '')
        context = data.get('context', '')

        if not topic:
            return jsonify({"error": "Topic is required"}), 400

        prompt = f"""Describe a future technology related to {topic}.
Context: {context}
Provide the response in the following format:
1. Technology Name: (creative but realistic name)
2. Connection to Lesson: (how it relates to the topic being taught)
3. Potential Impact: (how it could change our lives or solve problems)
Be creative, inspiring, and scientifically plausible."""

        response = co.chat(
            message=prompt,
            model="command"
        )

        return jsonify({"content": response.text}), 200

    except Exception as e:
        logger.error(f"Error generating future tech section: {str(e)}")
        return jsonify({"error": f"Failed to generate content: {str(e)}"}), 500


@app.route('/api/generate-myth-section', methods=['POST'])
def generate_myth_section():
    """Generate Myth vs Reality section content using AI"""
    try:
        data = request.get_json()
        topic = data.get('topic', '')
        context = data.get('context', '')

        if not topic:
            return jsonify({"error": "Topic is required"}), 400

        prompt = f"""Identify and debunk a common myth about {topic}.
Context: {context}
Provide the response in the following format:
1. The Myth: (common misconception)
2. The Reality: (scientific truth)
3. Why People Believe It: (psychological or historical reason)
Be educational, accurate, and respectful."""

        response = co.chat(
            message=prompt,
            model="command"
        )

        return jsonify({"content": response.text}), 200

    except Exception as e:
        logger.error(f"Error generating myth section: {str(e)}")
        return jsonify({"error": f"Failed to generate content: {str(e)}"}), 500


@app.route('/api/generate-puzzle-section', methods=['POST'])
def generate_puzzle_section():
    """Generate Puzzle section content using AI"""
    try:
        data = request.get_json()
        topic = data.get('topic', '')
        context = data.get('context', '')
        difficulty = data.get('difficulty', 'medium')

        if not topic:
            return jsonify({"error": "Topic is required"}), 400

        prompt = f"""Create an educational puzzle related to {topic}.
Context: {context}
Difficulty: {difficulty}
Provide the response in the following format:
1. Puzzle Question: (engaging question or riddle)
2. Hint: (helpful clue without giving away the answer)
3. Solution: (complete answer with explanation)
Make it challenging but solvable for students."""

        response = co.chat(
            message=prompt,
            model="command"
        )

        return jsonify({"content": response.text}), 200

    except Exception as e:
        logger.error(f"Error generating puzzle section: {str(e)}")
        return jsonify({"error": f"Failed to generate content: {str(e)}"}), 500


@app.route('/api/generate-meme-section', methods=['POST'])
def generate_meme_section():
    """Generate Meme section content using AI"""
    try:
        data = request.get_json()
        topic = data.get('topic', '')
        context = data.get('context', '')

        if not topic:
            return jsonify({"error": "Topic is required"}), 400

        prompt = f"""Create an educational meme concept about {topic}.
Context: {context}
Provide the response in the following format:
1. Meme Concept: (funny, relatable scenario related to the topic)
2. Educational Connection: (how it teaches the concept)
3. Suggested Format: (popular meme template that would work)
Keep it funny, appropriate for students, and educational."""

        response = co.chat(
            message=prompt,
            model="command"
        )

        return jsonify({"content": response.text}), 200

    except Exception as e:
        logger.error(f"Error generating meme section: {str(e)}")
        return jsonify({"error": f"Failed to generate content: {str(e)}"}), 500


@app.route('/api/generate-story-section', methods=['POST'])
def generate_story_section():
    """Generate Story section content using AI"""
    try:
        data = request.get_json()
        topic = data.get('topic', '')
        context = data.get('context', '')
        age_group = data.get('age_group', 'elementary')

        if not topic:
            return jsonify({"error": "Topic is required"}), 400

        prompt = f"""Create an educational story about {topic} suitable for {age_group} students.
Context: {context}
Provide the response in the following format:
1. Story Title: (engaging title)
2. Story Content: (short story in 3-5 paragraphs, max 100 words per paragraph)
3. Moral/Lesson: (educational takeaway)
4. Author Bio Idea: (suggested author background)
Make it engaging, age-appropriate, and educational."""

        response = co.chat(
            message=prompt,
            model="command"
        )

        return jsonify({"content": response.text}), 200

    except Exception as e:
        logger.error(f"Error generating story section: {str(e)}")
        return jsonify({"error": f"Failed to generate content: {str(e)}"}), 500


@app.route('/api/generate-quiz-from-text', methods=['POST'])
@token_required
def generate_quiz_from_text(current_user):
    """Generate quiz from text content"""
    try:
        data = request.get_json()
        content_text = data.get('content_text', '').strip()
        num_questions = data.get('num_questions', 5)
        title = data.get('title', 'Generated Quiz')
        types = data.get('types', ['multiple_choice'])
        mode = data.get('mode', 'auto')
        
        if not content_text or len(content_text) < 100:
            return jsonify({'error': 'Content text must be at least 100 characters'}), 400
        
        # Generate quiz ID
        quiz_id = str(uuid.uuid4())
        
        # Use AI to generate questions from text
        # (You can use your existing AI quiz generation logic here)
        # For now, I'll show the structure
        
        quiz_data = {
            'id': quiz_id,
            'title': title,
            'mode': mode,
            'time_limit': 30,
            'questions': []  # Populate with AI-generated questions
        }
        
        # Save to database
        new_quiz = QuizModel(
            id=quiz_id,
            user_id=current_user.id,
            title=title,
            quiz_data=json.dumps(quiz_data),
            created_at=datetime.utcnow()
        )
        
        db.session.add(new_quiz)
        db.session.commit()
        
        return jsonify({
            'message': 'Quiz generated successfully',
            'quiz_id': quiz_id,
            'quiz_data': quiz_data
        }), 201
        
    except Exception as e:
        logger.error(f"Error generating quiz from text: {str(e)}")
        db.session.rollback()
        return jsonify({'error': str(e)}), 500
    
@app.route('/api/math-lesson-stats', methods=['GET'])
@token_required
def get_math_lesson_statistics(current_user):
    """Get statistics about user's math lesson plans"""
    try:
        stats = get_math_lesson_stats(current_user.id)
        return jsonify(stats), 200
        
    except Exception as e:
        logger.error(f"Error fetching math lesson stats: {str(e)}")
        return jsonify({'error': str(e)}), 500

# Backend API for Dynamic Step Generation System
import json
import re
import logging
from flask import request, jsonify
from datetime import datetime
import anthropic

# Enhanced API endpoint for dynamic step generation
@app.route('/api/generate-dynamic-steps', methods=['POST'])
@token_required
def generate_dynamic_steps_no_fallback(current_user):
    """
    Generate dynamic step-by-step solutions - no fallbacks, network errors only
    """
    try:
        data = request.get_json()
        
        # Extract request parameters
        problem_text = data.get('problem_text', '')
        topic = data.get('topic', 'mathematics')
        grade_level = data.get('grade_level', 'high')
        subject = data.get('subject', 'mathematics')
        include_verification = data.get('include_verification', True)
        show_intermediate_work = data.get('show_intermediate_work', True)
        
        # Validate required fields
        if not problem_text:
            return jsonify({'error': 'problem_text is required'}), 400
        
        logger.info(f"=== DYNAMIC STEP GENERATION (NO FALLBACK) ===")
        logger.info(f"User: {current_user.id}")
        logger.info(f"Problem: {problem_text[:100]}...")
        logger.info(f"Topic: {topic}")
        logger.info("=============================================")
        
        # Generate dynamic steps using AI - no fallback
        steps = generate_ai_steps_strict(
            problem_text=problem_text,
            topic=topic,
            grade_level=grade_level,
            subject=subject,
            include_verification=include_verification,
            show_intermediate_work=show_intermediate_work
        )
        
        if not steps or len(steps) == 0:
            return jsonify({
                'error': 'No steps could be generated. Please try again.',
                'error_type': 'generation_failed'
            }), 422
        
        # Log successful generation
        logger.info(f"Successfully generated {len(steps)} steps for problem")
        
        return jsonify({
            'steps': steps,
            'metadata': {
                'topic': topic,
                'grade_level': grade_level,
                'generated_at': datetime.utcnow().isoformat(),
                'step_count': len(steps)
            }
        }), 200
        
    except anthropic.APIError as e:
        logger.error(f"Anthropic API error: {str(e)}")
        return jsonify({
            'error': 'AI service temporarily unavailable. Please try again.',
            'error_type': 'ai_service_error'
        }), 503
        
    except anthropic.RateLimitError as e:
        logger.error(f"Rate limit error: {str(e)}")
        return jsonify({
            'error': 'Too many requests. Please wait a moment and try again.',
            'error_type': 'rate_limit'
        }), 429
        
    except Exception as e:
        logger.error(f"Error in dynamic step generation: {str(e)}")
        return jsonify({
            'error': 'Step generation failed. Please check your connection and try again.',
            'error_type': 'network_error'
        }), 500


def generate_ai_steps_strict(problem_text, topic, grade_level, subject, 
                           include_verification=True, show_intermediate_work=True):
    """
    Generate AI steps with strict validation - no fallback generation
    """
    
    # Build enhanced prompt
    prompt = build_strict_step_prompt(
        problem_text, topic, grade_level, subject, 
        include_verification, show_intermediate_work
    )
    
    try:
        response = anthropic_client.messages.create(
            model="claude-3-haiku-20240307",
            max_tokens=4000,
            temperature=0.3,
            messages=[{"role": "user", "content": prompt}]
        )
        
        content = response.content[0].text.strip()
        
        # Parse the AI response into structured steps
        steps = parse_ai_response_strict(content)
        
        if not steps or len(steps) == 0:
            raise ValueError("AI generated empty or invalid step sequence")
        
        # Validate each step has required fields
        validated_steps = validate_steps_strict(steps)
        
        if not validated_steps or len(validated_steps) == 0:
            raise ValueError("Step validation failed - no valid steps produced")
        
        return validated_steps
        
    except anthropic.APIError as e:
        logger.error(f"Anthropic API error in step generation: {str(e)}")
        raise
    except anthropic.RateLimitError as e:
        logger.error(f"Rate limit error in step generation: {str(e)}")
        raise
    except json.JSONDecodeError as e:
        logger.error(f"JSON parsing error in step generation: {str(e)}")
        raise ValueError("Invalid response format from AI service")
    except Exception as e:
        logger.error(f"Unexpected error in AI step generation: {str(e)}")
        raise


def build_strict_step_prompt(problem_text, topic, grade_level, subject, 
                           include_verification, show_intermediate_work):
    """
    Build a strict prompt that demands proper JSON structure
    """
    
    prompt = f"""
Generate a detailed step-by-step solution for this {subject} problem:

PROBLEM: {problem_text}
TOPIC: {topic}
GRADE LEVEL: {grade_level}

CRITICAL REQUIREMENTS:
1. Generate exactly 3-5 clear, logical steps
2. Each step MUST have ALL required fields
3. Mathematical work must be detailed and accurate
4. Show complete calculations and reasoning

REQUIRED JSON FORMAT (respond ONLY with this JSON structure):
{{
  "steps": [
    {{
      "step_number": 1,
      "description": "Clear explanation of what's being done",
      "work": "Detailed mathematical calculations with line breaks",
      "reasoning": "Why this step is necessary", 
      "result": "The outcome of this step",
      "key_point": "Important mathematical concept (optional)",
      "hints": ["Helpful tip 1", "Helpful tip 2"],
      "common_mistakes": ["Mistake to avoid 1", "Mistake to avoid 2"]
    }}
  ]
}}

MATHEMATICAL WORK REQUIREMENTS:
- Show original equations/expressions
- Display each algebraic manipulation
- Include substitution of values
- Show simplification process
- Use proper mathematical notation

{"VERIFICATION REQUIREMENT: Include verification step" if include_verification else ""}

IMPORTANT: Return ONLY valid JSON. No additional text, explanations, or markdown formatting.
"""
    
    return prompt


def parse_ai_response_strict(content):
    """
    Parse AI response with strict validation - no fallback parsing
    """
    try:
        # Clean the response
        cleaned_content = content.strip()
        
        # Remove markdown formatting if present
        if cleaned_content.startswith('```json'):
            cleaned_content = cleaned_content[7:]
        if cleaned_content.endswith('```'):
            cleaned_content = cleaned_content[:-3]
        
        cleaned_content = cleaned_content.strip()
        
        # Parse JSON - this will raise JSONDecodeError if invalid
        response_data = json.loads(cleaned_content)
        
        # Strict validation of structure
        if not isinstance(response_data, dict):
            raise ValueError("Response must be a JSON object")
        
        if 'steps' not in response_data:
            raise ValueError("Response missing required 'steps' field")
        
        steps = response_data['steps']
        if not isinstance(steps, list):
            raise ValueError("'steps' must be an array")
        
        if len(steps) == 0:
            raise ValueError("'steps' array cannot be empty")
        
        return steps
        
    except json.JSONDecodeError as e:
        logger.error(f"JSON decode error: {str(e)}")
        raise ValueError(f"Invalid JSON response: {str(e)}")
    except Exception as e:
        logger.error(f"Response parsing error: {str(e)}")
        raise ValueError(f"Response parsing failed: {str(e)}")


def validate_steps_strict(steps):
    """
    Validate steps with strict requirements - no fallback validation
    """
    validated_steps = []
    required_fields = ['description', 'work', 'reasoning', 'result']
    
    for i, step in enumerate(steps):
        if not isinstance(step, dict):
            raise ValueError(f"Step {i+1} must be an object")
        
        # Check required fields
        missing_fields = []
        for field in required_fields:
            if field not in step or not step[field] or not isinstance(step[field], str):
                missing_fields.append(field)
        
        if missing_fields:
            raise ValueError(f"Step {i+1} missing required fields: {', '.join(missing_fields)}")
        
        # Ensure step has meaningful content
        if len(step['description'].strip()) < 10:
            raise ValueError(f"Step {i+1} description too short")
        
        if len(step['work'].strip()) < 10:
            raise ValueError(f"Step {i+1} mathematical work too short")
        
        # Ensure optional fields have correct types
        validated_step = {
            'step_number': step.get('step_number', i + 1),
            'description': step['description'].strip(),
            'work': step['work'].strip(),
            'reasoning': step['reasoning'].strip(),
            'result': step['result'].strip(),
            'key_point': step.get('key_point', ''),
            'hints': step.get('hints', []) if isinstance(step.get('hints'), list) else [],
            'common_mistakes': step.get('common_mistakes', []) if isinstance(step.get('common_mistakes'), list) else []
        }
        
        validated_steps.append(validated_step)
    
    return validated_steps

class MathematicalProblemAnalyzer:
    """
    Analyzes mathematical problems to determine type, complexity, and approach
    """
    
    def __init__(self):
        self.problem_patterns = {
            'linear_equation': {
                'patterns': [
                    r'\b\d*[a-zA-Z]\s*[+\-]\s*\d+\s*=\s*\d+',
                    r'solve.*[a-zA-Z]\s*=',
                    r'find.*[a-zA-Z].*equation'
                ],
                'keywords': ['solve', 'linear', 'equation', 'variable']
            },
            'quadratic_equation': {
                'patterns': [
                    r'\b\d*[a-zA-Z]\^?2',
                    r'[a-zA-Z]Â²',
                    r'quadratic',
                    r'parabola'
                ],
                'keywords': ['quadratic', 'parabola', 'vertex', 'discriminant']
            },
            'slope_calculation': {
                'patterns': [
                    r'\(\s*-?\d+\s*,\s*-?\d+\s*\)',
                    r'point.*point',
                    r'slope.*formula'
                ],
                'keywords': ['slope', 'point', 'coordinate', 'line']
            },
            'trigonometry': {
                'patterns': [
                    r'\b(sin|cos|tan)\b',
                    r'\b\d+Â°|\d+\s*degrees?',
                    r'triangle.*angle'
                ],
                'keywords': ['sin', 'cos', 'tan', 'angle', 'triangle', 'trigonometry']
            },
            'calculus': {
                'patterns': [
                    r'\bderivative\b',
                    r'\bintegral\b',
                    r'\blimit\b',
                    r'd/dx',
                    r'âˆ«'
                ],
                'keywords': ['derivative', 'integral', 'limit', 'calculus']
            },
            'geometry': {
                'patterns': [
                    r'\barea\b',
                    r'\bperimeter\b',
                    r'\bvolume\b',
                    r'\bradius\b',
                    r'\bdiameter\b'
                ],
                'keywords': ['area', 'perimeter', 'volume', 'geometry', 'shape']
            },
            'statistics': {
                'patterns': [
                    r'\bmean\b',
                    r'\bmedian\b',
                    r'\bmode\b',
                    r'\bstandard deviation\b',
                    r'\bprobability\b'
                ],
                'keywords': ['mean', 'median', 'mode', 'statistics', 'data']
            }
        }
    
    def analyze_problem(self, problem_text, topic, subject):
        """
        Analyze a mathematical problem to determine its characteristics
        """
        problem_type = self.identify_problem_type(problem_text)
        complexity = self.assess_complexity(problem_text, problem_type)
        mathematical_elements = self.extract_mathematical_elements(problem_text)
        solution_approach = self.suggest_solution_approach(problem_type, mathematical_elements)
        
        return {
            'problem_type': problem_type,
            'complexity': complexity,
            'mathematical_elements': mathematical_elements,
            'solution_approach': solution_approach,
            'estimated_steps': self.estimate_step_count(problem_type, complexity),
            'required_concepts': self.identify_required_concepts(problem_type, topic),
            'common_mistakes': self.get_common_mistakes(problem_type),
            'verification_method': self.get_verification_method(problem_type)
        }
    
    def identify_problem_type(self, problem_text):
        """
        Identify the type of mathematical problem
        """
        text_lower = problem_text.lower()
        
        for problem_type, config in self.problem_patterns.items():
            # Check patterns
            for pattern in config['patterns']:
                if re.search(pattern, text_lower):
                    return problem_type
            
            # Check keywords
            keyword_matches = sum(1 for keyword in config['keywords'] if keyword in text_lower)
            if keyword_matches >= 2:  # Require at least 2 keyword matches
                return problem_type
        
        return 'general_mathematics'
    
    def assess_complexity(self, problem_text, problem_type):
        """
        Assess the complexity level of the problem
        """
        complexity_indicators = {
            'simple': 0,
            'moderate': 0,
            'complex': 0
        }
        
        # Count mathematical operations
        operations = len(re.findall(r'[+\-*/Ã·Ã—=]', problem_text))
        if operations <= 2:
            complexity_indicators['simple'] += 2
        elif operations <= 5:
            complexity_indicators['moderate'] += 2
        else:
            complexity_indicators['complex'] += 2
        
        # Check for advanced concepts
        advanced_patterns = [r'\^[2-9]', r'âˆš', r'sin|cos|tan', r'log|ln', r'derivative|integral']
        advanced_count = sum(1 for pattern in advanced_patterns if re.search(pattern, problem_text))
        
        if advanced_count == 0:
            complexity_indicators['simple'] += 1
        elif advanced_count <= 2:
            complexity_indicators['moderate'] += 1
        else:
            complexity_indicators['complex'] += 1
        
        # Word problem complexity
        if len(problem_text.split()) > 50:
            complexity_indicators['complex'] += 1
        elif len(problem_text.split()) > 20:
            complexity_indicators['moderate'] += 1
        else:
            complexity_indicators['simple'] += 1
        
        return max(complexity_indicators, key=complexity_indicators.get)
    
    def extract_mathematical_elements(self, problem_text):
        """
        Extract mathematical elements from the problem
        """
        elements = {
            'numbers': re.findall(r'-?\d+(?:\.\d+)?', problem_text),
            'variables': list(set(re.findall(r'\b[a-zA-Z]\b', problem_text))),
            'equations': re.findall(r'[^=]*=[^=]*', problem_text),
            'operations': re.findall(r'[+\-*/Ã·Ã—]', problem_text),
            'coordinates': re.findall(r'\(\s*-?\d+(?:\.\d+)?\s*,\s*-?\d+(?:\.\d+)?\s*\)', problem_text),
            'functions': re.findall(r'(sin|cos|tan|log|ln|sqrt|exp)\s*\(', problem_text, re.IGNORECASE),
            'units': re.findall(r'\b(?:cm|m|km|ft|in|kg|g|lb|Â°|degrees?)\b', problem_text, re.IGNORECASE)
        }
        
        # Convert string numbers to floats
        elements['numbers'] = [float(n) for n in elements['numbers']]
        
        return elements
    
    def suggest_solution_approach(self, problem_type, elements):
        """
        Suggest the best solution approach based on problem type and elements
        """
        approaches = {
            'linear_equation': 'Isolate the variable using inverse operations',
            'quadratic_equation': 'Use factoring, completing the square, or quadratic formula',
            'slope_calculation': 'Apply the slope formula: m = (yâ‚‚ - yâ‚)/(xâ‚‚ - xâ‚)',
            'trigonometry': 'Use trigonometric ratios and identities',
            'calculus': 'Apply differentiation or integration rules',
            'geometry': 'Use appropriate geometric formulas and theorems',
            'statistics': 'Apply statistical methods and formulas',
            'general_mathematics': 'Analyze the problem and apply relevant mathematical principles'
        }
        
        return approaches.get(problem_type, approaches['general_mathematics'])
    
    def estimate_step_count(self, problem_type, complexity):
        """
        Estimate the number of solution steps needed
        """
        base_steps = {
            'linear_equation': 4,
            'quadratic_equation': 6,
            'slope_calculation': 4,
            'trigonometry': 5,
            'calculus': 6,
            'geometry': 5,
            'statistics': 4,
            'general_mathematics': 4
        }
        
        base = base_steps.get(problem_type, 4)
        
        if complexity == 'simple':
            return max(3, base - 1)
        elif complexity == 'complex':
            return base + 2
        else:
            return base
    
    def identify_required_concepts(self, problem_type, topic):
        """
        Identify key mathematical concepts required for the problem
        """
        concept_map = {
            'linear_equation': ['inverse operations', 'equation solving', 'variable isolation'],
            'quadratic_equation': ['factoring', 'quadratic formula', 'parabolas', 'vertex form'],
            'slope_calculation': ['coordinate geometry', 'rate of change', 'point-slope form'],
            'trigonometry': ['sine, cosine, tangent', 'unit circle', 'angle measurement'],
            'calculus': ['limits', 'derivatives', 'chain rule', 'integration'],
            'geometry': ['area formulas', 'perimeter', 'geometric theorems'],
            'statistics': ['measures of central tendency', 'probability', 'data analysis'],
            'general_mathematics': ['basic operations', 'problem solving', 'mathematical reasoning']
        }
        
        return concept_map.get(problem_type, concept_map['general_mathematics'])
    
    def get_common_mistakes(self, problem_type):
        """
        Get common mistakes for this problem type
        """
        mistakes = {
            'linear_equation': [
                'Forgetting to apply operations to both sides',
                'Sign errors when moving terms',
                'Not simplifying fractions properly'
            ],
            'quadratic_equation': [
                'Forgetting to set equation equal to zero',
                'Arithmetic errors with the discriminant',
                'Not checking for extraneous solutions'
            ],
            'slope_calculation': [
                'Confusing x and y coordinates',
                'Subtracting in wrong order',
                'Division by zero when line is vertical'
            ],
            'trigonometry': [
                'Using wrong trigonometric ratio',
                'Forgetting to convert between degrees and radians',
                'Not considering all possible angles'
            ],
            'general_mathematics': [
                'Rushing through calculations',
                'Not showing all work',
                'Forgetting to check the answer'
            ]
        }
        
        return mistakes.get(problem_type, mistakes['general_mathematics'])
    
    def get_verification_method(self, problem_type):
        """
        Get the appropriate verification method for this problem type
        """
        methods = {
            'linear_equation': 'Substitute solution back into original equation',
            'quadratic_equation': 'Check solutions in original equation',
            'slope_calculation': 'Verify using alternate point pairs',
            'trigonometry': 'Check using inverse functions or identities',
            'calculus': 'Verify derivative using definition or integration',
            'geometry': 'Check units and reasonableness of measurements',
            'statistics': 'Verify calculations and check for outliers',
            'general_mathematics': 'Check reasonableness and verify calculations'
        }
        
        return methods.get(problem_type, methods['general_mathematics'])


class DynamicStepAIGenerator:
    """
    Generates step-by-step solutions using AI with mathematical analysis
    """
    
    def __init__(self):
        anthropic_client = anthropic.Anthropic(api_key=os.getenv('ANTHROPIC_API_KEY'))
    
    async def generate_solution_steps(self, problem_text, topic, grade_level, subject, 
                                    problem_analysis, include_verification=True, 
                                    show_intermediate_work=True):
        """
        Generate dynamic solution steps using AI
        """
        
        # Build enhanced prompt based on problem analysis
        prompt = self.build_enhanced_prompt(
            problem_text, topic, grade_level, subject, 
            problem_analysis, include_verification, show_intermediate_work
        )
        
        try:
            response = self.anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=4000,
                temperature=0.3,  # Lower temperature for mathematical accuracy
                messages=[{"role": "user", "content": prompt}]
            )
            
            content = response.content[0].text
            
            # Parse the AI response into structured steps
            steps = self.parse_ai_response(content, problem_analysis)
            
            # Validate and enhance the steps
            validated_steps = self.validate_and_enhance_steps(steps, problem_analysis)
            
            return validated_steps
            
        except Exception as e:
            logger.error(f"Error in AI step generation: {str(e)}")
            # Fallback to template-based generation
            return self.generate_fallback_steps(problem_text, problem_analysis)
    
    def build_enhanced_prompt(self, problem_text, topic, grade_level, subject, 
                            problem_analysis, include_verification, show_intermediate_work):
        """
        Build an enhanced prompt based on problem analysis
        """
        
        problem_type = problem_analysis.get('problem_type', 'general')
        complexity = problem_analysis.get('complexity', 'moderate')
        estimated_steps = problem_analysis.get('estimated_steps', 4)
        required_concepts = problem_analysis.get('required_concepts', [])
        verification_method = problem_analysis.get('verification_method', '')
        
        prompt = f"""
You are an expert mathematics teacher creating a detailed step-by-step solution for a {grade_level} {subject} student.

PROBLEM TO SOLVE:
{problem_text}

PROBLEM ANALYSIS:
- Type: {problem_type}
- Complexity: {complexity}
- Topic: {topic}
- Required concepts: {', '.join(required_concepts)}
- Estimated steps: {estimated_steps}

REQUIREMENTS:
1. Generate exactly {estimated_steps} clear, logical steps
2. Each step must include:
   - description: Clear explanation of what's being done
   - work: Detailed mathematical calculations and manipulations
   - reasoning: Why this step is necessary
   - result: The outcome of this step
   - key_point: Important concept or principle (optional)
   - hints: Helpful tips for students (optional)
   - common_mistakes: What to avoid (optional)

3. Mathematical work must show:
   - Original equations/expressions
   - Each algebraic manipulation
   - Substitution of values
   - Simplification process
   - All arithmetic calculations

4. Use proper mathematical notation:
   - Fractions: 1/2, 3/4
   - Exponents: x^2, x^3
   - Square roots: sqrt(x)
   - Mathematical symbols: +, -, Ã—, Ã·, =

{"5. Include verification step by: " + verification_method if include_verification else ""}

{"6. Show intermediate work and detailed explanations" if show_intermediate_work else ""}

7. Adapt language and explanations for {grade_level} level students

SPECIFIC GUIDANCE FOR {problem_type.upper()}:
{self.get_type_specific_guidance(problem_type)}

Format your response as JSON:
{{
  "steps": [
    {{
      "description": "Clear explanation of the step",
      "work": "Detailed mathematical calculations with line breaks for each operation",
      "reasoning": "Why this step is necessary",
      "result": "The outcome of this step",
      "key_point": "Important concept (optional)",
      "hints": ["Helpful tip 1", "Helpful tip 2"],
      "common_mistakes": ["Common mistake 1", "Common mistake 2"]
    }}
  ]
}}

IMPORTANT: Return ONLY the JSON object. No additional text.
"""
        
        return prompt
    
    def get_type_specific_guidance(self, problem_type):
        """
        Get specific guidance for different problem types
        """
        guidance = {
            'linear_equation': """
- Start by identifying the variable and constants
- Move all variable terms to one side, constants to the other
- Show each inverse operation clearly
- Simplify step by step
- Always verify by substitution""",
            
            'quadratic_equation': """
- Rearrange to standard form axÂ² + bx + c = 0
- Determine the best solution method (factoring, quadratic formula, etc.)
- Show all algebraic manipulations
- Calculate discriminant if using quadratic formula
- Check both solutions in original equation""",
            
            'slope_calculation': """
- Identify the two points clearly
- Write the slope formula: m = (yâ‚‚ - yâ‚)/(xâ‚‚ - xâ‚)
- Substitute coordinates carefully
- Show the subtraction in numerator and denominator
- Simplify the fraction""",
            
            'trigonometry': """
- Identify given information and what to find
- Choose appropriate trigonometric ratio
- Set up the equation using the ratio
- Solve using inverse trig functions if needed
- Check answer reasonableness""",
            
            'calculus': """
- Identify the function and what operation is needed
- Apply appropriate rules (power rule, chain rule, etc.)
- Show each differentiation/integration step
- Simplify the final expression
- Verify using alternate method if possible""",
            
            'geometry': """
- Identify the shape and given measurements
- Choose the appropriate formula
- Substitute known values
- Calculate step by step
- Include appropriate units in final answer""",
            
            'general_mathematics': """
- Read the problem carefully and identify what's given
- Determine what needs to be found
- Choose appropriate mathematical methods
- Show all calculations clearly
- Verify the answer makes sense"""
        }
        
        return guidance.get(problem_type, guidance['general_mathematics'])
    
    def parse_ai_response(self, content, problem_analysis):
        """
        Parse AI response into structured steps
        """
        try:
            # Clean the response
            cleaned_content = content.strip()
            if cleaned_content.startswith('```json'):
                cleaned_content = cleaned_content[7:]
            if cleaned_content.endswith('```'):
                cleaned_content = cleaned_content[:-3]
            
            # Parse JSON
            response_data = json.loads(cleaned_content)
            steps = response_data.get('steps', [])
            
            # Validate step structure
            validated_steps = []
            for i, step in enumerate(steps):
                validated_step = {
                    'step_number': i + 1,
                    'description': step.get('description', f'Step {i + 1}'),
                    'work': step.get('work', ''),
                    'reasoning': step.get('reasoning', ''),
                    'result': step.get('result', ''),
                    'key_point': step.get('key_point', ''),
                    'hints': step.get('hints', []),
                    'common_mistakes': step.get('common_mistakes', [])
                }
                validated_steps.append(validated_step)
            
            return validated_steps
            
        except (json.JSONDecodeError, KeyError) as e:
            logger.error(f"Error parsing AI response: {str(e)}")
            return self.generate_fallback_steps(content, problem_analysis)
    
    def validate_and_enhance_steps(self, steps, problem_analysis):
        """
        Validate and enhance the generated steps
        """
        enhanced_steps = []
        
        for step in steps:
            # Ensure all required fields are present
            enhanced_step = {
                'step_number': step.get('step_number', 1),
                'description': step.get('description', 'Mathematical operation'),
                'work': step.get('work', 'Perform calculations'),
                'reasoning': step.get('reasoning', 'Apply mathematical principles'),
                'result': step.get('result', 'Result obtained'),
                'key_point': step.get('key_point', ''),
                'hints': step.get('hints', []),
                'common_mistakes': step.get('common_mistakes', [])
            }
            
            # Add verification for last step if needed
            if (step.get('step_number') == len(steps) and 
                problem_analysis.get('verification_method')):
                enhanced_step['verification'] = {
                    'method': problem_analysis.get('verification_method'),
                    'description': 'Verify the solution is correct'
                }
            
            enhanced_steps.append(enhanced_step)
        
        return enhanced_steps
    
    def generate_fallback_steps(self, problem_text, problem_analysis):
        """
        Generate fallback steps when AI parsing fails
        """
        problem_type = problem_analysis.get('problem_type', 'general')
        estimated_steps = problem_analysis.get('estimated_steps', 4)
        
        fallback_steps = []
        
        for i in range(estimated_steps):
            step = {
                'step_number': i + 1,
                'description': f'Solve step {i + 1} of the {problem_type} problem',
                'work': f'Apply mathematical operations for step {i + 1}',
                'reasoning': f'This step is necessary to progress toward the solution',
                'result': f'Result from step {i + 1}',
                'key_point': '',
                'hints': [],
                'common_mistakes': []
            }
            fallback_steps.append(step)
        
        return fallback_steps


def enhance_mathematical_content(steps, problem_analysis):
    """
    Enhance mathematical content in steps with proper formatting
    """
    enhanced_steps = []
    
    for step in steps:
        enhanced_step = step.copy()
        
        # Enhance mathematical notation in work field
        if enhanced_step.get('work'):
            enhanced_step['work'] = enhance_mathematical_notation(enhanced_step['work'])
        
        # Enhance mathematical notation in other fields
        for field in ['description', 'reasoning', 'result']:
            if enhanced_step.get(field):
                enhanced_step[field] = enhance_mathematical_notation(enhanced_step[field])
        
        # Add mathematical symbols and formatting
        enhanced_step['mathematical_work'] = format_mathematical_work(enhanced_step.get('work', ''))
        
        enhanced_steps.append(enhanced_step)
    
    return enhanced_steps


def enhance_mathematical_notation(text):
    """
    Enhance mathematical notation in text
    """
    if not text:
        return text
    
    # Replace common mathematical expressions
    enhanced = text
    enhanced = re.sub(r'\^2', 'Â²', enhanced)
    enhanced = re.sub(r'\^3', 'Â³', enhanced)
    enhanced = re.sub(r'sqrt\(([^)]+)\)', r'âˆš(\1)', enhanced)
    enhanced = re.sub(r'\+/-', 'Â±', enhanced)
    enhanced = re.sub(r'infinity', 'âˆž', enhanced)
    enhanced = re.sub(r'pi', 'Ï€', enhanced)
    
    return enhanced


def format_mathematical_work(work_text):
    """
    Format mathematical work with proper line breaks and structure
    """
    if not work_text:
        return work_text
    
    # Add proper formatting for mathematical expressions
    lines = work_text.split('\n')
    formatted_lines = []
    
    for line in lines:
        line = line.strip()
        if line:
            # Add proper spacing around operators
            line = re.sub(r'([=+\-*/])', r' \1 ', line)
            line = re.sub(r'\s+', ' ', line)  # Remove extra spaces
            formatted_lines.append(line)
    
    return '\n'.join(formatted_lines)


# Additional utility endpoint for testing step generation
@app.route('/api/test-dynamic-steps', methods=['POST'])
@token_required 
def test_dynamic_steps(current_user):
    """
    Test endpoint for dynamic step generation
    """
    try:
        data = request.get_json()
        problem_text = data.get('problem_text', 'Solve 2x + 5 = 17')
        
        analyzer = MathematicalProblemAnalyzer()
        analysis = analyzer.analyze_problem(problem_text, 'algebra', 'mathematics')
        
        return jsonify({
            'problem': problem_text,
            'analysis': analysis,
            'message': 'Analysis completed successfully'
        }), 200
        
    except Exception as e:
        logger.error(f"Error in test endpoint: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/get-quiz-info/<quiz_id>')
def get_quiz_info(quiz_id):
    try:
        quiz = Quiz.query.get(quiz_id)
        if not quiz:
            return jsonify({"error": "Quiz not found"}), 404

        return jsonify({
            'id': quiz.id,
            'title': quiz.title,
            'topic': quiz.topic,
            'grade_level': quiz.grade_level,
            'time_limit': quiz.time_limit,
            'mode': quiz.mode
        })
    except Exception as e:
        logger.error(f"Error getting quiz info: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/regenerate-question', methods=['POST'])
@token_required
def regenerate_question(current_user):
    try:
        data = request.get_json()
        quiz_id = data.get('quiz_id')
        question_id = data.get('question_id')
        topic = data.get('topic')
        grade_level = data.get('grade_level')
        
        # Get the original question type (if available)
        original_type = data.get('question_type', 'multiple_choice')  # Default to multiple choice
        
        # Log the request details for debugging
        logger.info(f"Regenerating {original_type} question for quiz {quiz_id}, question {question_id}")
        
        # Generate a different prompt based on question type
        if original_type == 'true_false':
            prompt = f"""Create one True/False question about {topic} for {grade_level} level students.

            Format the question like this:
            Question: [question text]
            A) True
            B) False
            Correct: [A or B]

            Make the question challenging but appropriate for {grade_level} level students.
            """
        elif original_type == 'paragraph':
            prompt = f"""Create one paragraph question about {topic} for {grade_level} level students.

            Format the question like this:
            Question: [question text that requires a written response]

            Make the question open-ended and thought-provoking, appropriate for {grade_level} level students.
            """
        else:  # Default to multiple choice
            prompt = f"""Create one multiple choice question about {topic} for {grade_level} level students.

            Format the question like this:
            Question: [question text]
            A) [first option]
            B) [second option]
            C) [third option]
            D) [fourth option]
            Correct: [A, B, C, or D]

            Make the question challenging but appropriate for {grade_level} level students.
            """

        # Call Claude API
        try:
            response = anthropic_client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=1000,
                temperature=0.7,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            content = response.content[0].text
            logger.info(f"Received response from Claude: {len(content)} characters")
            logger.debug(f"Claude response: {content[:200]}...")
            
        except Exception as claude_error:
            logger.error(f"Claude API error: {str(claude_error)}")
            return jsonify({'error': 'Failed to generate new question'}), 500
        
        # Parse the new question based on type
        new_question = None
        
        # For multiple choice or true/false
        if original_type in ['multiple_choice', 'true_false']:
            options = []
            question_text = None
            
            for line in content.strip().split('\n'):
                line = line.strip()
                if not line:
                    continue
                    
                if line.startswith("Question:"):
                    question_text = line.replace("Question:", "").strip()
                    
                elif line[0:2] in ["A)", "B)", "C)", "D)"]:
                    option_text = line[2:].strip()
                    options.append({
                        "text": option_text,
                        "isCorrect": False
                    })
                    
                elif line.startswith("Correct:"):
                    correct_letter = line.replace("Correct:", "").strip()
                    if correct_letter in ["A", "B", "C", "D"]:
                        correct_index = ord(correct_letter) - ord("A")
                        if 0 <= correct_index < len(options):
                            options[correct_index]["isCorrect"] = True
            
            if question_text and options:
                new_question = {
                    "text": question_text,
                    "type": original_type,
                    "options": options,
                    "id": question_id or str(uuid.uuid4())
                }
        
        # For paragraph questions
        elif original_type == 'paragraph':
            for line in content.strip().split('\n'):
                line = line.strip()
                if line.startswith("Question:"):
                    question_text = line.replace("Question:", "").strip()
                    new_question = {
                        "text": question_text,
                        "type": "paragraph",
                        "id": question_id or str(uuid.uuid4())
                    }
                    break
        
        # If parsing failed, log details and return error
        if not new_question:
            logger.error(f"Failed to parse question from response: {content}")
            return jsonify({'error': 'Failed to parse generated question'}), 400
            
        # Update quiz in database if quiz_id is provided
        if quiz_id:
            quiz = Quiz.query.get(quiz_id)
            if quiz:
                # Get existing questions
                questions = []
                try:
                    if hasattr(quiz, 'questions_json') and quiz.questions_json:
                        questions = json.loads(quiz.questions_json)
                    else:
                        logger.warning(f"No questions_json found for quiz {quiz_id}")
                except json.JSONDecodeError:
                    logger.error(f"Failed to parse questions_json for quiz {quiz_id}")
                
                # Update questions list
                if question_id:
                    found = False
                    for i, q in enumerate(questions):
                        if q.get('id') == question_id:
                            questions[i] = new_question
                            found = True
                            break
                    if not found:
                        questions.append(new_question)
                else:
                    questions.append(new_question)
                
                # Save updated questions
                try:
                    if hasattr(quiz, 'questions_json'):
                        quiz.questions_json = json.dumps(questions)
                        db.session.commit()
                        logger.info(f"Updated questions for quiz {quiz_id}")
                    else:
                        logger.warning("Quiz model doesn't have questions_json field")
                except Exception as e:
                    logger.error(f"Error saving questions: {str(e)}")
        
        return jsonify({
            'question': new_question
        }), 200
        
    except Exception as e:
        logger.error(f"Question regeneration error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/get-quiz/<quiz_id>')
def get_quiz(quiz_id):
    try:
        # Get quiz from database
        quiz = Quiz.query.get(quiz_id)
        if not quiz:
            return jsonify({"error": "Quiz not found"}), 404

        # Check if the quiz has questions stored in questions_json field
        questions = []
        try:
            if hasattr(quiz, 'questions_json') and quiz.questions_json:
                questions = json.loads(quiz.questions_json)
                
                # Normalize question types for consistency
                for question in questions:
                    # Make sure type is lowercase for consistency
                    if 'type' in question:
                        question['type'] = question['type'].lower()
                    
                    # If no type is specified but has options, set as multiple_choice
                    if ('type' not in question or not question['type']) and 'options' in question and question['options']:
                        question['type'] = 'multiple_choice'
                
                logger.info(f"Successfully retrieved stored questions for quiz {quiz_id}")
        except Exception as e:
            logger.error(f"Error parsing stored questions: {str(e)}")
            # If there was an error with the stored questions, return an empty list
            questions = []
            
        return jsonify({
            'id': quiz.id,
            'title': quiz.title,
            'topic': quiz.topic,
            'grade_level': quiz.grade_level,
            'time_limit': quiz.time_limit,
            'mode': quiz.mode,
            'questions': questions
        })
        
    except Exception as e:
        logger.error(f"Error getting quiz: {str(e)}")
        return jsonify({"error": str(e)}), 500

# In your Flask or similar backend code:


    
@app.route('/api/submit-quiz', methods=['POST'])
def submit_quiz():
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['quiz_id', 'student_name', 'score', 'max_score', 'answers']
        if not all(field in data for field in required_fields):
            return jsonify({'error': 'Missing required fields'}), 400
        
        # Get the quiz record first
        quiz_record = Quiz.query.get(data['quiz_id'])
        if not quiz_record:
            return jsonify({"error": "Quiz not found"}), 404
            
        # Create submission with owner ID
        new_submission = QuizSubmission(
            id=str(uuid.uuid4()),
            quiz_id=data['quiz_id'],
            quiz_owner_id=quiz_record.user_id,  # Use quiz_record.user_id
            student_name=data['student_name'],
            score=data['score'],
            max_score=data['max_score'],
            answers=json.dumps(data['answers']),
            time_taken=data.get('time_taken')
        )
        
        db.session.add(new_submission)
        db.session.commit()
        
        return jsonify({
            'id': new_submission.id,
            'message': 'Quiz submitted successfully'
        }), 201
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500
        
            

@app.route('/test-login-logic')
def test_login_logic():
    try:
        # Test the login logic without actually logging in
        # Just check if we can find a user
        user = User.query.first()
        return jsonify({
            'status': 'success',
            'message': 'Login logic test successful',
            'found_user': user is not None,
            'user_email': user.email if user else None
        })
    except Exception as e:
        return jsonify({
            'status': 'error',
            'message': f'Login logic error: {str(e)}'
        }), 500
# Serve static files
@app.route('/')
def serve_frontend():
    return send_from_directory('.', 'index.html')

@token_required
def check_auth(current_user):
    """Check if user is authenticated and return user info"""
    return jsonify({
        'isAuthenticated': True,
        'user': {
            'id': current_user.id,
            'name': current_user.name,
            'email': current_user.email,
            'trial_ends_at': current_user.trial_ends_at.isoformat() if current_user.trial_ends_at else None
        }
    })

def resend_verification():
    # Function logic here
    pass

if __name__ == '__main__':
    with app.app_context():
        # Verify database connectivity (tables must already exist)
        try:
            from sqlalchemy import text
            db.session.execute(text("SELECT 1")).fetchone()
            logger.info("âœ“ Database connection verified - tables must exist")
        except Exception as e:
            logger.error(f"Database connectivity error: {str(e)}")
    app.run(debug=True)


@app.route('/user/profile', methods=['GET'])
@token_required
def get_user_profile(current_user):
    """Get user profile information"""
    subscription = Subscription.query.filter_by(
        user_id=current_user.id,
        status='active'
    ).first()
    
    return jsonify({
        'user': {
            'id': current_user.id,
            'name': current_user.name,
            'email': current_user.email,
            'country': current_user.country,
            'trial_ends_at': current_user.trial_ends_at.isoformat() if current_user.trial_ends_at else None,
            'subscription': {
                'active': bool(subscription),
                'plan_type': subscription.plan_type if subscription else None,
                'ends_at': subscription.ends_at.isoformat() if subscription and subscription.ends_at else None
            }
        }
    })
@app.route('/api/debug/quiz-format', methods=['GET'])
def debug_quiz_format():
    return jsonify({
        'expected_fields': {
            'title': 'string',
            'topic': 'string',
            'grade_level': 'string',
            'numQuestions': 'integer',
            'time_limit': 'integer',
            'mode': 'string'
        },
        'sample_request': {
            'studentName': 'Test Student',
            'title': 'Test Quiz',
            'topic': 'Biology',
            'grade_level': 'high',
            'numQuestions': 5,
            'time_limit': 30,
            'mode': 'list'
        }
    })

@app.route('/api/stripe-button-info', methods=['GET'])
@token_required
def get_stripe_button_info(current_user):
    """Get the appropriate Stripe button ID based on user's trial status"""
    try:
        # Check if user has an active subscription
        subscription = Subscription.query.filter_by(
            user_id=current_user.id,
            status='active'
        ).first()
        
        has_active_subscription = bool(subscription)
        
        # Check if user is in trial period
        in_trial_period = False
        if current_user.trial_ends_at:
            trial_diff = current_user.trial_ends_at - datetime.utcnow()
            in_trial_period = trial_diff.total_seconds() > 0
        
        # Determine which button to show
        if has_active_subscription or in_trial_period:
            # User has active subscription or is in trial - no button needed
            button_id = None
            button_text = None
        else:
            # User's trial has ended - show subscription button
            button_id = 'buy_btn_1R0R3KDzaE07qplyVINIe3Di'  # Your subscription-only button ID
            button_text = 'Subscribe Now'
            
        return jsonify({
            'button_id': button_id,
            'button_text': button_text,
            'trial_active': in_trial_period,
            'subscription_active': has_active_subscription
        })
    except Exception as e:
        logger.error(f"Error getting Stripe button info: {str(e)}")
        return jsonify({'error': str(e)}), 500
        
@app.route('/user/profile', methods=['PUT'])
@token_required
def update_user_profile(current_user):
    """Update user profile information"""
    try:
        data = request.get_json()
        
        if 'name' in data:
            current_user.name = data['name']
        if 'country' in data:
            current_user.country = data['country']
            
        db.session.commit()
        
        return jsonify({
            'message': 'Profile updated successfully',
            'user': {
                'id': current_user.id,
                'name': current_user.name,
                'email': current_user.email,
                'country': current_user.country
            }
        })
    except Exception as e:
        logger.error(f"Profile update error: {str(e)}")
        return jsonify({'error': 'Failed to update profile'}), 500
@app.route('/api/quiz-scores', methods=['POST', 'OPTIONS'])
def submit_quiz_score():
    """
    Submit quiz score - generic endpoint that routes to appropriate system
    Handles both regular quiz submissions and social media task submissions
    """
    # Handle CORS preflight
    if request.method == 'OPTIONS':
        response = jsonify({'status': 'ok'})
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
        response.headers.add('Access-Control-Allow-Methods', 'POST,OPTIONS')
        return response, 200
    
    try:
        data = request.get_json()
        
        if not data:
            logger.error("No data received in quiz score submission")
            return jsonify({'error': 'No data provided'}), 400
        
        logger.info(f"Quiz score submission received: {data}")
        
        # Check if this is a social media task
        task_id = data.get('task_id')
        
        if task_id:
            # This is a social media task - requires authentication
            logger.info(f"Processing social media task submission for task_id: {task_id}")
            
            try:
                # Get the auth token from headers
                auth_header = request.headers.get('Authorization')
                if not auth_header or not auth_header.startswith('Bearer '):
                    logger.warning("Social media task submission without valid auth token")
                    return jsonify({
                        'error': 'Authentication required',
                        'message': 'Please ensure you are logged in to the social media portal',
                        'code': 'AUTH_REQUIRED'
                    }), 401
                
                token = auth_header.split(' ')[1]
                
                # Decode and verify token
                try:
                    payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
                    student_id = payload.get('student_id')
                    
                    # Verify this is a social media student token
                    if payload.get('student_type') != 'social_media':
                        logger.warning(f"Invalid token type for social media task: {payload.get('student_type')}")
                        return jsonify({
                            'error': 'Invalid token type',
                            'message': 'This token is not valid for social media tasks'
                        }), 401
                    
                except jwt.ExpiredSignatureError:
                    logger.error("Token expired")
                    return jsonify({
                        'error': 'Token expired',
                        'message': 'Your session has expired. Please log in again.',
                        'code': 'TOKEN_EXPIRED'
                    }), 401
                except jwt.InvalidTokenError as e:
                    logger.error(f"Invalid token: {str(e)}")
                    return jsonify({
                        'error': 'Invalid token',
                        'message': 'Authentication token is invalid',
                        'code': 'INVALID_TOKEN'
                    }), 401
                
                # Get the task
                task = SocialMediaTask.query.filter_by(
                    id=task_id,
                    student_id=student_id
                ).first()
                
                if not task:
                    logger.warning(f"Task {task_id} not found for student {student_id}")
                    return jsonify({
                        'error': 'Task not found',
                        'message': 'The specified task does not exist or does not belong to you'
                    }), 404
                
                # Extract score data
                score = data.get('score', 0)
                max_score = data.get('max_score', 100)
                time_spent_minutes = data.get('time_spent_minutes', 0)
                
                # If time is in seconds, convert to minutes
                if time_spent_minutes > 500:  # Likely in seconds
                    time_spent_minutes = time_spent_minutes // 60
                
                logger.info(f"Task {task_id} - Score: {score}/{max_score}, Time: {time_spent_minutes}min")
                
                # Calculate completion percentage
                completion_percentage = (score / max_score * 100) if max_score > 0 else 0
                
                # Mark task as completed
                task.status = 'completed'
                task.completed_at = datetime.utcnow()
                
                # Award points based on score
                points_earned = 0
                if task.points_reward:
                    if completion_percentage >= 70:
                        points_earned = task.points_reward
                    else:
                        points_earned = int(task.points_reward * (completion_percentage / 100))
                
                logger.info(f"Points to be awarded: {points_earned}")
                
                # Update student points
                student = SocialMediaStudent.query.get(student_id)
                if not student:
                    logger.error(f"Student {student_id} not found")
                    return jsonify({'error': 'Student not found'}), 404
                
                student.total_points = (student.total_points or 0) + points_earned
                student.total_tasks_completed = (student.total_tasks_completed or 0) + 1
                logger.info(f"Student {student.full_name} - New total points: {student.total_points}")
                
                # Update or create progress record for this week
                week_number = task.week_number
                
                if not week_number:
                    logger.warning(f"Task {task_id} has no week_number, using week 1")
                    week_number = 1
                
                progress = SocialMediaProgress.query.filter_by(
                    student_id=student_id,
                    week_number=week_number
                ).first()
                
                if not progress:
                    # Count total lessons in this week
                    total_week_tasks = SocialMediaTask.query.filter_by(
                        student_id=student_id,
                        week_number=week_number
                    ).count()
                    
                    progress = SocialMediaProgress(
                        student_id=student_id,
                        week_number=week_number,
                        completed_lessons=1,
                        total_lessons=total_week_tasks if total_week_tasks > 0 else 1,
                        time_spent_minutes=time_spent_minutes,
                        progress_percentage=0
                    )
                    db.session.add(progress)
                    logger.info(f"Created new progress record for Week {week_number}")
                else:
                    # Update existing progress
                    progress.completed_lessons += 1
                    progress.time_spent_minutes = (progress.time_spent_minutes or 0) + time_spent_minutes
                    progress.last_updated = datetime.utcnow()
                    logger.info(f"Updated progress for Week {week_number}: {progress.completed_lessons}/{progress.total_lessons}")
                
                # Recalculate progress percentage
                if progress.total_lessons > 0:
                    progress.progress_percentage = (progress.completed_lessons / progress.total_lessons) * 100
                else:
                    progress.progress_percentage = 0
                
                # Commit all changes
                db.session.commit()
                
                logger.info(f"âœ… Task {task_id} completed successfully. Points: {points_earned}, Progress: {progress.progress_percentage:.1f}%")
                
                return jsonify({
                    'success': True,
                    'message': 'Task completed successfully',
                    'points_earned': points_earned,
                    'completion_percentage': round(completion_percentage, 1),
                    'progress': {
                        'week_number': progress.week_number,
                        'completed_lessons': progress.completed_lessons,
                        'total_lessons': progress.total_lessons,
                        'progress_percentage': round(progress.progress_percentage, 1),
                        'time_spent_minutes': progress.time_spent_minutes
                    },
                    'student': {
                        'total_points': student.total_points,
                        'total_tasks_completed': student.total_tasks_completed
                    }
                }), 200
                
            except Exception as e:
                logger.error(f"Error processing social media task completion: {str(e)}")
                logger.error(traceback.format_exc())
                db.session.rollback()
                return jsonify({
                    'error': 'Failed to complete task',
                    'message': str(e),
                    'code': 'PROCESSING_ERROR'
                }), 500
        
        # If not a social media task, handle as regular quiz submission (no auth required)
        else:
            logger.info("Regular quiz submission (non-social-media) - no auth required")

            # Store regular quiz submission in the QuizSubmission table
            try:
                quiz_id = data.get('quiz_id')
                student_name = data.get('student_name', 'Anonymous')
                score = data.get('score', 0)
                max_score = data.get('max_score', 100)
                answers = data.get('answers', {})
                time_taken = data.get('time_taken')

                logger.info(f"Saving quiz submission - Quiz: {quiz_id}, Student: {student_name}, Score: {score}/{max_score}")

                # Get the quiz record to get the owner ID
                quiz_record = Quiz.query.get(quiz_id)
                if not quiz_record:
                    logger.warning(f"Quiz {quiz_id} not found in database, creating submission anyway")
                    quiz_owner_id = None
                else:
                    quiz_owner_id = quiz_record.user_id

                # Create the submission record
                new_submission = QuizSubmission(
                    id=str(uuid.uuid4()),
                    quiz_id=quiz_id,
                    quiz_owner_id=quiz_owner_id,
                    student_name=student_name,
                    score=score,
                    max_score=max_score,
                    answers=json.dumps(answers),
                    time_taken=time_taken
                )

                db.session.add(new_submission)
                db.session.commit()

                logger.info(f"âœ… Quiz submission saved successfully: {new_submission.id}")

                return jsonify({
                    'success': True,
                    'message': 'Quiz score recorded',
                    'submission_id': new_submission.id,
                    'quiz_id': quiz_id,
                    'student_name': student_name,
                    'score': score,
                    'max_score': max_score
                }), 200

            except Exception as save_error:
                logger.error(f"Error saving regular quiz submission: {str(save_error)}")
                logger.error(traceback.format_exc())
                db.session.rollback()
                # Return success anyway to not break the frontend, but log the error
                return jsonify({
                    'success': True,
                    'message': 'Quiz completed but submission not saved',
                    'error': str(save_error)
                }), 200
            
    except Exception as e:
        logger.error(f"Quiz score submission error: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({
            'error': 'Failed to submit score',
            'message': str(e),
            'code': 'SUBMISSION_ERROR'
        }), 500


@app.route('/api/quiz-scores/<quiz_id>', methods=['GET'])
@token_required
def get_quiz_scores(current_user, quiz_id):
    """Get all submissions for a specific quiz"""
    try:
        # Add detailed logging
        logger.info(f"Fetching scores for quiz ID: {quiz_id}, User ID: {current_user.id}")
        
        # Verify that the quiz exists
        quiz = Quiz.query.get(quiz_id)
        if not quiz:
            logger.error(f"Quiz not found: {quiz_id}")
            return jsonify({"error": "Quiz not found"}), 404
            
        # More permissive check - allow access if it's their quiz OR the quiz has submissions associated with them
        submissions_exist = QuizSubmission.query.filter_by(quiz_id=quiz_id).first() is not None
        
        if quiz.user_id != current_user.id and not submissions_exist:
            logger.warning(f"Access concern: Quiz belongs to user {quiz.user_id}, not {current_user.id}")
            # Continue anyway since we want to be more permissive
        
        # Get all submissions for this quiz
        logger.info(f"Querying submissions for quiz {quiz_id}")
        submissions = QuizSubmission.query.filter_by(quiz_id=quiz_id).all()
        logger.info(f"Found {len(submissions)} submissions")
        
        # Format the submissions for the response
        formatted_submissions = []
        for submission in submissions:
            logger.info(f"Processing submission {submission.id}")
            # Parse the answers JSON
            answers_data = {}
            if submission.answers:
                try:
                    answers_data = json.loads(submission.answers)
                except Exception as e:
                    logger.error(f"Error parsing answers JSON: {str(e)}")
            
            # Format time
            time_spent = "N/A"
            if submission.time_taken:
                minutes = submission.time_taken // 60
                seconds = submission.time_taken % 60
                time_spent = f"{minutes}m {seconds}s"
            
            formatted_submissions.append({
                "id": submission.id,
                "student_name": submission.student_name,
                "score": submission.score,
                "max_score": submission.max_score,
                "percentage": round((submission.score / submission.max_score * 100) if submission.max_score > 0 else 0, 1),
                "time_spent": time_spent,
                "submitted_at": submission.submitted_at.isoformat()
            })
            
        return jsonify({
            "quiz_id": quiz_id,
            "quiz_title": quiz.title,
            "submissions": formatted_submissions,
            "total_submissions": len(formatted_submissions)
        }), 200
        
    except Exception as e:
        logger.error(f"Error getting quiz scores: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/quiz-scores', methods=['GET'])
@token_required
def get_all_quiz_scores(current_user):
    """Get all quiz submissions for the current user's quizzes"""
    try:
        logger.info(f"Fetching all quiz scores for user {current_user.id}")

        # Get all quizzes belonging to the current user
        user_quizzes = Quiz.query.filter_by(user_id=current_user.id).all()
        quiz_ids = [quiz.id for quiz in user_quizzes]

        logger.info(f"Found {len(quiz_ids)} quizzes for user")

        # Get all submissions for these quizzes
        submissions = QuizSubmission.query.filter(QuizSubmission.quiz_id.in_(quiz_ids)).all()
        logger.info(f"Found {len(submissions)} total submissions")

        # Format the submissions
        formatted_submissions = []
        for submission in submissions:
            # Get quiz info
            quiz = next((q for q in user_quizzes if q.id == submission.quiz_id), None)

            formatted_submissions.append({
                "id": submission.id,
                "quiz_id": submission.quiz_id,
                "quiz_title": quiz.title if quiz else "Unknown Quiz",
                "student_name": submission.student_name,
                "score": submission.score,
                "max_score": submission.max_score,
                "percentage": round((submission.score / submission.max_score * 100) if submission.max_score > 0 else 0, 1),
                "time_taken": submission.time_taken,
                "submission_date": submission.submitted_at.isoformat() if submission.submitted_at else None,
                "created_at": submission.submitted_at.isoformat() if submission.submitted_at else None
            })

        logger.info(f"Returning {len(formatted_submissions)} formatted submissions")

        return jsonify({
            "scores": formatted_submissions,
            "total": len(formatted_submissions)
        }), 200

    except Exception as e:
        logger.error(f"Error getting all quiz scores: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({"error": str(e)}), 500

@app.route('/api/quiz-scores/<quiz_id>/<submission_id>', methods=['DELETE'])
@token_required
def delete_quiz_submission(current_user, quiz_id, submission_id):
    """Delete a specific quiz submission"""
    try:
        # Verify that the quiz belongs to the current user
        quiz = Quiz.query.get(quiz_id)
        if not quiz or quiz.user_id != current_user.id:
            return jsonify({"error": "Quiz not found or access denied"}), 404

        # Get the submission
        submission = QuizSubmission.query.get(submission_id)
        if not submission or submission.quiz_id != quiz_id:
            return jsonify({"error": "Submission not found"}), 404

        # Delete the submission
        db.session.delete(submission)
        db.session.commit()

        return jsonify({
            "message": "Submission deleted successfully",
            "id": submission_id
        }), 200

    except Exception as e:
        logger.error(f"Error deleting quiz submission: {str(e)}")
        db.session.rollback()
        return jsonify({"error": str(e)}), 500

@app.route('/api/quiz-performance', methods=['GET'])
@token_required
def get_performance_metrics(current_user):
    """Get performance metrics for user's quizzes"""
    try:
        # Query parameter to filter by quiz
        quiz_id = request.args.get('quiz_id')
        time_period = request.args.get('period', 'month')  # 'week', 'month', 'year'
        
        # Define the time range based on period
        now = datetime.utcnow()
        if time_period == 'week':
            start_date = now - timedelta(days=7)
        elif time_period == 'year':
            start_date = now - timedelta(days=365)
        else:  # default to month
            start_date = now - timedelta(days=30)
        
        # Base query to get submissions for the user's quizzes
        base_query = db.session.query(QuizSubmission).\
            join(Quiz, QuizSubmission.quiz_id == Quiz.id).\
            filter(Quiz.user_id == current_user.id,
                   QuizSubmission.submitted_at >= start_date)
        
        # Apply quiz filter if specified
        if quiz_id:
            base_query = base_query.filter(QuizSubmission.quiz_id == quiz_id)
        
        # Get all the submissions
        submissions = base_query.all()
        
        # Calculate summary statistics
        total_submissions = len(submissions)
        
        if total_submissions == 0:
            return jsonify({
                "message": "No quiz submissions found for the specified criteria",
                "total_submissions": 0
            }), 200
        
        # Calculate score distribution
        score_distribution = {
            "0-59": 0,
            "60-69": 0,
            "70-79": 0,
            "80-89": 0,
            "90-100": 0
        }
        
        total_score = 0
        student_set = set()
        
        for submission in submissions:
            score_percentage = (submission.score / submission.max_score * 100) if submission.max_score > 0 else 0
            total_score += score_percentage
            student_set.add(submission.student_name)
            
            if score_percentage < 60:
                score_distribution["0-59"] += 1
            elif score_percentage < 70:
                score_distribution["60-69"] += 1
            elif score_percentage < 80:
                score_distribution["70-79"] += 1
            elif score_percentage < 90:
                score_distribution["80-89"] += 1
            else:
                score_distribution["90-100"] += 1
        
        average_score = total_score / total_submissions if total_submissions > 0 else 0
        
        # Get activity over time (grouped by day)
        query = text('''
            SELECT DATE(submitted_at) as date, COUNT(*) as count
            FROM quiz_submissions 
            JOIN quizzes ON quiz_submissions.quiz_id = quizzes.id
            WHERE quizzes.user_id = :user_id
              AND submitted_at >= :start_date
            GROUP BY DATE(submitted_at)
            ORDER BY DATE(submitted_at)
        ''')
        
        daily_activity = db.session.execute(
            query, 
            {"user_id": current_user.id, "start_date": start_date}
        ).fetchall()
        
        activity_data = [{"date": str(row[0]), "count": row[1]} for row in daily_activity]
        
        # Get top performing students
        top_students_query = text('''
            SELECT student_name, AVG(score * 100.0 / max_score) as avg_score, COUNT(*) as quiz_count
            FROM quiz_submissions
            JOIN quizzes ON quiz_submissions.quiz_id = quizzes.id
            WHERE quizzes.user_id = :user_id
              AND submitted_at >= :start_date
            GROUP BY student_name
            ORDER BY avg_score DESC
            LIMIT 5
        ''')
        
        top_students_result = db.session.execute(
            top_students_query,
            {"user_id": current_user.id, "start_date": start_date}
        ).fetchall()
        
        top_students = [
            {
                "name": row[0], 
                "average_score": round(row[1], 1), 
                "quizzes_taken": row[2]
            } for row in top_students_result
        ]
        
        # Return compiled metrics
        return jsonify({
            "total_submissions": total_submissions,
            "total_students": len(student_set),
            "average_score": round(average_score, 1),
            "score_distribution": score_distribution,
            "activity_data": activity_data,
            "top_students": top_students,
            "time_period": time_period
        }), 200
        
    except Exception as e:
        logger.error(f"Error getting performance metrics: {str(e)}")
        return jsonify({"error": str(e)}), 500
        

        
    except Exception as e:
        db.session.rollback()  # Roll back the session in case of error
        return jsonify({'error': str(e)}), 500

@app.route('/api/quiz-submission-details/<submission_id>', methods=['GET'])
@token_required
def get_submission_details(current_user, submission_id):
    """Get detailed information about a specific quiz submission"""
    try:
        # Get the submission
        submission = QuizSubmission.query.get(submission_id)
        if not submission:
            return jsonify({"error": "Submission not found"}), 404
            
        # Verify that the submission's quiz exists
        quiz = Quiz.query.get(submission.quiz_id)
        if not quiz:
            return jsonify({"error": "Associated quiz not found"}), 404
            
        # More permissive check - allow either the quiz owner or if it's a submission related to them
        if quiz.user_id != current_user.id and getattr(submission, 'quiz_owner_id', None) != current_user.id:
            logger.warning(f"Access concern: Quiz belongs to user {quiz.user_id}, not {current_user.id}")
            
        # Parse the answers JSON
        answers_data = {}
        if submission.answers:
            try:
                answers_data = json.loads(submission.answers)
            except:
                answers_data = {}
                
        # Get the quiz questions
        questions = []
        if quiz.questions_json:
            try:
                questions = json.loads(quiz.questions_json)
            except:
                questions = []
                
        # Match answers with questions
        answered_questions = []
        for i, question in enumerate(questions):
            answer_key = str(i)
            answer_data = answers_data.get(answer_key, {})
            
            selected_option = answer_data.get('selectedOption')
            is_correct = answer_data.get('isCorrect', False)
            
            question_data = {
                "question_number": i + 1,
                "question_text": question.get('text', ''),
                "question_type": question.get('type', 'unknown'),
                "options": question.get('options', []),
                "selected_option": selected_option,
                "is_correct": is_correct
            }
            
            answered_questions.append(question_data)
        
        # Format time spent
        time_spent = "N/A"
        if submission.time_taken:
            minutes = submission.time_taken // 60
            seconds = submission.time_taken % 60
            time_spent = f"{minutes}m {seconds}s"
            
        # Return detailed submission information
        return jsonify({
            "id": submission.id,
            "quiz_id": submission.quiz_id,
            "quiz_title": quiz.title,
            "student_name": submission.student_name,
            "score": submission.score,
            "max_score": submission.max_score,
            "percentage": round((submission.score / submission.max_score * 100) if submission.max_score > 0 else 0, 1),
            "time_spent": time_spent,
            "time_taken_seconds": submission.time_taken,
            "submitted_at": submission.submitted_at.isoformat(),
            "questions": answered_questions
        }), 200
        
    except Exception as e:
        logger.error(f"Error getting submission details: {str(e)}")
        return jsonify({"error": str(e)}), 500

# FIXED: Geometry Quiz API Endpoints with renamed functions to avoid conflicts

@app.route('/api/register-geometry-quiz', methods=['POST'])
@token_required
def register_geometry_quiz_db(current_user):
    """Register a new geometry quiz in the database"""
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['id', 'title', 'topic', 'grade_level']
        for field in required_fields:
            if field not in data:
                return jsonify({"error": f"Missing required field: {field}"}), 400
        
        # Check if quiz already exists
        existing_quiz = GeometryQuiz.query.get(data['id'])
        if existing_quiz:
            logger.info(f"Geometry quiz {data['id']} already exists, returning existing")
            return jsonify({
                "message": "Quiz already registered",
                "quiz_id": existing_quiz.id
            }), 200
        
        # Create new geometry quiz
        geometry_quiz = GeometryQuiz(
            id=data['id'],
            user_id=current_user.id,
            title=data.get('title', 'Geometry Quiz'),
            topic=data.get('topic', 'Geometry'),
            grade_level=data.get('grade_level', 'High School'),
            time_limit=data.get('time_limit', 30),
            mode=data.get('mode', 'list'),
            questions_json=json.dumps(data.get('questions', [])),
            geometry_types=json.dumps(data.get('geometry_types', []))
        )
        
        db.session.add(geometry_quiz)
        db.session.commit()
        
        logger.info(f"Successfully registered geometry quiz: {geometry_quiz.id}")
        
        return jsonify({
            "message": "Geometry quiz registered successfully",
            "quiz_id": geometry_quiz.id
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error registering geometry quiz: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/register-geometry-quiz-anonymous', methods=['POST'])
def register_geometry_quiz_anonymous_db():
    """Register a geometry quiz without authentication"""
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['id', 'title', 'topic', 'grade_level']
        for field in required_fields:
            if field not in data:
                return jsonify({"error": f"Missing required field: {field}"}), 400
        
        # Check if quiz already exists
        existing_quiz = GeometryQuiz.query.get(data['id'])
        if existing_quiz:
            logger.info(f"Geometry quiz {data['id']} already exists, returning existing")
            return jsonify({
                "message": "Quiz already registered",
                "quiz_id": existing_quiz.id
            }), 200
        
        # Create new geometry quiz with anonymous user
        geometry_quiz = GeometryQuiz(
            id=data['id'],
            user_id=0,  # Use 0 for anonymous/system user
            title=data.get('title', 'Geometry Quiz'),
            topic=data.get('topic', 'Geometry'),
            grade_level=data.get('grade_level', 'High School'),
            time_limit=data.get('time_limit', 30),
            mode=data.get('mode', 'list'),
            questions_json=json.dumps(data.get('questions', [])),
            geometry_types=json.dumps(data.get('geometry_types', []))
        )
        
        db.session.add(geometry_quiz)
        db.session.commit()
        
        logger.info(f"Successfully registered anonymous geometry quiz: {geometry_quiz.id}")
        
        return jsonify({
            "message": "Geometry quiz registered successfully",
            "quiz_id": geometry_quiz.id
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error registering anonymous geometry quiz: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/geometry-quiz-data/<quiz_id>', methods=['GET'])
def get_geometry_quiz_data_fixed(quiz_id):
    """Get geometry quiz data with geometry_data support"""
    try:
        logger.info(f"ðŸ“š Request: GET /api/geometry-quiz-data/{quiz_id}")
        
        # Try direct SQL query first (your existing approach)
        try:
            from sqlalchemy import text
            result = db.session.execute(
                text("SELECT * FROM geometry_quiz WHERE id = :quiz_id"),
                {"quiz_id": quiz_id}
            ).fetchone()
            
            if not result:
                logger.warning(f"âš ï¸ Not found in geometry_quiz table, trying quizzes table...")
                # Fallback to quizzes table
                result = db.session.execute(
                    text("SELECT * FROM quizzes WHERE id = :quiz_id"),
                    {"quiz_id": quiz_id}
                ).fetchone()
            
            if not result:
                logger.error(f"âŒ Geometry quiz not found in any table: {quiz_id}")
                return jsonify({"error": "Geometry quiz not found"}), 404
            
            logger.info(f"âœ… Found quiz: {result.title}")
            
            # Parse questions JSON safely
            questions = []
            if result.questions_json:
                try:
                    questions_data = json.loads(result.questions_json)
                    
                    # Handle different formats
                    if isinstance(questions_data, dict):
                        questions = questions_data.get('questions', [])
                    elif isinstance(questions_data, list):
                        questions = questions_data
                    else:
                        logger.warning(f"âš ï¸ Unexpected questions format: {type(questions_data)}")
                        questions = []
                        
                except json.JSONDecodeError as e:
                    logger.error(f"âŒ Error parsing questions JSON: {str(e)}")
                    questions = []
            
            logger.info(f"ðŸ“Š Quiz has {len(questions)} questions")
            
            # CRITICAL: Ensure each question has geometry_data
            for i, question in enumerate(questions):
                if 'geometry_data' not in question:
                    # Extract from other fields if present
                    geometry_data = {
                        'shape_type': question.get('shape_type'),
                        'measurements': question.get('measurements', {}),
                    }
                    question['geometry_data'] = geometry_data
                    logger.info(f"ðŸ“ Q{i+1}: Created geometry_data from fields - shape: {geometry_data.get('shape_type')}")
                else:
                    logger.info(f"âœ… Q{i+1}: geometry_data exists - shape: {question['geometry_data'].get('shape_type')}")
            
            # Parse geometry types safely
            geometry_types = []
            if hasattr(result, 'geometry_types') and result.geometry_types:
                try:
                    geometry_types = json.loads(result.geometry_types)
                except json.JSONDecodeError:
                    geometry_types = []
            
            # Build response with all required fields
            quiz_data = {
                "id": result.id,
                "title": result.title,
                "topic": result.topic,
                "grade_level": result.grade_level,
                "time_limit": result.time_limit,
                "mode": result.mode,
                "questions": questions,  # Now includes geometry_data!
                "geometry_types": geometry_types,
                "created_at": result.created_at.isoformat() if hasattr(result, 'created_at') and result.created_at else None
            }
            
            logger.info(f"âœ… Successfully returning quiz data with {len(questions)} questions")
            return jsonify(quiz_data), 200
            
        except Exception as query_error:
            logger.error(f"âŒ Direct query failed: {query_error}")
            
            # Fallback to ORM query
            geometry_quiz = db.session.query(GeometryQuiz).filter(GeometryQuiz.id == quiz_id).first()
            
            if not geometry_quiz:
                logger.error(f"âŒ Geometry quiz not found via ORM: {quiz_id}")
                return jsonify({"error": "Geometry quiz not found"}), 404
            
            logger.info(f"âœ… Found quiz via ORM: {geometry_quiz.title}")
            
            # Parse questions JSON
            questions = []
            if geometry_quiz.questions_json:
                try:
                    questions_data = json.loads(geometry_quiz.questions_json)
                    
                    # Handle different formats
                    if isinstance(questions_data, dict):
                        questions = questions_data.get('questions', [])
                    elif isinstance(questions_data, list):
                        questions = questions_data
                    else:
                        questions = []
                except:
                    questions = []
            
            logger.info(f"ðŸ“Š Quiz has {len(questions)} questions")
            
            # CRITICAL: Ensure each question has geometry_data
            for i, question in enumerate(questions):
                if 'geometry_data' not in question:
                    geometry_data = {
                        'shape_type': question.get('shape_type'),
                        'measurements': question.get('measurements', {}),
                    }
                    question['geometry_data'] = geometry_data
                    logger.info(f"ðŸ“ Q{i+1}: Created geometry_data from fields")
                else:
                    logger.info(f"âœ… Q{i+1}: geometry_data exists")
            
            # Parse geometry types
            geometry_types = []
            if geometry_quiz.geometry_types:
                try:
                    geometry_types = json.loads(geometry_quiz.geometry_types)
                except:
                    geometry_types = []
            
            response = {
                "id": geometry_quiz.id,
                "title": geometry_quiz.title,
                "topic": geometry_quiz.topic,
                "grade_level": geometry_quiz.grade_level,
                "time_limit": geometry_quiz.time_limit,
                "mode": geometry_quiz.mode,
                "questions": questions,  # Now includes geometry_data!
                "geometry_types": geometry_types,
                "created_at": geometry_quiz.created_at.isoformat() if geometry_quiz.created_at else None
            }
            
            logger.info(f"âœ… Successfully returning quiz data via ORM")
            return jsonify(response), 200
        
    except Exception as e:
        logger.error(f"âŒ Error getting geometry quiz data: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500

@app.route('/api/submit-geometry-quiz-score', methods=['POST'])
def submit_geometry_quiz_score():
    """Submit geometry quiz results (renamed to avoid conflicts)"""
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['quiz_id', 'student_name', 'score', 'max_score']
        for field in required_fields:
            if field not in data:
                return jsonify({"error": f"Missing required field: {field}"}), 400
        
        # Verify the geometry quiz exists
        geometry_quiz = GeometryQuiz.query.get(data['quiz_id'])
        if not geometry_quiz:
            return jsonify({"error": "Geometry quiz not found"}), 404
        
        # Create geometry quiz submission
        submission_id = str(uuid.uuid4())
        geometry_submission = GeometryQuizSubmission(
            id=submission_id,
            quiz_id=data['quiz_id'],
            student_name=data['student_name'],
            score=float(data['score']),
            max_score=float(data['max_score']),
            answers_json=json.dumps(data.get('answers', {})),
            time_taken=data.get('time_taken', 0)
        )
        
        db.session.add(geometry_submission)
        db.session.commit()
        
        logger.info(f"Successfully submitted geometry quiz: {submission_id}")
        
        return jsonify({
            "message": "Geometry quiz submitted successfully",
            "submission_id": submission_id,
            "quiz_id": data['quiz_id']
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error submitting geometry quiz: {str(e)}")
        return jsonify({"error": str(e)}), 500



# Add these endpoints to your Flask backend (similar to geometry quiz endpoints)

@app.route('/api/quiz-scores/<quiz_id>', methods=['GET'])
@token_required
def get_quiz_scores_enhanced(current_user, quiz_id):
    """Get all submissions for a specific quiz (supports regular, geometry, and math quizzes)"""
    try:
        logger.info(f"Fetching scores for quiz ID: {quiz_id}, User ID: {current_user.id}")
        
        # First try regular quiz
        quiz = Quiz.query.get(quiz_id)
        if quiz:
            # Existing logic for regular quizzes
            submissions_exist = QuizSubmission.query.filter_by(quiz_id=quiz_id).first() is not None
            
            if quiz.user_id != current_user.id and not submissions_exist:
                logger.warning(f"Access concern: Quiz belongs to user {quiz.user_id}, not {current_user.id}")
            
            submissions = QuizSubmission.query.filter_by(quiz_id=quiz_id).all()
            
            formatted_submissions = []
            for submission in submissions:
                answers_data = {}
                if submission.answers:
                    try:
                        answers_data = json.loads(submission.answers)
                    except Exception as e:
                        logger.error(f"Error parsing answers JSON: {str(e)}")
                
                time_spent = "N/A"
                if submission.time_taken:
                    minutes = submission.time_taken // 60
                    seconds = submission.time_taken % 60
                    time_spent = f"{minutes}m {seconds}s"
                
                formatted_submissions.append({
                    "id": submission.id,
                    "student_name": submission.student_name,
                    "score": submission.score,
                    "max_score": submission.max_score,
                    "percentage": round((submission.score / submission.max_score * 100) if submission.max_score > 0 else 0, 1),
                    "time_spent": time_spent,
                    "submitted_at": submission.submitted_at.isoformat()
                })
                
            return jsonify({
                "quiz_id": quiz_id,
                "quiz_title": quiz.title,
                "quiz_type": "regular",
                "submissions": formatted_submissions,
                "total_submissions": len(formatted_submissions)
            }), 200
        
        # Try geometry quiz if regular quiz not found
        geometry_quiz = GeometryQuiz.query.get(quiz_id)
        if geometry_quiz:
            logger.info(f"Found geometry quiz: {quiz_id}")
            
            # Get geometry quiz submissions
            geometry_submissions = GeometryQuizSubmission.query.filter_by(quiz_id=quiz_id).all()
            
            formatted_submissions = []
            for submission in geometry_submissions:
                answers_data = {}
                if submission.answers_json:
                    try:
                        answers_data = json.loads(submission.answers_json)
                    except:
                        answers_data = {}
                
                time_spent = "N/A"
                if submission.time_taken:
                    minutes = submission.time_taken // 60
                    seconds = submission.time_taken % 60
                    time_spent = f"{minutes}m {seconds}s"
                
                formatted_submissions.append({
                    "id": submission.id,
                    "student_name": submission.student_name,
                    "score": submission.score,
                    "max_score": submission.max_score,
                    "percentage": round((submission.score / submission.max_score * 100) if submission.max_score > 0 else 0, 1),
                    "time_spent": time_spent,
                    "submitted_at": submission.submitted_at.isoformat()
                })
            
            return jsonify({
                "quiz_id": quiz_id,
                "quiz_title": geometry_quiz.title,
                "quiz_type": "geometry",
                "submissions": formatted_submissions,
                "total_submissions": len(formatted_submissions)
            }), 200
        
        # Try math quiz if geometry quiz not found
        math_quiz = MathQuiz.query.get(quiz_id)
        if math_quiz:
            logger.info(f"Found math quiz: {quiz_id}")
            
            # Get math quiz submissions
            math_submissions = MathQuizSubmission.query.filter_by(quiz_id=quiz_id).all()
            
            formatted_submissions = []
            for submission in math_submissions:
                answers_data = {}
                if submission.answers_json:
                    try:
                        answers_data = json.loads(submission.answers_json)
                    except:
                        answers_data = {}
                
                time_spent = "N/A"
                if submission.time_taken:
                    minutes = submission.time_taken // 60
                    seconds = submission.time_taken % 60
                    time_spent = f"{minutes}m {seconds}s"
                
                formatted_submissions.append({
                    "id": submission.id,
                    "student_name": submission.student_name,
                    "score": submission.score,
                    "max_score": submission.max_score,
                    "percentage": round((submission.score / submission.max_score * 100) if submission.max_score > 0 else 0, 1),
                    "time_spent": time_spent,
                    "submitted_at": submission.submitted_at.isoformat()
                })
            
            return jsonify({
                "quiz_id": quiz_id,
                "quiz_title": math_quiz.title,
                "quiz_type": "math",
                "submissions": formatted_submissions,
                "total_submissions": len(formatted_submissions)
            }), 200
        
        # None of the quiz types found
        logger.error(f"Quiz not found (tried regular, geometry, and math): {quiz_id}")
        return jsonify({"error": "Quiz not found"}), 404
        
    except Exception as e:
        logger.error(f"Error getting quiz scores: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/lesson-preview')
def serve_lesson_preview_page():
    """Serve the lesson preview HTML page"""
    return send_from_directory('.', 'lesson-preview.html')

@app.route('/course-view')
def serve_course_view_page():
    """Serve the course view HTML page"""
    return send_from_directory('.', 'course-view.html')

@app.route('/api/minimal-test', methods=['POST'])
def minimal_test():
    return jsonify({"message": "Test successful"})

import os
from werkzeug.utils import secure_filename
from PIL import Image
import uuid

# Configuration
UPLOAD_FOLDER = 'static/lesson_images'
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
MAX_FILE_SIZE = 2 * 1024 * 1024  # 2MB

# Ensure upload folder exists
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

import boto3
from botocore.exceptions import NoCredentialsError, ClientError
import os
import secrets
import time

# S3 Configuration
S3_BUCKET = os.getenv('S3_BUCKET_NAME')
S3_REGION = os.getenv('S3_REGION', 'eu-north-1')

# Initialize S3 client
s3_client = boto3.client(
    's3',
    aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
    aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),
    region_name=S3_REGION
)

@app.route('/api/get-quiz-embed/<quiz_id>', methods=['GET'])
def get_quiz_embed(quiz_id):
    """Get quiz data for embedding in lesson plans"""
    try:
        logger.info(f"Fetching quiz embed data for ID: {quiz_id}")
        
        # Try MathQuiz first (since your link is math-quiz.html)
        math_quiz = MathQuiz.query.get(quiz_id)
        if math_quiz:
            questions = []
            if math_quiz.questions_json:
                try:
                    questions = json.loads(math_quiz.questions_json)
                except Exception as e:
                    logger.error(f"Error parsing math quiz questions: {e}")
                    questions = []
            
            return jsonify({
                'id': math_quiz.id,
                'title': math_quiz.title,
                'topic': math_quiz.topic,
                'grade_level': math_quiz.grade_level,
                'time_limit': math_quiz.time_limit,
                'mode': math_quiz.mode,
                'questions': questions,
                'type': 'math'
            }), 200
        
        # Try regular Quiz
        quiz = Quiz.query.get(quiz_id)
        if quiz:
            questions = []
            if quiz.questions_json:
                try:
                    questions = json.loads(quiz.questions_json)
                except Exception as e:
                    logger.error(f"Error parsing quiz questions: {e}")
                    questions = []
            
            return jsonify({
                'id': quiz.id,
                'title': quiz.title,
                'topic': quiz.topic,
                'grade_level': quiz.grade_level,
                'time_limit': quiz.time_limit,
                'mode': quiz.mode,
                'questions': questions,
                'type': 'regular'
            }), 200
        
        # Try GeometryQuiz
        geometry_quiz = GeometryQuiz.query.get(quiz_id)
        if geometry_quiz:
            questions = []
            if geometry_quiz.questions_json:
                try:
                    questions = json.loads(geometry_quiz.questions_json)
                except Exception as e:
                    logger.error(f"Error parsing geometry quiz questions: {e}")
                    questions = []
            
            return jsonify({
                'id': geometry_quiz.id,
                'title': geometry_quiz.title,
                'topic': geometry_quiz.topic,
                'grade_level': geometry_quiz.grade_level,
                'time_limit': geometry_quiz.time_limit,
                'mode': geometry_quiz.mode,
                'questions': questions,
                'type': 'geometry'
            }), 200
        
        logger.warning(f"Quiz not found in any table: {quiz_id}")
        return jsonify({'error': 'Quiz not found'}), 404
        
    except Exception as e:
        logger.error(f"Error fetching quiz embed: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/generate-quiz-feedback', methods=['POST'])
def generate_quiz_feedback():
    try:
        data = request.get_json()
        score = data.get('score', 0)
        total = data.get('total_questions', 1)
        percentage = data.get('percentage', 0)
        topic = data.get('topic', 'this subject')
        
        prompt = f"""Generate encouraging, constructive feedback for a student who scored {score}/{total} ({percentage}%) on a quiz about {topic}.

Keep it:
- Encouraging and positive
- Specific to their performance level
- Actionable with study suggestions
- Brief (2-3 sentences)"""
        
        response = anthropic_client.messages.create(
            model="claude-3-haiku-20240307",
            max_tokens=200,
            messages=[{"role": "user", "content": prompt}]
        )
        
        feedback = response.content[0].text.strip()
        
        return jsonify({'feedback': feedback}), 200
        
    except Exception as e:
        logger.error(f"Feedback generation error: {str(e)}")
        return jsonify({'error': str(e)}), 500

# Updated geometry quiz submission endpoint with better error handling
@app.route('/api/submit-geometry-quiz-score', methods=['POST'])
def submit_geometry_quiz_score_fixed():
    """Submit geometry quiz results with improved database handling"""
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['quiz_id', 'student_name', 'score', 'max_score']
        for field in required_fields:
            if field not in data:
                return jsonify({"error": f"Missing required field: {field}"}), 400
        
        # Ensure database connection is healthy
        if not get_db_connection():
            return jsonify({"error": "Database connection failed"}), 500
        
        # Verify the geometry quiz exists
        try:
            geometry_quiz = GeometryQuiz.query.get(data['quiz_id'])
            if not geometry_quiz:
                return jsonify({"error": "Geometry quiz not found"}), 404
        except Exception as e:
            logging.error(f"Error fetching geometry quiz: {e}")
            # Try to recover the connection
            db.session.rollback()
            geometry_quiz = GeometryQuiz.query.get(data['quiz_id'])
            if not geometry_quiz:
                return jsonify({"error": "Geometry quiz not found"}), 404
        
        # Create geometry quiz submission
        submission_id = str(uuid.uuid4())
        geometry_submission = GeometryQuizSubmission(
            id=submission_id,
            quiz_id=data['quiz_id'],
            student_name=data['student_name'],
            score=float(data['score']),
            max_score=float(data['max_score']),
            answers_json=json.dumps(data.get('answers', {})),
            time_taken=data.get('time_taken', 0)
        )
        
        # Attempt to save with retry logic
        max_save_attempts = 3
        for attempt in range(max_save_attempts):
            try:
                db.session.add(geometry_submission)
                db.session.commit()
                break
            except Exception as save_error:
                logging.error(f"Save attempt {attempt + 1} failed: {save_error}")
                db.session.rollback()
                
                if attempt < max_save_attempts - 1:
                    # Try to refresh the connection
                    try:
                        db.session.remove()
                        db.engine.dispose()
                        # Recreate the submission object
                        geometry_submission = GeometryQuizSubmission(
                            id=submission_id,
                            quiz_id=data['quiz_id'],
                            student_name=data['student_name'],
                            score=float(data['score']),
                            max_score=float(data['max_score']),
                            answers_json=json.dumps(data.get('answers', {})),
                            time_taken=data.get('time_taken', 0)
                        )
                    except Exception as refresh_error:
                        logging.error(f"Connection refresh failed: {refresh_error}")
                else:
                    raise save_error
        
        logger.info(f"Successfully submitted geometry quiz: {submission_id}")
        
        return jsonify({
            "message": "Geometry quiz submitted successfully",
            "submission_id": submission_id,
            "quiz_id": data['quiz_id']
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error submitting geometry quiz: {str(e)}")
        
        # Return a more user-friendly error message
        if "QueuePool" in str(e) or "connection" in str(e).lower():
            return jsonify({
                "error": "Database connection issue. Please try again in a moment."
            }), 503
        else:
            return jsonify({"error": str(e)}), 500


    
    # Enable SQL statement logging for debugging (remove in production)
    # app.config['SQLALCHEMY_ECHO'] = True

# Call this function after creating your Flask app but before creating db
# configure_database_connection()

# Also update your existing geometry quiz scores endpoint
@app.route('/api/geometry-quiz-scores', methods=['GET'])
def get_all_geometry_quiz_scores_fixed():
    """Get geometry quiz scores with improved error handling"""
    try:
        # Ensure database connection
        if not get_db_connection():
            return jsonify({"error": "Database connection failed"}), 500
            
        quiz_id = request.args.get('quiz_id')
        
        # Build query with error handling
        try:
            query = GeometryQuizSubmission.query
            
            # Filter by quiz_id if provided
            if quiz_id:
                query = query.filter_by(quiz_id=quiz_id)
            
            # Get all geometry quiz submissions
            submissions = query.order_by(GeometryQuizSubmission.submitted_at.desc()).all()
            
        except Exception as query_error:
            logging.error(f"Query error: {query_error}")
            # Try to recover
            db.session.rollback()
            db.session.remove()
            
            # Retry query
            query = GeometryQuizSubmission.query
            if quiz_id:
                query = query.filter_by(quiz_id=quiz_id)
            submissions = query.order_by(GeometryQuizSubmission.submitted_at.desc()).all()
        
        # Format the submissions
        formatted_scores = []
        for submission in submissions:
            answers_data = {}
            if submission.answers_json:
                try:
                    answers_data = json.loads(submission.answers_json)
                except:
                    answers_data = {}
            
            formatted_scores.append({
                "id": submission.id,
                "quiz_id": submission.quiz_id,
                "student_name": submission.student_name,
                "score": submission.score,
                "max_score": submission.max_score,
                "percentage": round((submission.score / submission.max_score * 100) if submission.max_score > 0 else 0, 1),
                "time_taken": submission.time_taken,
                "submitted_at": submission.submitted_at.isoformat(),
                "created_at": submission.submitted_at.isoformat(),  # Alias for compatibility
                "answers": answers_data
            })
        
        logger.info(f"Found {len(formatted_scores)} geometry quiz scores")
        
        return jsonify({
            "scores": formatted_scores,
            "total": len(formatted_scores)
        }), 200
        
    except Exception as e:
        logger.error(f"Error fetching geometry quiz scores: {str(e)}")
        if "QueuePool" in str(e) or "connection" in str(e).lower():
            return jsonify({
                "error": "Database connection issue. Please try again."
            }), 503
        return jsonify({"error": str(e)}), 500

# Health check endpoint to test database connectivity
@app.route('/api/health/database', methods=['GET'])
def check_database_health():
    """Check database connection health"""
    try:
        # Simple query to test connection
        result = db.session.execute(text("SELECT 1 as test")).fetchone()
        if result and result[0] == 1:
            return jsonify({
                "status": "healthy",
                "database": "connected",
                "timestamp": datetime.utcnow().isoformat()
            }), 200
        else:
            return jsonify({
                "status": "unhealthy",
                "database": "query_failed"
            }), 503
    except Exception as e:
        logging.error(f"Database health check failed: {e}")
        return jsonify({
            "status": "unhealthy",
            "database": "disconnected",
            "error": str(e)
        }), 503
    
@app.route('/user/quizzes')
@token_required
def get_user_quizzes(current_user):
    """Get all quizzes created by the user"""
    try:
        quizzes = Quiz.query.filter_by(user_id=current_user.id).order_by(Quiz.created_at.desc()).all()
        return jsonify({
            'quizzes': [{
                'id': quiz.id,
                'title': quiz.title,
                'topic': quiz.topic,
                'grade_level': quiz.grade_level,
                'time_limit': quiz.time_limit,
                'mode': quiz.mode,
                'created_at': quiz.created_at.isoformat()
            } for quiz in quizzes]
        })
    except Exception as e:
        logger.error(f"Error fetching user quizzes: {str(e)}")
        return jsonify({'error': 'Failed to fetch quizzes'}), 500

# Verify database connectivity within application context
def init_db():
    with app.app_context():
        try:
            from sqlalchemy import text
            db.session.execute(text("SELECT 1")).fetchone()
            logger.info("âœ… Database connectivity verified - use migrations to create tables")
        except Exception as e:
            logger.warning(f"âš ï¸ Database connectivity check failed: {str(e)} - App will start anyway")
            # Don't raise - let the app start even if DB is not ready yet


@app.route('/api/forgot-password', methods=['POST'])
def forgot_password():
    """Handle forgot password requests and send reset email"""
    try:
        data = request.get_json()
        email = data.get('email')
        
        if not email:
            return jsonify({'error': 'Email is required'}), 400
            
        # Find the user with this email
        user = User.query.filter_by(email=email).first()
        if not user:
            # For security reasons, still return success even if user doesn't exist
            # This prevents email enumeration attacks
            return jsonify({
                'message': 'If your email is registered, you will receive a password reset link'
            }), 200
            
        # Generate reset token
        reset_token = secrets.token_urlsafe(32)
        token_expiry = datetime.utcnow() + timedelta(hours=1)  # Token valid for 1 hour
        
        # Store token in user record
        user.reset_token = reset_token
        user.reset_token_expires = token_expiry
        db.session.commit()
        
        # Send password reset email
        send_password_reset_email(user.email, reset_token)
        
        return jsonify({
            'message': 'If your email is registered, you will receive a password reset link'
        }), 200
        
    except Exception as e:
        logger.error(f"Forgot password error: {str(e)}")
        db.session.rollback()
        return jsonify({'error': 'Failed to process request'}), 500
        
def send_password_reset_email(user_email, token):
    """Send password reset email with token"""
    reset_url = f"{request.host_url.rstrip('/')}/reset-password/{token}"
    
    msg = MailMessage(
        'Reset Your Decipher Learning Password',
        sender=app.config['MAIL_DEFAULT_SENDER'],
        recipients=[user_email]
    )
    
    msg.body = f"""
    Hello,
    
    We received a request to reset your Decipher Learning Platform password.
    
    To reset your password, please click the link below:
    
    {reset_url}
    
    This link will expire in 1 hour.
    
    If you didn't request a password reset, you can safely ignore this email.
    
    Best regards,
    The Decipher Learning Team
    """
    
    msg.html = f"""
    <p>Hello,</p>
    <p>We received a request to reset your Decipher Learning Platform password.</p>
    <p>To reset your password, please click the button below:</p>
    <p><a href="{reset_url}" style="display: inline-block; padding: 10px 20px; background-color: #4F46E5; color: white; text-decoration: none; border-radius: 5px;">Reset My Password</a></p>
    <p>This link will expire in 1 hour.</p>
    <p>If you didn't request a password reset, you can safely ignore this email.</p>
    <p>Best regards,<br>The Decipher Learning Team</p>
    """
    
    mail.send(msg)

@app.route('/reset-password/<token>', methods=['GET'])
def reset_password_form(token):
    """Show password reset form"""
    # Check if token is valid
    user = User.query.filter_by(reset_token=token).first()
    
    if not user or not user.reset_token_expires or user.reset_token_expires < datetime.utcnow():
        return "Invalid or expired reset link. Please request a new password reset.", 400
    
    # Return HTML form for password reset
    return f"""
    <html>
    <head>
        <title>Reset Password</title>
        <style>
            body {{ font-family: Arial, sans-serif; text-align: center; padding: 50px; background-color: #f0f4f8; }}
            .container {{ max-width: 500px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.1); }}
            h1 {{ color: #4F46E5; }}
            .form-group {{ margin-bottom: 20px; text-align: left; }}
            label {{ display: block; margin-bottom: 8px; font-weight: 600; }}
            input {{ width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; box-sizing: border-box; }}
            .submit-btn {{ display: inline-block; padding: 12px 20px; background-color: #4F46E5; color: white; border: none; border-radius: 5px; font-size: 16px; cursor: pointer; }}
            .error-message {{ color: #EF4444; margin-top: 10px; display: none; }}
            .success-message {{ color: #10B981; margin-top: 10px; display: none; }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Reset Your Password</h1>
            <p>Please enter a new password for your account.</p>
            
            <form id="resetForm">
                <input type="hidden" id="token" value="{token}">
                
                <div class="form-group">
                    <label for="password">New Password</label>
                    <input type="password" id="password" required>
                </div>
                
                <div class="form-group">
                    <label for="confirmPassword">Confirm New Password</label>
                    <input type="password" id="confirmPassword" required>
                </div>
                
                <div id="errorMessage" class="error-message"></div>
                <div id="successMessage" class="success-message"></div>
                
                <button type="submit" class="submit-btn">Reset Password</button>
            </form>
        </div>
        
        <script>
            document.getElementById('resetForm').addEventListener('submit', async function(e) {{
                e.preventDefault();
                
                const token = document.getElementById('token').value;
                const password = document.getElementById('password').value;
                const confirmPassword = document.getElementById('confirmPassword').value;
                const errorMessage = document.getElementById('errorMessage');
                const successMessage = document.getElementById('successMessage');
                
                // Clear previous messages
                errorMessage.style.display = 'none';
                successMessage.style.display = 'none';
                
                // Validate passwords match
                if (password !== confirmPassword) {{
                    errorMessage.textContent = 'Passwords do not match';
                    errorMessage.style.display = 'block';
                    return;
                }}
                
                // Validate password strength (at least 8 characters)
                if (password.length < 8) {{
                    errorMessage.textContent = 'Password must be at least 8 characters long';
                    errorMessage.style.display = 'block';
                    return;
                }}
                
                try {{
                    const response = await fetch('/api/reset-password', {{
                        method: 'POST',
                        headers: {{
                            'Content-Type': 'application/json'
                        }},
                        body: JSON.stringify({{ token, password }})
                    }});
                    
                    const data = await response.json();
                    
                    if (response.ok) {{
                        successMessage.textContent = data.message || 'Password reset successful! You can now log in with your new password.';
                        successMessage.style.display = 'block';
                        
                        // Disable form
                        document.querySelectorAll('input, button').forEach(el => el.disabled = true);
                        
                        // Redirect to login page after 3 seconds
                        setTimeout(() => {{
                            window.location.href = '/index.html';
                        }}, 3000);
                    }} else {{
                        errorMessage.textContent = data.error || 'Failed to reset password';
                        errorMessage.style.display = 'block';
                    }}
                }} catch (error) {{
                    errorMessage.textContent = 'An error occurred. Please try again.';
                    errorMessage.style.display = 'block';
                }}
            }});
        </script>
    </body>
    </html>
    """
@app.route('/api/generate-word-rush', methods=['POST'])
@token_required
def generate_word_rush(current_user):
    data = request.get_json()
    topic = data.get('topic')
    grade_level = data.get('gradeLevel')
    
    # Initialize generator
    generator = WordRushGenerator(claude_api_key=app.config.get('CLAUDE_API_KEY'))
    
    # Run generator in asyncio event loop
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    
    try:
        # Generate game data
        game_data = loop.run_until_complete(generator.generate_game(topic, grade_level))
        
        # Generate HTML
        game_html = generator.generate_game_html(game_data)
        
        return jsonify({
            'success': True,
            'game_data': game_data,
            'game_html': game_html
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500
    finally:
        loop.close()
        
@app.route('/api/reset-password', methods=['POST'])
def reset_password():
    """Process password reset request"""
    try:
        data = request.get_json()
        token = data.get('token')
        password = data.get('password')
        
        if not token or not password:
            return jsonify({'error': 'Token and password are required'}), 400
            
        # Find user with this token
        user = User.query.filter_by(reset_token=token).first()
        
        if not user or not user.reset_token_expires or user.reset_token_expires < datetime.utcnow():
            return jsonify({'error': 'Invalid or expired token'}), 400
            
        # Update password
        user.password_hash = generate_password_hash(password)
        
        # Clear reset token
        user.reset_token = None
        user.reset_token_expires = None
        
        db.session.commit()
        
        return jsonify({
            'message': 'Password reset successful. You can now log in with your new password.'
        }), 200
        
    except Exception as e:
        logger.error(f"Password reset error: {str(e)}")
        db.session.rollback()
        return jsonify({'error': 'Failed to reset password'}), 500

@app.route('/')
def index():
    return send_from_directory('.', 'index.html')

@app.errorhandler(Exception)
def handle_exception(e):
    # Don't catch HTTP exceptions (like 404, 405, etc.) - let them be handled by their specific handlers
    from werkzeug.exceptions import HTTPException
    if isinstance(e, HTTPException):
        return e

    app.logger.error(f"Unhandled exception: {str(e)}")
    return jsonify({
        'error': 'Internal server error',
        'message': str(e)
    }), 500

@app.route('/welcome.html')
def serve_welcome():
    return send_from_directory('.', 'welcome.html')
 
@app.route('/quiz-login')
def serve_quizlogin():
    return send_from_directory('.', 'quiz-login.html')

@app.route('/dashboard.html')
def serve_dashboard():
    return send_from_directory('.', 'dashboard.html')

@app.route('/test-renderer')
def serve_testrenderer():
    return send_from_directory('.', 'test-renderer.html')

@app.route('/profile.html') 
def serve_profile():
    return send_from_directory('.', 'profile.html')

@app.route('/quiz-mas')
def serve_quizmas():
    return send_from_directory('.', 'quiz-mas.html')    

@app.route('/quizmas-admin')
def serve_quizmasad():
    return send_from_directory('.', 'quizmas-admin.html') 

@app.route('/quiz-management-dashboard.html')
def serve_management():
    return send_from_directory('.', 'quiz-management-dashboard.html')    

@app.route('/performance.html')
def serve_performance():
    return send_from_directory('.', 'performance.html')

@app.route('/api/submit-feedback', methods=['POST'])
def submit_feedback():
    if not request.form:
        return jsonify({'error': 'Invalid request'}), 400
    
    try:
        player_name = request.form.get('player_name')
        player_email = request.form.get('player_email')
        final_score = request.form.get('final_score')
        rating = request.form.get('rating')
        favorite_stage = request.form.get('favorite_stage')
        feedback = request.form.get('feedback')
        
        if not all([player_name, player_email, final_score, rating, favorite_stage, feedback]):
            return jsonify({'error': 'Missing required fields'}), 400
        
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            'INSERT INTO game_feedback (player_name, player_email, final_score, rating, favorite_stage, feedback) VALUES (?, ?, ?, ?, ?, ?)',
            (player_name, player_email, final_score, rating, favorite_stage, feedback)
        )
        conn.commit()
        conn.close()
        return jsonify({'success': True}), 201
    except Exception as e:
        return jsonify({'error': str(e)}), 500


# Parent Feedback API Endpoint
@app.route('/api/parent-feedback', methods=['POST', 'OPTIONS'])
def submit_parent_feedback():
    """Handle parent feedback form submissions for lesson reviews"""

    # Handle CORS preflight
    if request.method == 'OPTIONS':
        response = jsonify({'status': 'ok'})
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type')
        response.headers.add('Access-Control-Allow-Methods', 'POST')
        return response

    try:
        data = request.get_json()

        if not data:
            return jsonify({'error': 'No data provided'}), 400

        # Validate required fields
        rating = data.get('rating')
        if not rating:
            return jsonify({'error': 'Rating is required'}), 400

        # Create new parent feedback record
        feedback = ParentFeedback(
            student_id=data.get('studentId'),
            tutor_id=data.get('tutorId'),
            lesson_id=data.get('lessonId'),
            student_name=data.get('studentName'),
            tutor_name=data.get('tutorName'),
            subject=data.get('subject'),
            lesson_date=data.get('lessonDate'),
            rating=rating,
            positive_comments=json.dumps(data.get('positiveComments', [])),
            negative_comments=json.dumps(data.get('negativeComments', [])),
            additional_comments=data.get('additionalComments', ''),
            submitted_at=datetime.utcnow()
        )

        db.session.add(feedback)
        db.session.commit()

        logger.info(f"Parent feedback submitted successfully: {feedback.id}")

        return jsonify({
            'success': True,
            'message': 'Feedback submitted successfully',
            'feedback_id': feedback.id
        }), 201

    except Exception as e:
        db.session.rollback()
        logger.error(f"Error submitting parent feedback: {str(e)}")
        return jsonify({'error': 'Failed to submit feedback', 'details': str(e)}), 500


@app.route('/api/parent-feedback/list', methods=['GET'])
def get_parent_feedback_list():
    """Get list of parent feedback (for admin dashboard)"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        tutor_id = request.args.get('tutor_id')
        student_id = request.args.get('student_id')

        query = ParentFeedback.query

        if tutor_id:
            query = query.filter(ParentFeedback.tutor_id == tutor_id)
        if student_id:
            query = query.filter(ParentFeedback.student_id == student_id)

        query = query.order_by(ParentFeedback.submitted_at.desc())

        pagination = query.paginate(page=page, per_page=per_page, error_out=False)

        return jsonify({
            'success': True,
            'feedback': [f.to_dict() for f in pagination.items],
            'total': pagination.total,
            'pages': pagination.pages,
            'current_page': page
        }), 200

    except Exception as e:
        logger.error(f"Error fetching parent feedback: {str(e)}")
        return jsonify({'error': 'Failed to fetch feedback', 'details': str(e)}), 500


# Serve parent feedback form page
@app.route('/parent-feedbacks')
def serve_parent_feedback():
    return render_template('tutoring/parent-feedback.html')

@app.route('/parent-feedback')
def serve_parentfeed():
    return send_from_directory('.', 'parent-feedback.html') 

@app.route('/anagram')
def serve_Anagram():
    return send_from_directory('.', 'anagram.html')  

@app.route('/explanation.html')
def serve_explanation():
    return send_from_directory('.', 'explanation.html')        

@app.route('/course-landing-page.html')
def serve_landingpage():
    return send_from_directory('.', 'course-landing-page.html')  

@app.route('/digital-course.html')
def serve_digitalcourse():
    return send_from_directory('.', 'digital-course.html')  

@app.route('/launch.html')
def serve_launch():
    return send_from_directory('.', 'launch.html')  

@app.route('/course-details.html')
def serve_coursedetails():
    return send_from_directory('.', 'course-details.html')  

@app.route('/template.html')
def serve_coursetemplate():
    return send_from_directory('.', 'template.html')  

@app.route('/Maths-plan')
def serve_mathsplan():
    return send_from_directory('.', 'Maths-plan.html')  

@app.route('/interview-questions.html')
def serve_interviewquestions():
    return send_from_directory('.', 'interview-questions.html')  

@app.route('/linkedIn-guide.html')
def serve_linkedIn():
    return send_from_directory('.', 'linkedIn-guide.html') 

@app.route('/resume-guide.html')
def serve_resumeguide():
    return send_from_directory('.', 'resume-guide.html')

@app.route('/test-graph.html')
def serve_testgraph():
    return send_from_directory('.', 'test-graph.html')

@app.route('/biology')
def serve_biology():
    return send_from_directory('Academy', 'biology.html')

@app.route('/written')
def serve_written():
    return send_from_directory('Academy', 'written.html')

@app.route('/valentine')
def serve_valentine():
    return send_from_directory('', 'valentine.html')

@app.route('/valearntine')
def serve_valearntine():
    return send_from_directory('', 'valearntine.html')

@app.route('/games')
def serve_games():
    return send_from_directory('Academy', 'games.html') 

@app.route('/mathgame')
def serve_mgame():
    return send_from_directory('Academy', 'mathgame.html') 

@app.route('/scigame')
def serve_scigame():
    return send_from_directory('Academy', 'scigame.html') 

@app.route('/engame')
def serve_engame():
    return send_from_directory('Academy', 'engame.html') 

@app.route('/webinar')
def serve_webinar():
    return send_from_directory('', 'webinar.html') 

@app.route('/d-tutor')
def serve_dtutor():
    return send_from_directory('', 'd-tutor.html') 

@app.route('/tutor-signup')
def serve_tutorsignup():
    return send_from_directory('', 'tutor-signup.html')

@app.route('/tutor-admin')
def serve_tutoradmin():
    return send_from_directory('', 'tutor-admin.html')

@app.route('/company-reg')
def serve_companyreg():
    return send_from_directory('', 'company-reg.html')

@app.route('/tutor-profile')
def serve_tutorprofile():
    return send_from_directory('', 'tutor-profile.html')

@app.route('/tutor-test')
def serve_tutortst():
    return send_from_directory('', 'tutor-test.html')

@app.route('/tutor-admin-login')
def serve_tutoradminlogin():
    return send_from_directory('', 'tutor-admin-login.html')

@app.route('/biogame')
def serve_biogame():
    return send_from_directory('Academy', 'biogame.html') 

@app.route('/chemgame')
def serve_chemgame():
    return send_from_directory('Academy', 'chemgame.html') 


@app.route('/phygame')
def serve_phygame():
    return send_from_directory('Academy', 'phygame.html') 

@app.route('/game')
def serve_gam():
    return send_from_directory('Academy', 'game.html')    

@app.route('/game2')
def serve_game2():
    return send_from_directory('Academy', 'game2.html')  

@app.route('/game<int:game_number>')
def serve_game(game_number):
    filename = f'game{game_number}.html'
    file_path = os.path.join('Academy', filename)
    
    if os.path.exists(file_path):
        return send_from_directory('Academy', filename)
    return "Game not found", 404

@app.route('/static/<path:filename>')
def static_files(filename):
    return send_from_directory('static', filename)

@app.route('/templates/<path:filename>')
def templates_files(filename):
    return send_from_directory('templates', filename)

@app.route('/stories')
def serve_stories():
    return send_from_directory('Academy', 'stories.html') 

@app.route('/writing')
def serve_writing():
    return send_from_directory('Academy', 'writing.html') 

@app.route('/workshop-login')
def serve_workshoplogin():
    return send_from_directory('', 'workshop-login.html') 

@app.route('/enstory')
def serve_enstory():
    return send_from_directory('Academy', 'enstory.html') 

@app.route('/mastory')
def serve_mastory():
    return send_from_directory('Academy', 'mastory.html') 

@app.route('/scstory')
def serve_scstory():
    return send_from_directory('Academy', 'scstory.html') 

@app.route('/story1')
def serve_story1():
    return send_from_directory('Academy', 'story1.html')  

@app.route('/story2')
def serve_story2():
    return send_from_directory('Academy', 'story2.html')

@app.route('/story3')
def serve_story3():
    return send_from_directory('Academy', 'story3.html')

@app.route('/story4')
def serve_story4():
    return send_from_directory('Academy', 'story4.html')

@app.route('/story5')
def serve_story5():
    return send_from_directory('Academy', 'story5.html')

@app.route('/infographics')
def serve_infographics():
    return send_from_directory('Academy', 'infographics.html')

# Remove the generic /<filename> routes and replace with:
@app.route('/val/<filename>')
def serve_Val(filename):
    if not filename.endswith('.html'):
        filename += '.html'
    return send_from_directory('Val', filename)

@app.route('/affiliate/<filename>')
def serve_affiliate(filename):
    if not filename.endswith('.html'):
        filename += '.html'
    return send_from_directory('affiliate', filename)

@app.route('/<filename>')  # Keep  this one for grade-tasks
def serve_gradetasks(filename):
    if not filename.endswith('.html'):
        filename += '.html'
    return send_from_directory('grade-tasks', filename)

@app.route('/page/<page_name>')
def serve_template(page_name):
    try:
        return render_template(f'{page_name}.html')
    except:
        return "Page not found", 404
    
@app.route('/summer')
def serve_summer():
    return send_from_directory('Academy', 'summer.html')

@app.route('/sales-value')
def serve_salesvalue():
    return send_from_directory('Academy', 'sales-value.html')

@app.route('/student-login') 
def serve_student():
    return send_from_directory('', 'student-login.html')

@app.route('/catalogue-view') 
def serve_coachcatalogue():
    return send_from_directory('', 'catalogue-view.html')

@app.route('/index.html') 
def serve_indexx():
    return send_from_directory('', 'index.html')

@app.route('/view-lesson') 
def serve_viewlesson():
    return send_from_directory('', 'view-lesson.html')

# Remove the generic /<filename> routes and replace with:
@app.route('/Skills/<filename>')
def serve_Skill(filename):
    if not filename.endswith('.html'):
        filename += '.html'
    return send_from_directory('Skills', filename)

@app.route('/quiz.html') 
def serve_quiz():
    return send_from_directory('', 'quiz.html')

@app.route('/a-card')
def serve_acard():
    return send_from_directory('', 'a-card.html')

@app.route('/sm-page')
def serve_smpage():
    return send_from_directory('', 'sm-page.html')

@app.route('/scores.html') 
def serve_scores():
    return send_from_directory('', 'scores.html')

@app.route('/lesson-plan') 
def serve_lessonplan():
    return send_from_directory('', 'lesson-plan.html')

@app.route('/parent-login') 
def serve_parentlogin():
    return send_from_directory('', 'parent-login.html')

@app.route('/role-user') 
def serve_roleuser():
    return send_from_directory('', 'role-user.html')

@app.route('/school-login') 
def serve_schoollogin():
    return send_from_directory('', 'school-login.html')

@app.route('/quiz-creator') 
def serve_quizcreator():
    return send_from_directory('', 'quiz-creator.html')

@app.route('/geometry-creator') 
def serve_geometry():
    return send_from_directory('', 'geometry-creator.html')

@app.route('/maths-creator') 
def serve_mathsgraph():
    return send_from_directory('', 'maths-creator.html')

@app.route('/homework-help')
def serve_homework():
    return send_from_directory('', 'homework-help.html')

@app.route('/learn-and-earn')
def serve_learn_earn():
    return send_from_directory('', 'learn-and-earn.html')

@app.route('/my-subjects')
def serve_mysubject():
    return send_from_directory('', 'my-subjects.html')

@app.route('/ai-admin-control')
def serve_ai_admin_control():
    return send_from_directory('', 'ai-admin-control.html')

@app.route('/webinarfeedback')
def serve_webfeed():
    return send_from_directory('', 'webinarfeedback.html')

@app.route('/admin-login')
def serve_adminlog():
    return send_from_directory('', 'admin-login.html')

@app.route('/student-reward')
def serve_studentrewards():
    return send_from_directory('', 'student-reward.html')

@app.route('/super-admin')
def serve_superadmin():
    return send_from_directory('', 'super-admin.html')

@app.route('/math-edit')
def serve_mathedit():
    return send_from_directory('', 'math-edit.html')

@app.route('/admin')
def serve_admins():
    return send_from_directory('', 'admin.html')

@app.route('/coach-portal')
def serve_coachportal():
    return send_from_directory('', 'coach-portal.html')

@app.route('/indexpage')
def serve_indexpage():
    return send_from_directory('', 'indexpage.html')

@app.route('/product-price')
def serve_prprice():
    return send_from_directory('', 'product-price.html')

@app.route('/task')
def serve_task():
    return send_from_directory('', 'task.html')

@app.route('/subject-task')
def serve_subject_task():
    return send_from_directory('', 'subject-task.html')

@app.route('/story-panel')
def serve_spanel():
    return send_from_directory('', 'story-panel.html')

@app.route('/class-storymode')
def serve_classstorymode():
    return send_from_directory('', 'class-storymode.html')

@app.route('/game-collection')
def serve_gamecollection():
    return send_from_directory('Academy', 'game-collection.html')

@app.route('/ve-page')
def serve_vepage():
    return send_from_directory('', 've-page.html')
    
@app.route('/student-worksheet')
def serve_worksheet():
    return send_from_directory('', 'student-worksheet.html')

@app.route('/worksheet-task-tracker.js')
def serve_worksheet_task_tracker():
    return send_from_directory('.', 'worksheet-task-tracker.js')

@app.route('/create-worksheet')
def serve_cw():
    return send_from_directory('', 'create-worksheet.html')

@app.route('/existing-worksheets')
def serve_existing_worksheets():
    return send_from_directory('', 'existing-worksheets.html')

@app.route('/feedback-audio/<path:filename>')
def serve_feedback_audio(filename):
    return send_from_directory('feedback-audio', filename)

@app.route('/customer-support')
def serve_customrsupport():
    return send_from_directory('', 'customer-support.html')

@app.route('/support-dashboard')
def serve_support_dashboard():
    return send_from_directory('', 'support-dashboard.html')

@app.route('/resource')
def serve_resource():
    return send_from_directory('', 'resource.html')

@app.route('/programs')
def serve_programs():
    return send_from_directory('', 'programs.html')

@app.route('/event')
def serve_events():
    return send_from_directory('', 'event.html')

@app.route('/tools')
def serve_tools(): 
    return send_from_directory('', 'tools.html')

@app.route('/stem')
def serve_stem():
    return send_from_directory('', 'stem.html')

@app.route('/digital-library')
def serve_digitallibrary():
    return send_from_directory('', 'digital-library.html')

@app.route('/teacher-tools')
def serve_teachertools():
    return send_from_directory('', 'teacher-tools.html')

@app.route('/start-course')
def serve_startcourse():
    return send_from_directory('', 'start-course.html')

@app.route('/library')
def serve_library():
    return send_from_directory('', 'library.html')

@app.route('/discover')
def serve_discover():
    return send_from_directory('', 'discover.html')

@app.route('/booking-form')
def serve_bookingform():
    return send_from_directory('', 'booking-form.html')

@app.route('/booking-confirmation')
def serve_bookingconfirmation():
    return send_from_directory('', 'booking-confirmation.html')

@app.route('/leave-review')
def serve_leavereview():
    return send_from_directory('', 'leave-review.html')

@app.route('/find-tutoring')
def serve_findtutoring():
    return send_from_directory('', 'find-tutoring.html')

@app.route('/onboard')
def serve_onboard():
    return send_from_directory('', 'onboard.html')

@app.route('/subjects')
def serve_subjects():
    return send_from_directory('', 'subjects.html')

@app.route('/student-dashboard')
def serve_studentdash():
    return send_from_directory('', 'student-dashboard.html') 

@app.route('/student-account')
def serve_studentaccount():
    return send_from_directory('', 'student-account.html')
    
@app.route('/cover-letters.html')
def serve_coverletters():
    return send_from_directory('.', 'cover-letters.html')  

@app.route('/job-bundle.html')
def serve_jobbundle():
    return send_from_directory('.', 'job-bundle.html')    

@app.route('/maths-notation.html')
def serve_notation():
    return send_from_directory('.', 'maths-notation.html')  

@app.route('/mathsquiz-creator.html')
def serve_mathsquiz():
    return send_from_directory('.', 'mathsquiz-creator.html') 

@app.route('/scoreboard')
def serve_scoreboard():
    return send_from_directory('.', 'scoreboard.html') 

@app.route('/super-login')
def serve_superlogin():
    return send_from_directory('.', 'super-login.html') 

@app.route('/s.m-course-page.html')
def serve_smcourse():
    return send_from_directory('.', 's.m-course-page.html')

@app.route('/geometry-test')
def serve_geometrytest():
    return send_from_directory('.', 'geometry-test.html')

@app.route('/svid1.html')
def serve_svid1():
    return send_from_directory('.', 'svid1.html')

@app.route('/Geometry-creator.html')
def serve_Geometry():
    return send_from_directory('.', 'Geometry-creator.html') 

@app.route('/onboarding.html')
def serve_onboarding():
    return send_from_directory('.', 'onboarding.html')

@app.route('/onboarding/<path:filename>')
def serve_onboarding_assets(filename):
    return send_from_directory('onboarding', filename)

# Create anagram game table in database
# For newer Flask versions
@app.before_request
def create_anagram_table():
    """
    OPTIMIZED: Check flag first before any operations to avoid overhead on every request.
    This should ideally be moved to app startup instead of before_request.
    """
    # Quick check to avoid any operations on subsequent requests
    if app.config.get('ANAGRAM_TABLE_CREATED', False):
        return

    # Only run on first request
    try:
        conn = get_db_connection()
        if conn:
            cursor = conn.cursor()
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS anagram_scores (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    email TEXT NOT NULL,
                    score INTEGER NOT NULL,
                    date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            conn.commit()
            conn.close()
            app.config['ANAGRAM_TABLE_CREATED'] = True
            logger.info('âœ… Anagram table created successfully')
    except Exception as e:
        logger.error(f'âŒ Failed to create anagram table: {e}')
        # Set flag to avoid retrying on every request
        app.config['ANAGRAM_TABLE_CREATED'] = True



# API endpoint to submit a score
@app.route('/api/anagram-game/submit-score', methods=['POST'])
def submit_anagram_score():
    if not request.json:
        return jsonify({'error': 'Invalid request'}), 400
    
    data = request.json
    name = data.get('name')
    email = data.get('email')
    score = data.get('score')
    
    if not name or not email or score is None:
        return jsonify({'error': 'Missing required fields'}), 400
    
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            'INSERT INTO anagram_scores (name, email, score) VALUES (?, ?, ?)',
            (name, email, score)
        )
        conn.commit()
        conn.close()
        return jsonify({'success': True}), 201
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# API endpoint to get all scores
@app.route('/api/anagram-game/scores', methods=['GET'])
def get_anagram_scores():
    try:
        conn = get_db_connection()
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        cursor.execute('SELECT name, score, date FROM anagram_scores ORDER BY score DESC')
        scores = [dict(row) for row in cursor.fetchall()]
        conn.close()
        return jsonify(scores), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

def get_db_connection():
    conn = sqlite3.connect('database.db')  # or whatever your database file is named
    conn.row_factory = sqlite3.Row
    return conn


@app.route('/<filename>')
def serve_static_files(filename):
    print(f"=== STATIC FILE REQUEST ===")
    print(f"Requested filename: {filename}")
    print(f"Current working directory: {os.getcwd()}")
    
    if filename.endswith(('.png', '.jpg', '.jpeg', '.gif', '.svg')):
        file_path = os.path.join('Academy', filename)
        abs_path = os.path.abspath(file_path)
        
        print(f"Looking for file at: {file_path}")
        print(f"Absolute path: {abs_path}")
        print(f"File exists: {os.path.exists(file_path)}")
        
        # List all files in Academy directory
        try:
            files_in_academy = os.listdir('Academy')
            print(f"Files in Academy directory: {files_in_academy}")
        except Exception as e:
            print(f"Error listing Academy directory: {e}")
        
        if os.path.exists(file_path):
            print(f"SUCCESS: Serving {filename}")
            return send_from_directory('Academy', filename)
        else:
            print(f"FAILED: File not found")
            return f"File not found: {file_path}", 404
    
    print(f"Not an image file: {filename}")
    return "Not found", 404

if __name__ == "__main__":
    with app.app_context():
        # Verify database connectivity (tables must already exist)
        try:
            from sqlalchemy import text
            db.session.execute(text("SELECT 1")).fetchone()
            logger.info("âœ“ Database connection verified - tables must exist")
        except Exception as e:
            logger.error(f"Database connectivity error: {str(e)}")
    app.run(debug=True)    
if __name__ == '__main__':
    # Initialize databa setables 
    init_db()
    
    # Run the application
    port = int(os.getenv('PORT', 8080))
    app.run(host='0.0.0.0', port=port, debug=True)

# Verify database connectivity on startup - Add this at the END of app.py
if __name__ != '__main__':
    try:
        with app.app_context():
            from sqlalchemy import text
            db.session.execute(text("SELECT 1")).fetchone()
            logger.info("âœ“ Database connection verified - tables must exist")
    except Exception as e:
        logger.warning(f"âš ï¸ Database connectivity check failed: {e} - Will retry on first request")    
# ==================== VIDEO EDITING ENDPOINTS ====================
# Video Editing Student Endpoints (mirroring Social Media structure)

@app.route('/api/video-editing/auth/login', methods=['POST'])
def video_editing_student_login():
    """
    Video editing student login endpoint
    Expects: { "username": "user@decipher.com", "password": "password" }
    """
    try:
        data = request.get_json()
        if not data or 'username' not in data or 'password' not in data:
            return jsonify({'error': 'Missing username or password'}), 400
        
        username = data.get('username').strip().lower()
        password = data.get('password')
        
        # Find student by username
        student = SocialMediaStudent.query.filter(
            db.func.lower(SocialMediaStudent.username) == username
        ).first()
        
        if not student:
            logger.warning(f"âŒ Login failed: Student not found - {username}")
            return jsonify({'error': 'Invalid credentials'}), 401
        
        # Verify password
        if not student.check_password(password):
            logger.warning(f"âŒ Login failed: Wrong password for {username}")
            return jsonify({'error': 'Invalid credentials'}), 401
        
        # Verify student is video editing category
        if student.category != 'video-editing':
            logger.warning(f"âŒ Login failed: Student {username} is not video-editing category")
            return jsonify({'error': 'Invalid credentials'}), 401
        
        # Update last login
        student.last_login = datetime.utcnow()
        db.session.commit()
        
        # Generate JWT token
        token_data = {
            'student_id': student.id,
            'username': student.username,
            'email': student.email,
            'exp': datetime.utcnow() + timedelta(days=7),
            'student_type': 'video_editing'
        }
        token = jwt.encode(token_data, JWT_SECRET_KEY, algorithm='HS256')
        
        logger.info(f"âœ… Video editing student login successful: {student.full_name}")
        
        return jsonify({
            'success': True,
            'token': token,
            'student': {
                'id': student.id,
                'username': student.username,
                'full_name': student.full_name,
                'email': student.email,
                'category': student.category
            }
        }), 200
        
    except Exception as e:
        logger.error(f"âŒ Video editing login error: {str(e)}")
        return jsonify({'error': 'Login failed'}), 500


@app.route('/api/video-editing/auth/verify', methods=['GET'])
def verify_video_editing_token():
    """Verify JWT token for video editing student"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No valid token provided'}), 401
        
        token = auth_header.split(' ')[1]
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
        
        # Verify student exists and is video editing
        student = SocialMediaStudent.query.get(payload['student_id'])
        if not student or student.category != 'video-editing':
            return jsonify({'error': 'Invalid token'}), 401
        
        return jsonify({'success': True, 'valid': True}), 200
        
    except jwt.ExpiredSignatureError:
        return jsonify({'error': 'Token expired'}), 401
    except Exception as e:
        logger.error(f"Token verification error: {str(e)}")
        return jsonify({'error': 'Invalid token'}), 401


@app.route('/api/video-editing/student/dashboard', methods=['GET'])
def get_video_editing_dashboard():
    """Get dashboard data for video editing student"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header:
            return jsonify({'error': 'No authorization header'}), 401
        
        token = auth_header.split(' ')[1]
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
        student_id = payload.get('student_id')
        
        student = SocialMediaStudent.query.get(student_id)
        if not student or student.category != 'video-editing':
            return jsonify({'error': 'Student not found'}), 404
        
        tasks = SocialMediaTask.query.filter_by(
            student_id=student_id,
            task_type='video-editing'
        ).all()
        
        total_tasks = len(tasks)
        pending_tasks = len([t for t in tasks if t.status == 'pending'])
        completed_tasks = len([t for t in tasks if t.status == 'completed'])
        total_points = sum(t.points_reward for t in tasks if t.status == 'completed')
        
        return jsonify({
            'success': True,
            'statistics': {
                'total_tasks': total_tasks,
                'pending_tasks': pending_tasks,
                'completed_tasks': completed_tasks,
                'total_points': total_points
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Dashboard error: {str(e)}")
        return jsonify({'error': 'Failed to load dashboard'}), 500


@app.route('/api/video-editing/student/tasks', methods=['GET'])
def get_video_editing_student_tasks():
    """Get all tasks for video editing student"""
    try:
        auth_header = request.headers.get('Authorization')
        token = auth_header.split(' ')[1]
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
        student_id = payload.get('student_id')
        
        tasks = SocialMediaTask.query.filter_by(
            student_id=student_id,
            task_type='video-editing'
        ).order_by(SocialMediaTask.created_at.desc()).all()
        
        return jsonify({
            'success': True,
            'tasks': [t.to_dict() for t in tasks]
        }), 200
        
    except Exception as e:
        logger.error(f"Tasks error: {str(e)}")
        return jsonify({'error': 'Failed to load tasks'}), 500


@app.route('/api/video-editing/student/progress', methods=['GET'])
def get_video_editing_student_progress():
    """Get student's progress across all weeks"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No authorization'}), 401
        
        token = auth_header.split(' ')[1]
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
        student_id = payload.get('student_id')
        
        progress_records = SocialMediaProgress.query.filter_by(
            student_id=student_id
        ).all()
        
        return jsonify({
            'success': True,
            'progress_records': [p.to_dict() for p in progress_records]
        }), 200
        
    except Exception as e:
        logger.error(f"Progress error: {str(e)}")
        return jsonify({'error': 'Failed to load progress'}), 500


@app.route('/api/video-editing/student/summary', methods=['GET'])
def get_video_editing_student_summary():
    """Get comprehensive summary of student's performance"""
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header:
            return jsonify({'error': 'No authorization'}), 401
        
        token = auth_header.split(' ')[1]
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
        student_id = payload.get('student_id')
        
        student = SocialMediaStudent.query.get(student_id)
        if not student or student.category != 'video-editing':
            return jsonify({'error': 'Student not found'}), 404
        
        tasks = SocialMediaTask.query.filter_by(
            student_id=student_id,
            task_type='video-editing'
        ).all()
        
        completed_tasks = [t for t in tasks if t.status == 'completed']
        total_lessons = len(tasks)
        lessons_completed = len(completed_tasks)
        
        overall_progress = int((lessons_completed / total_lessons * 100)) if total_lessons > 0 else 0
        
        # Calculate progress by week
        progress_by_week = []
        for week in range(1, 5):
            week_tasks = [t for t in tasks if t.week_number == week]
            week_completed = [t for t in week_tasks if t.status == 'completed']
            week_progress = int((len(week_completed) / len(week_tasks) * 100)) if week_tasks else 0
            
            progress_by_week.append({
                'week': week,
                'total_lessons': len(week_tasks),
                'completed_lessons': len(week_completed),
                'progress_percentage': week_progress,
                'time_spent': sum(int(t.duration.split()[0]) if t.duration else 0 for t in week_completed)
            })
        
        return jsonify({
            'success': True,
            'statistics': {
                'total_lessons': total_lessons,
                'lessons_completed': lessons_completed,
                'overall_progress': overall_progress,
                'total_points': student.total_points
            },
            'progress_by_week': progress_by_week
        }), 200
        
    except Exception as e:
        logger.error(f"Summary error: {str(e)}")
        return jsonify({'error': 'Failed to load summary'}), 500


@app.route('/api/video-editing/scoreboard', methods=['GET'])
def get_video_editing_scoreboard():
    """Get scoreboard of all video editing students"""
    try:
        students = SocialMediaStudent.query.filter_by(
            category='video-editing',
            is_active=True
        ).all()
        
        scoreboard = []
        for student in students:
            tasks = SocialMediaTask.query.filter_by(
                student_id=student.id,
                task_type='video-editing'
            ).all()
            
            completed_tasks = [t for t in tasks if t.status == 'completed']
            total_lessons = len(tasks)
            lessons_completed = len(completed_tasks)
            
            avg_score = sum(t.quiz_score or 0 for t in completed_tasks) / len(completed_tasks) if completed_tasks else 0
            overall_progress = int((lessons_completed / total_lessons * 100)) if total_lessons > 0 else 0
            
            scoreboard.append({
                'id': student.id,
                'name': student.full_name,
                'email': student.email,
                'average_score': round(avg_score, 1),
                'lessons_completed': lessons_completed,
                'total_lessons': total_lessons,
                'overall_progress': overall_progress
            })
        
        scoreboard.sort(key=lambda x: x['overall_progress'], reverse=True)
        
        return jsonify({
            'success': True,
            'scoreboard': scoreboard,
            'total_students': len(scoreboard)
        }), 200
        
    except Exception as e:
        logger.error(f"Scoreboard error: {str(e)}")
        return jsonify({'error': 'Failed to load scoreboard'}), 500


@app.route('/api/video-editing/task/<int:task_id>/start', methods=['POST'])
def start_video_editing_task(task_id):
    """Mark task as started (change status to in_progress)"""
    try:
        auth_header = request.headers.get('Authorization')
        token = auth_header.split(' ')[1]
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
        student_id = payload.get('student_id')
        
        task = SocialMediaTask.query.filter_by(
            id=task_id,
            student_id=student_id,
            task_type='video-editing'
        ).first()
        
        if not task:
            return jsonify({'error': 'Task not found'}), 404
        
        task.status = 'in_progress'
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Task started'
        }), 200
        
    except Exception as e:
        logger.error(f"Start task error: {str(e)}")
        return jsonify({'error': 'Failed to start task'}), 500


# Admin endpoints for video editing
@app.route('/api/admin/video-editing/students', methods=['GET'])
@admin_required
def get_video_editing_students():
    """Get all video editing students (Admin only)"""
    try:
        students = SocialMediaStudent.query.filter_by(
            category='video-editing',
            is_active=True
        ).order_by(SocialMediaStudent.full_name).all()
        
        return jsonify({
            'success': True,
            'students': [s.to_dict() for s in students],
            'total_count': len(students)
        }), 200
        
    except Exception as e:
        logger.error(f"Get video editing students error: {str(e)}")
        return jsonify({'error': 'Failed to fetch students'}), 500


@app.route('/api/admin/video-editing/assign-tasks', methods=['POST'])
@admin_required
def assign_video_editing_tasks():
    """Assign tasks to video editing students"""
    try:
        data = request.get_json()
        student_ids = data.get('student_ids', [])
        
        if not student_ids:
            return jsonify({'error': 'No students selected'}), 400
        
        task_data = {
            'task_type': 'video-editing',
            'skill_category': data.get('skill_category', 'Video Editing'),
            'task_title': data.get('task_title'),
            'task_description': data.get('task_description'),
            'week_number': data.get('week_number'),
            'day_number': data.get('day_number'),
            'lesson_type': data.get('lesson_type'),
            'video_url': data.get('video_url'),
            'duration': data.get('duration'),
            'points_reward': data.get('points_reward', 10),
            'admin_id': request.current_admin.id
        }
        
        created_tasks = []
        for student_id in student_ids:
            task = SocialMediaTask(**task_data, student_id=student_id)
            db.session.add(task)
            created_tasks.append(task)
        
        db.session.commit()
        
        logger.info(f"âœ… Admin {request.current_admin.name} assigned {len(created_tasks)} video editing tasks")
        
        return jsonify({
            'success': True,
            'message': f'Assigned tasks to {len(student_ids)} students',
            'tasks_created': len(created_tasks)
        }), 201
        
    except Exception as e:
        logger.error(f"Assign tasks error: {str(e)}")
        db.session.rollback()
        return jsonify({'error': 'Failed to assign tasks'}), 500


@app.route('/api/admin/video-editing/tasks', methods=['GET'])
@admin_required
def get_all_video_editing_tasks():
    """Get all video editing tasks (Admin view)"""
    try:
        tasks = SocialMediaTask.query.filter_by(
            task_type='video-editing'
        ).order_by(SocialMediaTask.created_at.desc()).all()
        
        return jsonify({
            'success': True,
            'tasks': [t.to_dict() for t in tasks],
            'total_count': len(tasks)
        }), 200
        
    except Exception as e:
        logger.error(f"Get tasks error: {str(e)}")
        return jsonify({'error': 'Failed to fetch tasks'}), 500


@app.route('/api/admin/video-editing/task/<int:task_id>', methods=['PUT'])
@admin_required
def update_video_editing_task(task_id):
    """Update a video editing task"""
    try:
        task = SocialMediaTask.query.filter_by(
            id=task_id,
            task_type='video-editing'
        ).first()
        
        if not task:
            return jsonify({'error': 'Task not found'}), 404
        
        data = request.get_json()
        
        # Update fields
        for field in ['task_title', 'task_description', 'week_number', 'day_number', 
                     'lesson_type', 'video_url', 'duration', 'points_reward', 'status']:
            if field in data:
                setattr(task, field, data[field])
        
        task.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Task updated successfully'
        }), 200
        
    except Exception as e:
        logger.error(f"Update task error: {str(e)}")
        db.session.rollback()
        return jsonify({'error': 'Failed to update task'}), 500


@app.route('/api/admin/video-editing/task/<int:task_id>', methods=['DELETE'])
@admin_required
def delete_video_editing_task(task_id):
    """Delete a video editing task"""
    try:
        task = SocialMediaTask.query.filter_by(
            id=task_id,
            task_type='video-editing'
        ).first()
        
        if not task:
            return jsonify({'error': 'Task not found'}), 404
        
        db.session.delete(task)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Task deleted successfully'
        }), 
        
    except Exception as e:
        logger.error(f"Delete task error: {str(e)}")
        db.session.rollback()
        return jsonify({'error': 'Failed to delete task'}), 500

# Quiz-mas Registration Routes
@app.route('/api/quiz-mas-registration', methods=['POST'])
def submit_quiz_mas_registration():
    """Submit a quiz-mas registration"""
    try:
        data = request.get_json()
        logger.info(f"Received quiz-mas registration data: {data}")

        # Validate required fields
        if not data.get('workshop'):
            return jsonify({
                'success': False,
                'error': 'Workshop selection is required'
            }), 400

        # Create registration record
        registration = QuizMasRegistration(
            workshop=data.get('workshop'),
            number_of_children=data.get('numberOfChildren', 1)
        )

        # Add child 1 data
        if data.get('childName1'):
            registration.child1_name = data.get('childName1')
            registration.child1_grade = data.get('class1')
            registration.child1_birthdate = datetime.strptime(data.get('birthdate1'), '%Y-%m-%d').date() if data.get('birthdate1') else None
            registration.child1_signed_in = data.get('signedIn1')
            registration.child1_device = data.get('device1')
            registration.child1_contact_method = data.get('contactMethod1')
            registration.child1_contact_value = data.get('contactValue1')  # NEW: Email/Phone/WhatsApp

        # Add child 2 data
        if data.get('childName2'):
            registration.child2_name = data.get('childName2')
            registration.child2_grade = data.get('class2')
            registration.child2_birthdate = datetime.strptime(data.get('birthdate2'), '%Y-%m-%d').date() if data.get('birthdate2') else None
            registration.child2_signed_in = data.get('signedIn2')
            registration.child2_device = data.get('device2')
            registration.child2_contact_method = data.get('contactMethod2')
            registration.child2_contact_value = data.get('contactValue2')  # NEW: Email/Phone/WhatsApp

        # Add child 3 data
        if data.get('childName3'):
            registration.child3_name = data.get('childName3')
            registration.child3_grade = data.get('class3')
            registration.child3_birthdate = datetime.strptime(data.get('birthdate3'), '%Y-%m-%d').date() if data.get('birthdate3') else None
            registration.child3_signed_in = data.get('signedIn3')
            registration.child3_device = data.get('device3')
            registration.child3_contact_method = data.get('contactMethod3')
            registration.child3_contact_value = data.get('contactValue3')  # NEW: Email/Phone/WhatsApp

        db.session.add(registration)
        db.session.commit()

        logger.info(f"Successfully saved registration with ID: {registration.id}")

        return jsonify({
            'success': True,
            'message': 'Registration submitted successfully',
            'registration_id': registration.id
        }), 201

    except ValueError as ve:
        logger.error(f"Validation error: {str(ve)}")
        db.session.rollback()
        return jsonify({
            'success': False,
            'error': 'Invalid data format',
            'details': str(ve)
        }), 400
    except Exception as e:
        logger.error(f"Registration error: {str(e)}")
        db.session.rollback()
        return jsonify({
            'success': False,
            'error': 'Failed to submit registration',
            'details': str(e)
        }), 500


@app.route('/api/quiz-mas-registration', methods=['GET'])
def get_quiz_mas_registration():
    """Get all quiz-mas registrations"""
    try:
        registrations = QuizMasRegistration.query.order_by(QuizMasRegistration.created_at.desc()).all()

        return jsonify({
            'success': True,
            'registrations': [reg.to_dict() for reg in registrations],
            'count': len(registrations)
        }), 200

    except Exception as e:
        logger.error(f"Failed to fetch registrations: {str(e)}")
        return jsonify({
            'success': False,
            'error': 'Failed to fetch registrations',
            'details': str(e)
        }), 500

logger.info("âœ… Video Editing API Routes Loaded")

@app.route('/zuchristmas/<path:filename>')

def serve_zuchristmas_static(filename):

    """Serves static files (css, js, images, etc.) from zuchristmas folder"""

    try:

        base_dir = os.path.dirname(os.path.abspath(__file__))

        zuchristmas_path = os.path.join(base_dir, 'zuchristmas')

 

        logger.debug(f"Serving zuchristmas static file: {filename}")

        logger.debug(f"From path: {zuchristmas_path}")

 

        return send_from_directory(zuchristmas_path, filename)

    except Exception as e:

        logger.error(f"Error serving zuchristmas static file {filename}: {str(e)}")

        return f"Error serving {filename}", 404

@app.route('/quizmas')
def serve_quizmaspage():
    """Serves the Quizmas page from zuchristmas folder"""
    try:
        logger.debug("Serving quizmas.html from zuchristmas folder")
        return send_from_directory('zuchristmas', 'quizmas.html')
    except Exception as e:
        logger.error(f"Error serving quizmas.html: {str(e)}")
        return "Error: Could not load Quizmas page", 500

@app.route('/api/quizmas-chat', methods=['POST'])
def quizmas_chat():
    """Handles Quizmas-specific chatbot inquiries with full event knowledge"""
    try:
        data = request.get_json()
        if not data or 'message' not in data:
            return jsonify({"error": "Missing 'message' field in request"}), 400

        message = data.get('message', '')
        history = data.get('history', [])

        logger.debug(f"Quizmas chat request: {message[:50]}...")

        # Quizmas event information context
        quizmas_context = """
You are an intelligent assistant for the Quizmas 2025 event by Decipher Academy.
QUIZMAS EVENT DETAILS:
- Event Name: Quiz-Mas Competition 2025
- Organizer: Decipher Academy
- Location: No. 19, Yusuf Aisiku Street, Ijegun, Lagos State
- Event Dates: December 8-20, 2025
- Grand Finale: December 19 & 20, 2025
- Platform: Zoom (Online)
COMPETITION SUBJECTS:
- Mathematics
- English Language
- General Studies
- STEM and Digital Skills Training
- Practical insights into Artificial Intelligence
STUDENT CATEGORIES:
1. Primary Category: Primary 4, 5, 6
2. Junior Category: JSS 1, 2, 3
3. Senior Category: SS 1, 2, 3
QUALIFICATION MODEL:
A) Automatic Free Qualification:
   - Schools nominate ONE top-performing student per class
   - Based on most recent test results
   - FREE entry into main competition
   - Includes: Skill training + Online sessions + Certificates
B) General Registration Slots:
   - 20 limited slots per school
   - Registration Fee: â‚¦10,000 per student
   - Open to all interested learners
   - Same benefits as nominated students
SCHOOL PARTNERSHIP BENEFITS:
- Schools receive 20% of registration fees (â‚¦10,000) for all recommended students who successfully enroll
- This is approximately â‚¦2,000 per student registered through school recommendation
WHAT STUDENTS RECEIVE:
- Guaranteed entry into Quiz-Mas Competition
- STEM & Digital Skills training sessions
- Online learning sessions
- Certificates of participation
- Prize opportunities
- Practical AI insights
CONTACT INFORMATION:
- Email: Decipheracad@gmail.com
- Phone: +234 916 081 2845
- International: +44 7979 145157
- Address: No. 19, Yusuf Aisiku Street, Ijegun, Lagos State
ABOUT DECIPHER ACADEMY:
Decipher Academy is an online educational institute committed to simplifying learning, promoting STEM education,
and helping students build confidence through fun, competitive, and value-driven learning experiences.
Founder: Mr. Valentine Okom
Answer questions accurately based on this information. Be helpful, friendly, and encouraging.
If asked about registration process, explain both the free nomination option and the general registration slots.
If asked about costs, clarify the â‚¦10,000 fee for general slots and the 20% school commission.
"""

        # Build conversation context
        conversation_context = quizmas_context + "\n\nConversation History:\n"
        for msg in history[-4:]:  # Last 4 messages
            role = "User" if msg['type'] == 'user' else "Assistant"
            conversation_context += f"{role}: {msg['content']}\n"

        conversation_context += f"\nUser: {message}\nAssistant:"

        # Call Cohere API
        response = co.chat(
            message=conversation_context,
            model="command",
            temperature=0.7,
            max_tokens=500
        )

        if hasattr(response, 'text'):
            return jsonify({'response': response.text}), 200
        else:
            logger.error("No text in Cohere response")
            return jsonify({"error": "No response generated"}), 500

    except Exception as e:
        logger.error(f"Error processing Quizmas chat request: {str(e)}")
        return jsonify({"error": f"Failed to process request: {str(e)}"}), 500


@app.route('/api/quizmas-game', methods=['POST'])
def save_quizmas_game_result():
    """Save Quiz-mas 2025 Prize Spinner Game Results (Upsert)"""
    try:
        data = request.get_json()

        # Validate required fields
        required_fields = ['name', 'grade', 'prize_won', 'time_used']
        for field in required_fields:
            if field not in data:
                return jsonify({"error": f"Missing required field: {field}"}), 400

        # Check if player already exists
        existing_player = QuizMasGameResult.query.filter_by(name=data['name']).first()

        if existing_player:
            # Update existing player's record
            existing_player.grade = int(data['grade'])
            existing_player.prize_won = data['prize_won']
            existing_player.time_used = int(data['time_used'])
            existing_player.completed = data.get('completed', False)
            existing_player.date_played = datetime.fromisoformat(data['date_played'].replace('Z', '+00:00')) if 'date_played' in data else datetime.utcnow()

            game_result = existing_player
            message = "Game result updated successfully"
            status_code = 200
            logger.info(f"Quiz-mas game result updated: {game_result.name} - Grade {game_result.grade} - Prize: {game_result.prize_won}")
        else:
            # Create new game result
            game_result = QuizMasGameResult(
                name=data['name'],
                grade=int(data['grade']),
                prize_won=data['prize_won'],
                time_used=int(data['time_used']),
                completed=data.get('completed', False),
                date_played=datetime.fromisoformat(data['date_played'].replace('Z', '+00:00')) if 'date_played' in data else datetime.utcnow()
            )
            db.session.add(game_result)
            message = "Game result saved successfully"
            status_code = 201
            logger.info(f"Quiz-mas game result created: {game_result.name} - Grade {game_result.grade} - Prize: {game_result.prize_won}")

        # Save to database
        db.session.commit()

        return jsonify({
            "success": True,
            "message": message,
            "data": game_result.to_dict()
        }), status_code

    except ValueError as e:
        logger.error(f"Invalid data format in Quizmas game submission: {str(e)}")
        return jsonify({"error": f"Invalid data format: {str(e)}"}), 400
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error saving Quizmas game result: {str(e)}")
        return jsonify({"error": f"Failed to save game result: {str(e)}"}), 500


@app.route('/api/quizmas-player/<name>', methods=['GET'])
def check_quizmas_player(name):
    """Check if a Quiz-mas player exists by name"""
    try:
        player = QuizMasGameResult.query.filter_by(name=name).first()

        if player:
            return jsonify({
                "success": True,
                "exists": True,
                "player": {
                    "name": player.name,
                    "grade": player.grade,
                    "last_prize": player.prize_won,
                    "last_played": player.date_played.isoformat() if player.date_played else None
                }
            }), 200
        else:
            return jsonify({
                "success": True,
                "exists": False,
                "player": None
            }), 200

    except Exception as e:
        logger.error(f"Error checking Quizmas player: {str(e)}")
        return jsonify({"error": f"Failed to check player: {str(e)}"}), 500


@app.route('/api/quizmas-game-results', methods=['GET'])
def get_quizmas_game_results():
    """Get all Quiz-mas game results for admin viewing"""
    try:
        # Get query parameters for filtering
        grade = request.args.get('grade', type=int)
        limit = request.args.get('limit', type=int, default=100)

        # Build query
        query = QuizMasGameResult.query

        if grade:
            query = query.filter_by(grade=grade)

        # Order by date played (most recent first) and limit results
        results = query.order_by(QuizMasGameResult.date_played.desc()).limit(limit).all()

        return jsonify({
            "success": True,
            "count": len(results),
            "results": [result.to_dict() for result in results]
        }), 200

    except Exception as e:
        logger.error(f"Error fetching Quizmas game results: {str(e)}")
        return jsonify({"error": f"Failed to fetch game results: {str(e)}"}), 500


# Automatic HTML file serving from templates folder
@app.route('/<path:filename>')
def serve_template_html(filename):
    """Automatically serve HTML files from templates folder without needing individual routes"""
    import os

    # Never serve API routes as static files
    if filename.startswith('api/'):
        abort(404)

    # If filename doesn't end with .html, try adding it
    original_filename = filename
    if not filename.endswith('.html'):
        filename = filename + '.html'

    # Define potential locations for HTML files in priority order
    template_dirs = [
        'templates',
        'templates/tutoring',
        '.'  # Also check root directory for backward compatibility
    ]

    # Try to find and serve the file from each directory
    for directory in template_dirs:
        file_path = os.path.join(directory, filename)
        if os.path.isfile(file_path):
            logger.info(f"Serving {filename} from {directory}")
            return send_from_directory(directory, filename)

    # If still not found and we added .html, try the original filename
    if original_filename != filename:
        for directory in template_dirs:
            file_path = os.path.join(directory, original_filename)
            if os.path.isfile(file_path):
                logger.info(f"Serving {original_filename} from {directory}")
                return send_from_directory(directory, original_filename)

    # If not found in any directory, return 404
    logger.warning(f"File not found: {original_filename}")
    return "File not found", 404